# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template models.py.jinja --
import os
import logging
import inspect
import warnings
from collections import OrderedDict

from pydantic import BaseModel, Field

from . import types, enums, errors, fields, bases
from ._types import FuncType
from ._compat import model_rebuild, field_validator
from ._builder import serialize_base64
from .generator import partial_models_ctx, PartialModelField


log: logging.Logger = logging.getLogger(__name__)
_created_partial_types: Set[str] = set()

class CHARACTERVECTOR(bases.BaseCHARACTERVECTOR):
    """Represents a CHARACTERVECTOR record"""

    id: _int
    text: _str

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.CHARACTERVECTORKeys']] = None,
        exclude: Optional[Iterable['types.CHARACTERVECTORKeys']] = None,
        required: Optional[Iterable['types.CHARACTERVECTORKeys']] = None,
        optional: Optional[Iterable['types.CHARACTERVECTORKeys']] = None,
        relations: Optional[Mapping['types.CHARACTERVECTORRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.CHARACTERVECTORKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _CHARACTERVECTOR_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _CHARACTERVECTOR_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _CHARACTERVECTOR_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _CHARACTERVECTOR_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "CHARACTERVECTOR" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid CHARACTERVECTOR / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'CHARACTERVECTOR',
            }
        )
        _created_partial_types.add(name)


class Classes(bases.BaseClasses):
    """Represents a Classes record"""

    id: _int
    reg_class: _str
    subclass: _str
    source: Optional[_str] = None
    notes: Optional[_str] = None
    features: Optional[_str] = None
    level: Optional[_str] = None
    description: Optional[_str] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ClassesKeys']] = None,
        exclude: Optional[Iterable['types.ClassesKeys']] = None,
        required: Optional[Iterable['types.ClassesKeys']] = None,
        optional: Optional[Iterable['types.ClassesKeys']] = None,
        relations: Optional[Mapping['types.ClassesRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ClassesKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Classes_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Classes_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Classes_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Classes_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "Classes" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Classes / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Classes',
            }
        )
        _created_partial_types.add(name)


class GeneralEquipment(bases.BaseGeneralEquipment):
    """Represents a GeneralEquipment record"""

    id: _int
    name: _str
    cost: _str
    Weight__lbs_: Optional[_str] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.GeneralEquipmentKeys']] = None,
        exclude: Optional[Iterable['types.GeneralEquipmentKeys']] = None,
        required: Optional[Iterable['types.GeneralEquipmentKeys']] = None,
        optional: Optional[Iterable['types.GeneralEquipmentKeys']] = None,
        relations: Optional[Mapping['types.GeneralEquipmentRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.GeneralEquipmentKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _GeneralEquipment_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _GeneralEquipment_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _GeneralEquipment_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _GeneralEquipment_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "GeneralEquipment" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid GeneralEquipment / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'GeneralEquipment',
            }
        )
        _created_partial_types.add(name)


class ITEMSVECTOR(bases.BaseITEMSVECTOR):
    """Represents a ITEMSVECTOR record"""

    id: _int
    text: _str

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ITEMSVECTORKeys']] = None,
        exclude: Optional[Iterable['types.ITEMSVECTORKeys']] = None,
        required: Optional[Iterable['types.ITEMSVECTORKeys']] = None,
        optional: Optional[Iterable['types.ITEMSVECTORKeys']] = None,
        relations: Optional[Mapping['types.ITEMSVECTORRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ITEMSVECTORKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _ITEMSVECTOR_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _ITEMSVECTOR_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _ITEMSVECTOR_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _ITEMSVECTOR_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "ITEMSVECTOR" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid ITEMSVECTOR / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'ITEMSVECTOR',
            }
        )
        _created_partial_types.add(name)


class MONSTERVECTOR(bases.BaseMONSTERVECTOR):
    """Represents a MONSTERVECTOR record"""

    id: _int
    text: _str

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.MONSTERVECTORKeys']] = None,
        exclude: Optional[Iterable['types.MONSTERVECTORKeys']] = None,
        required: Optional[Iterable['types.MONSTERVECTORKeys']] = None,
        optional: Optional[Iterable['types.MONSTERVECTORKeys']] = None,
        relations: Optional[Mapping['types.MONSTERVECTORRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.MONSTERVECTORKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _MONSTERVECTOR_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _MONSTERVECTOR_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _MONSTERVECTOR_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _MONSTERVECTOR_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "MONSTERVECTOR" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid MONSTERVECTOR / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'MONSTERVECTOR',
            }
        )
        _created_partial_types.add(name)


class MagicItem(bases.BaseMagicItem):
    """Represents a MagicItem record"""

    id: _int
    name: _str
    rarity: Optional[_str] = None
    attunement: Optional[_str] = None
    Cost__gp_: Optional[_int] = None
    note: Optional[_str] = None
    Armor_Cost: Optional[_int] = None
    Rare_Material: Optional[_str] = None
    AC_Bonus: Optional[_int] = None
    Save_Bonus: Optional[_int] = None
    Set_Score__Modifier_: Optional[_int] = None
    Bonus_To_Score__Y_N_: Optional[_str] = None
    Weapon_Bonus: Optional[_int] = None
    Spell_Level: Optional[_int] = None
    Unlimited_Charges__Y_N_: Optional[_str] = None
    Charges_Day__Unlimit___7_: Optional[_int] = None
    Charges_Item__Destroyed_: Optional[_int] = None
    Spells_Share_Charges: Optional[_int] = None
    Condition__1Min__Save_: Optional[_str] = None
    Consumable_Damage__Avg_: Optional[_int] = None
    Consumable_Save___Y_N_: Optional[_str] = None
    Semi_Permanent_Damage__Avg_: Optional[_int] = None
    Semi_Perm_Save___Y_N_: Optional[_str] = None
    Duration___Minutes_: Optional[_int] = None
    Permanent_Damage__Avg_: Optional[_int] = None
    Perm_Save___Y_N_: Optional[_str] = None
    Specific_Situations__Y_N_: Optional[_str] = None
    Restore_HP__Avg_: Optional[_int] = None
    MatCost: Optional[_int] = None
    ACCost: Optional[_int] = None
    SaveCost: Optional[_int] = None
    SetScore_Cost: Optional[_int] = None
    BonusScore_Cost: Optional[_int] = None
    WeaponCost: Optional[_int] = None
    Consum_Spell_Cost: Optional[_int] = None
    PermCharges_Cost: Optional[_int] = None
    Charges___Destroyed: Optional[_int] = None
    SpellShare_ChargesCost: Optional[_int] = None
    ConditionCost: Optional[_int] = None
    ConsDMG_Cost: Optional[_int] = None
    Sm_PrDMG_Cost: Optional[_int] = None
    PerDMG_Cost: Optional[_int] = None
    AVGHP_Cost: Optional[_int] = None
    MiscCost: Optional[_int] = None
    Perm_Charges_Cost: Optional[_int] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.MagicItemKeys']] = None,
        exclude: Optional[Iterable['types.MagicItemKeys']] = None,
        required: Optional[Iterable['types.MagicItemKeys']] = None,
        optional: Optional[Iterable['types.MagicItemKeys']] = None,
        relations: Optional[Mapping['types.MagicItemRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.MagicItemKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _MagicItem_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _MagicItem_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _MagicItem_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _MagicItem_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "MagicItem" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid MagicItem / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'MagicItem',
            }
        )
        _created_partial_types.add(name)


class Monster(bases.BaseMonster):
    """Represents a Monster record"""

    id: _str
    name: _str
    size: Optional[_str] = None
    type: Optional[_str] = None
    alignment: Optional[_str] = None
    habitat: Optional[_str] = None
    mainHabitat: Optional[_str] = None
    otherHabitat: Optional[_str] = None
    treasure: Optional[_str] = None
    ac: Optional[_str] = None
    hp: Optional[_str] = None
    initiative: Optional[_str] = None
    walk: Optional[_str] = None
    burrow: Optional[_str] = None
    climb: Optional[_str] = None
    fly: Optional[_str] = None
    hover: Optional[_str] = None
    swim: Optional[_str] = None
    strMod: Optional[_str] = None
    intMod: Optional[_str] = None
    dexMod: Optional[_str] = None
    wisMod: Optional[_str] = None
    conMod: Optional[_str] = None
    chaMod: Optional[_str] = None
    strSave: Optional[_str] = None
    intSave: Optional[_str] = None
    dexSave: Optional[_str] = None
    wisSave: Optional[_str] = None
    conSave: Optional[_str] = None
    chaSave: Optional[_str] = None
    proficient: Optional[_str] = None
    expertise: Optional[_str] = None
    vulnerabilities: Optional[_str] = None
    slashing: Optional[_str] = None
    immunitiesConditions: Optional[_str] = None
    immunitiesDamage: Optional[_str] = None
    blindsight: Optional[_str] = None
    darkvision: Optional[_str] = None
    truesight: Optional[_str] = None
    tremorsense: Optional[_str] = None
    passivePerception: Optional[_str] = None
    languages: Optional[_str] = None
    cr: Optional[_str] = None
    XP_: Optional[_str] = None
    pb: Optional[_str] = None
    traits: Optional[_str] = None
    legendaryResistanceCount: Optional[_str] = None
    of_Atk: Optional[_str] = None
    atk1Type: Optional[_str] = None
    atk1Mod: Optional[_str] = None
    atk1Range: Optional[_str] = None
    atk1RangeShort: Optional[_str] = None
    atk1Dam: Optional[_str] = None
    atk1DamageType: Optional[_str] = None
    atk2Type: Optional[_str] = None
    atk2Mod: Optional[_str] = None
    atk2Range: Optional[_str] = None
    atk2RangeShort: Optional[_str] = None
    atk2Dam: Optional[_str] = None
    atk2DamageType: Optional[_str] = None
    atk3Type: Optional[_str] = None
    atk3Mod: Optional[_str] = None
    atk3Range: Optional[_str] = None
    atk3RangeShort: Optional[_str] = None
    atk3Dam: Optional[_str] = None
    atk3DamageType: Optional[_str] = None
    atk4Type: Optional[_str] = None
    atk4Mod: Optional[_str] = None
    atk4Range: Optional[_str] = None
    atk4RangeShort: Optional[_str] = None
    atk4Dam: Optional[_str] = None
    atk4DamageType: Optional[_str] = None
    saveDC: Optional[_str] = None
    savingThrow: Optional[_str] = None
    actionNotes: Optional[_str] = None
    ability: Optional[_str] = None
    spellSaveDC: Optional[_str] = None
    spellSavingThrows: Optional[_str] = None
    spellAttack: Optional[_str] = None
    At_Will: Optional[_str] = None
    Day3: Optional[_str] = None
    Day2: Optional[_str] = None
    Day1: Optional[_str] = None
    bonusAction: Optional[_str] = None
    reaction: Optional[_str] = None
    amount: Optional[_str] = None
    legendaryActionSaveDC: Optional[_str] = None
    legendaryActionSavingThrow: Optional[_str] = None
    Legendary_Actions_: Optional[_str] = None
    lair: Optional[_str] = None
    xp: Optional[_str] = None
    Legendary_Resistance: Optional[_str] = None
    Legendary_Actions: Optional[_str] = None
    lairSaveDC: Optional[_str] = None
    lairSavingThrows: Optional[_str] = None
    other: Optional[_str] = None
    align: Optional[_str] = None
    speeds: Optional[_str] = None
    STR: Optional[_str] = None
    DEX: Optional[_str] = None
    CON: Optional[_str] = None
    INT: Optional[_str] = None
    WIS: Optional[_str] = None
    CHA: Optional[_str] = None
    Sav__Throws: Optional[_str] = None
    skills: Optional[_str] = None
    WRI: Optional[_str] = None
    senses: Optional[_str] = None
    additional: Optional[_str] = None
    font: Optional[_str] = None
    additionalInfo: Optional[_str] = None
    author: Optional[_str] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.MonsterKeys']] = None,
        exclude: Optional[Iterable['types.MonsterKeys']] = None,
        required: Optional[Iterable['types.MonsterKeys']] = None,
        optional: Optional[Iterable['types.MonsterKeys']] = None,
        relations: Optional[Mapping['types.MonsterRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.MonsterKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Monster_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Monster_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Monster_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Monster_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "Monster" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Monster / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Monster',
            }
        )
        _created_partial_types.add(name)


class Race(bases.BaseRace):
    """Represents a Race record"""

    id: _int
    race: _str
    str: Optional[_str] = None
    dex: Optional[_str] = None
    con: Optional[_str] = None
    int: Optional[_str] = None
    wis: Optional[_str] = None
    cha: Optional[_str] = None
    special: Optional[_str] = None
    source: _str
    notes: Optional[_str] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.RaceKeys']] = None,
        exclude: Optional[Iterable['types.RaceKeys']] = None,
        required: Optional[Iterable['types.RaceKeys']] = None,
        optional: Optional[Iterable['types.RaceKeys']] = None,
        relations: Optional[Mapping['types.RaceRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.RaceKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Race_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Race_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Race_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Race_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "Race" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Race / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Race',
            }
        )
        _created_partial_types.add(name)


class SESSION(bases.BaseSESSION):
    """Represents a SESSION record"""

    id: _int
    sessionID: _int
    text: _str

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.SESSIONKeys']] = None,
        exclude: Optional[Iterable['types.SESSIONKeys']] = None,
        required: Optional[Iterable['types.SESSIONKeys']] = None,
        optional: Optional[Iterable['types.SESSIONKeys']] = None,
        relations: Optional[Mapping['types.SESSIONRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.SESSIONKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _SESSION_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _SESSION_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _SESSION_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _SESSION_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "SESSION" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid SESSION / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'SESSION',
            }
        )
        _created_partial_types.add(name)


class SPELLSVECTOR(bases.BaseSPELLSVECTOR):
    """Represents a SPELLSVECTOR record"""

    id: _int
    text: _str

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.SPELLSVECTORKeys']] = None,
        exclude: Optional[Iterable['types.SPELLSVECTORKeys']] = None,
        required: Optional[Iterable['types.SPELLSVECTORKeys']] = None,
        optional: Optional[Iterable['types.SPELLSVECTORKeys']] = None,
        relations: Optional[Mapping['types.SPELLSVECTORRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.SPELLSVECTORKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _SPELLSVECTOR_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _SPELLSVECTOR_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _SPELLSVECTOR_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _SPELLSVECTOR_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "SPELLSVECTOR" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid SPELLSVECTOR / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'SPELLSVECTOR',
            }
        )
        _created_partial_types.add(name)


class Spell(bases.BaseSpell):
    """Represents a Spell record"""

    id: _int
    name: _str
    level: _str
    school: _str
    castingTime: _str
    duration: _str
    range: _str
    area: Optional[_str] = None
    attack: Optional[_str] = None
    save: Optional[_str] = None
    damageEffect: _str
    ritual: Optional[_str] = None
    concentration: Optional[_str] = None
    verbal: Optional[_str] = None
    somatic: Optional[_str] = None
    material: Optional[_str] = None
    material_: Optional[_str] = None
    source: _str
    details: _str
    link: _str

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.SpellKeys']] = None,
        exclude: Optional[Iterable['types.SpellKeys']] = None,
        required: Optional[Iterable['types.SpellKeys']] = None,
        optional: Optional[Iterable['types.SpellKeys']] = None,
        relations: Optional[Mapping['types.SpellRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.SpellKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Spell_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Spell_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Spell_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Spell_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "Spell" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Spell / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Spell',
            }
        )
        _created_partial_types.add(name)


class USERDATA(bases.BaseUSERDATA):
    """Represents a USERDATA record"""

    id: _int
    name: _str
    username: _str
    password: _str

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.USERDATAKeys']] = None,
        exclude: Optional[Iterable['types.USERDATAKeys']] = None,
        required: Optional[Iterable['types.USERDATAKeys']] = None,
        optional: Optional[Iterable['types.USERDATAKeys']] = None,
        relations: Optional[Mapping['types.USERDATARelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.USERDATAKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _USERDATA_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _USERDATA_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _USERDATA_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _USERDATA_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "USERDATA" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid USERDATA / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'USERDATA',
            }
        )
        _created_partial_types.add(name)



_CHARACTERVECTOR_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_CHARACTERVECTOR_fields: Dict['types.CHARACTERVECTORKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('text', {
            'name': 'text',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Classes_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_Classes_fields: Dict['types.ClassesKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('reg_class', {
            'name': 'reg_class',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('subclass', {
            'name': 'subclass',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('source', {
            'name': 'source',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('notes', {
            'name': 'notes',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('features', {
            'name': 'features',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('level', {
            'name': 'level',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_GeneralEquipment_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_GeneralEquipment_fields: Dict['types.GeneralEquipmentKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('cost', {
            'name': 'cost',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('Weight__lbs_', {
            'name': 'Weight__lbs_',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_ITEMSVECTOR_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_ITEMSVECTOR_fields: Dict['types.ITEMSVECTORKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('text', {
            'name': 'text',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_MONSTERVECTOR_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_MONSTERVECTOR_fields: Dict['types.MONSTERVECTORKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('text', {
            'name': 'text',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_MagicItem_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_MagicItem_fields: Dict['types.MagicItemKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('rarity', {
            'name': 'rarity',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('attunement', {
            'name': 'attunement',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('Cost__gp_', {
            'name': 'Cost__gp_',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('note', {
            'name': 'note',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('Armor_Cost', {
            'name': 'Armor_Cost',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('Rare_Material', {
            'name': 'Rare_Material',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('AC_Bonus', {
            'name': 'AC_Bonus',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('Save_Bonus', {
            'name': 'Save_Bonus',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('Set_Score__Modifier_', {
            'name': 'Set_Score__Modifier_',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('Bonus_To_Score__Y_N_', {
            'name': 'Bonus_To_Score__Y_N_',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('Weapon_Bonus', {
            'name': 'Weapon_Bonus',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('Spell_Level', {
            'name': 'Spell_Level',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('Unlimited_Charges__Y_N_', {
            'name': 'Unlimited_Charges__Y_N_',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('Charges_Day__Unlimit___7_', {
            'name': 'Charges_Day__Unlimit___7_',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('Charges_Item__Destroyed_', {
            'name': 'Charges_Item__Destroyed_',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('Spells_Share_Charges', {
            'name': 'Spells_Share_Charges',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('Condition__1Min__Save_', {
            'name': 'Condition__1Min__Save_',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('Consumable_Damage__Avg_', {
            'name': 'Consumable_Damage__Avg_',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('Consumable_Save___Y_N_', {
            'name': 'Consumable_Save___Y_N_',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('Semi_Permanent_Damage__Avg_', {
            'name': 'Semi_Permanent_Damage__Avg_',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('Semi_Perm_Save___Y_N_', {
            'name': 'Semi_Perm_Save___Y_N_',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('Duration___Minutes_', {
            'name': 'Duration___Minutes_',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('Permanent_Damage__Avg_', {
            'name': 'Permanent_Damage__Avg_',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('Perm_Save___Y_N_', {
            'name': 'Perm_Save___Y_N_',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('Specific_Situations__Y_N_', {
            'name': 'Specific_Situations__Y_N_',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('Restore_HP__Avg_', {
            'name': 'Restore_HP__Avg_',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('MatCost', {
            'name': 'MatCost',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('ACCost', {
            'name': 'ACCost',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('SaveCost', {
            'name': 'SaveCost',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('SetScore_Cost', {
            'name': 'SetScore_Cost',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('BonusScore_Cost', {
            'name': 'BonusScore_Cost',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('WeaponCost', {
            'name': 'WeaponCost',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('Consum_Spell_Cost', {
            'name': 'Consum_Spell_Cost',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('PermCharges_Cost', {
            'name': 'PermCharges_Cost',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('Charges___Destroyed', {
            'name': 'Charges___Destroyed',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('SpellShare_ChargesCost', {
            'name': 'SpellShare_ChargesCost',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('ConditionCost', {
            'name': 'ConditionCost',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('ConsDMG_Cost', {
            'name': 'ConsDMG_Cost',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('Sm_PrDMG_Cost', {
            'name': 'Sm_PrDMG_Cost',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('PerDMG_Cost', {
            'name': 'PerDMG_Cost',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('AVGHP_Cost', {
            'name': 'AVGHP_Cost',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('MiscCost', {
            'name': 'MiscCost',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('Perm_Charges_Cost', {
            'name': 'Perm_Charges_Cost',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Monster_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_Monster_fields: Dict['types.MonsterKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('size', {
            'name': 'size',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('type', {
            'name': 'type',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('alignment', {
            'name': 'alignment',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('habitat', {
            'name': 'habitat',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('mainHabitat', {
            'name': 'mainHabitat',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('otherHabitat', {
            'name': 'otherHabitat',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('treasure', {
            'name': 'treasure',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('ac', {
            'name': 'ac',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('hp', {
            'name': 'hp',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('initiative', {
            'name': 'initiative',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('walk', {
            'name': 'walk',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('burrow', {
            'name': 'burrow',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('climb', {
            'name': 'climb',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('fly', {
            'name': 'fly',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('hover', {
            'name': 'hover',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('swim', {
            'name': 'swim',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('strMod', {
            'name': 'strMod',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('intMod', {
            'name': 'intMod',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('dexMod', {
            'name': 'dexMod',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('wisMod', {
            'name': 'wisMod',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('conMod', {
            'name': 'conMod',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('chaMod', {
            'name': 'chaMod',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('strSave', {
            'name': 'strSave',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('intSave', {
            'name': 'intSave',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('dexSave', {
            'name': 'dexSave',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('wisSave', {
            'name': 'wisSave',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('conSave', {
            'name': 'conSave',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('chaSave', {
            'name': 'chaSave',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('proficient', {
            'name': 'proficient',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('expertise', {
            'name': 'expertise',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('vulnerabilities', {
            'name': 'vulnerabilities',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('slashing', {
            'name': 'slashing',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('immunitiesConditions', {
            'name': 'immunitiesConditions',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('immunitiesDamage', {
            'name': 'immunitiesDamage',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('blindsight', {
            'name': 'blindsight',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('darkvision', {
            'name': 'darkvision',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('truesight', {
            'name': 'truesight',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('tremorsense', {
            'name': 'tremorsense',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('passivePerception', {
            'name': 'passivePerception',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('languages', {
            'name': 'languages',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('cr', {
            'name': 'cr',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('XP_', {
            'name': 'XP_',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('pb', {
            'name': 'pb',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('traits', {
            'name': 'traits',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('legendaryResistanceCount', {
            'name': 'legendaryResistanceCount',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('of_Atk', {
            'name': 'of_Atk',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('atk1Type', {
            'name': 'atk1Type',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('atk1Mod', {
            'name': 'atk1Mod',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('atk1Range', {
            'name': 'atk1Range',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('atk1RangeShort', {
            'name': 'atk1RangeShort',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('atk1Dam', {
            'name': 'atk1Dam',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('atk1DamageType', {
            'name': 'atk1DamageType',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('atk2Type', {
            'name': 'atk2Type',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('atk2Mod', {
            'name': 'atk2Mod',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('atk2Range', {
            'name': 'atk2Range',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('atk2RangeShort', {
            'name': 'atk2RangeShort',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('atk2Dam', {
            'name': 'atk2Dam',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('atk2DamageType', {
            'name': 'atk2DamageType',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('atk3Type', {
            'name': 'atk3Type',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('atk3Mod', {
            'name': 'atk3Mod',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('atk3Range', {
            'name': 'atk3Range',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('atk3RangeShort', {
            'name': 'atk3RangeShort',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('atk3Dam', {
            'name': 'atk3Dam',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('atk3DamageType', {
            'name': 'atk3DamageType',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('atk4Type', {
            'name': 'atk4Type',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('atk4Mod', {
            'name': 'atk4Mod',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('atk4Range', {
            'name': 'atk4Range',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('atk4RangeShort', {
            'name': 'atk4RangeShort',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('atk4Dam', {
            'name': 'atk4Dam',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('atk4DamageType', {
            'name': 'atk4DamageType',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('saveDC', {
            'name': 'saveDC',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('savingThrow', {
            'name': 'savingThrow',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('actionNotes', {
            'name': 'actionNotes',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('ability', {
            'name': 'ability',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('spellSaveDC', {
            'name': 'spellSaveDC',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('spellSavingThrows', {
            'name': 'spellSavingThrows',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('spellAttack', {
            'name': 'spellAttack',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('At_Will', {
            'name': 'At_Will',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('Day3', {
            'name': 'Day3',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('Day2', {
            'name': 'Day2',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('Day1', {
            'name': 'Day1',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('bonusAction', {
            'name': 'bonusAction',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('reaction', {
            'name': 'reaction',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('amount', {
            'name': 'amount',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('legendaryActionSaveDC', {
            'name': 'legendaryActionSaveDC',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('legendaryActionSavingThrow', {
            'name': 'legendaryActionSavingThrow',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('Legendary_Actions_', {
            'name': 'Legendary_Actions_',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('lair', {
            'name': 'lair',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('xp', {
            'name': 'xp',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('Legendary_Resistance', {
            'name': 'Legendary_Resistance',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('Legendary_Actions', {
            'name': 'Legendary_Actions',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('lairSaveDC', {
            'name': 'lairSaveDC',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('lairSavingThrows', {
            'name': 'lairSavingThrows',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('other', {
            'name': 'other',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('align', {
            'name': 'align',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('speeds', {
            'name': 'speeds',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('STR', {
            'name': 'STR',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('DEX', {
            'name': 'DEX',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('CON', {
            'name': 'CON',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('INT', {
            'name': 'INT',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('WIS', {
            'name': 'WIS',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('CHA', {
            'name': 'CHA',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('Sav__Throws', {
            'name': 'Sav__Throws',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('skills', {
            'name': 'skills',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('WRI', {
            'name': 'WRI',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('senses', {
            'name': 'senses',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('additional', {
            'name': 'additional',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('font', {
            'name': 'font',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('additionalInfo', {
            'name': 'additionalInfo',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('author', {
            'name': 'author',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Race_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_Race_fields: Dict['types.RaceKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('race', {
            'name': 'race',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('str', {
            'name': 'str',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('dex', {
            'name': 'dex',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('con', {
            'name': 'con',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('int', {
            'name': 'int',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('wis', {
            'name': 'wis',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('cha', {
            'name': 'cha',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('special', {
            'name': 'special',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('source', {
            'name': 'source',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('notes', {
            'name': 'notes',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_SESSION_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_SESSION_fields: Dict['types.SESSIONKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('sessionID', {
            'name': 'sessionID',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('text', {
            'name': 'text',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_SPELLSVECTOR_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_SPELLSVECTOR_fields: Dict['types.SPELLSVECTORKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('text', {
            'name': 'text',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Spell_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_Spell_fields: Dict['types.SpellKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('level', {
            'name': 'level',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('school', {
            'name': 'school',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('castingTime', {
            'name': 'castingTime',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('duration', {
            'name': 'duration',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('range', {
            'name': 'range',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('area', {
            'name': 'area',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('attack', {
            'name': 'attack',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('save', {
            'name': 'save',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('damageEffect', {
            'name': 'damageEffect',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('ritual', {
            'name': 'ritual',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('concentration', {
            'name': 'concentration',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('verbal', {
            'name': 'verbal',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('somatic', {
            'name': 'somatic',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('material', {
            'name': 'material',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('material_', {
            'name': 'material_',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('source', {
            'name': 'source',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('details', {
            'name': 'details',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('link', {
            'name': 'link',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_USERDATA_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_USERDATA_fields: Dict['types.USERDATAKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('username', {
            'name': 'username',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('password', {
            'name': 'password',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)



# we have to import ourselves as relation types are namespaced to models
# e.g. models.Post
from . import models, actions

# required to support relationships between models
model_rebuild(CHARACTERVECTOR)
model_rebuild(Classes)
model_rebuild(GeneralEquipment)
model_rebuild(ITEMSVECTOR)
model_rebuild(MONSTERVECTOR)
model_rebuild(MagicItem)
model_rebuild(Monster)
model_rebuild(Race)
model_rebuild(SESSION)
model_rebuild(SPELLSVECTOR)
model_rebuild(Spell)
model_rebuild(USERDATA)
