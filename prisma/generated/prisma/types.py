# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template types.py.jinja --
from typing import TypeVar

import httpx
from . import _types
from .utils import _NoneType



# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = _types.SortMode
SortOrder = _types.SortOrder

MetricsFormat = _types.MetricsFormat

DatasourceOverride = _types.DatasourceOverride
HttpConfig = _types.HttpConfig


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    List[Any],
    Dict[None, Any],
    Dict[bool, Any],
    Dict[float, Any],
    Dict[int, Any],
    Dict[str, Any],
]


    

StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive1'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive1 = TypedDict(
    'StringFilterRecursive1',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive2'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive2 = TypedDict(
    'StringFilterRecursive2',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive3'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive3 = TypedDict(
    'StringFilterRecursive3',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive4'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive4 = TypedDict(
    'StringFilterRecursive4',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
                'mode': SortMode,
        'search': str,
    },
    total=False,
)


class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


    

DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive1'],
    },
    total=False,
)


DateTimeFilterRecursive1 = TypedDict(
    'DateTimeFilterRecursive1',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive2'],
    },
    total=False,
)


DateTimeFilterRecursive2 = TypedDict(
    'DateTimeFilterRecursive2',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive3'],
    },
    total=False,
)


DateTimeFilterRecursive3 = TypedDict(
    'DateTimeFilterRecursive3',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive4'],
    },
    total=False,
)


DateTimeFilterRecursive4 = TypedDict(
    'DateTimeFilterRecursive4',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
            },
    total=False,
)


class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


    

BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive1'],
    },
    total=False,
)


BooleanFilterRecursive1 = TypedDict(
    'BooleanFilterRecursive1',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive2'],
    },
    total=False,
)


BooleanFilterRecursive2 = TypedDict(
    'BooleanFilterRecursive2',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive3'],
    },
    total=False,
)


BooleanFilterRecursive3 = TypedDict(
    'BooleanFilterRecursive3',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive4'],
    },
    total=False,
)


BooleanFilterRecursive4 = TypedDict(
    'BooleanFilterRecursive4',
    {
        'equals': bool,
            },
    total=False,
)


class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


    

IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive1'],
    },
    total=False,
)


IntFilterRecursive1 = TypedDict(
    'IntFilterRecursive1',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive2'],
    },
    total=False,
)


IntFilterRecursive2 = TypedDict(
    'IntFilterRecursive2',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive3'],
    },
    total=False,
)


IntFilterRecursive3 = TypedDict(
    'IntFilterRecursive3',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive4'],
    },
    total=False,
)


IntFilterRecursive4 = TypedDict(
    'IntFilterRecursive4',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
            },
    total=False,
)


class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
    

FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive1'],
    },
    total=False,
)


FloatFilterRecursive1 = TypedDict(
    'FloatFilterRecursive1',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive2'],
    },
    total=False,
)


FloatFilterRecursive2 = TypedDict(
    'FloatFilterRecursive2',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive3'],
    },
    total=False,
)


FloatFilterRecursive3 = TypedDict(
    'FloatFilterRecursive3',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive4'],
    },
    total=False,
)


FloatFilterRecursive4 = TypedDict(
    'FloatFilterRecursive4',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
            },
    total=False,
)


class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


    

BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive1'],
    },
    total=False,
)


BytesFilterRecursive1 = TypedDict(
    'BytesFilterRecursive1',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive2'],
    },
    total=False,
)


BytesFilterRecursive2 = TypedDict(
    'BytesFilterRecursive2',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive3'],
    },
    total=False,
)


BytesFilterRecursive3 = TypedDict(
    'BytesFilterRecursive3',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive4'],
    },
    total=False,
)


BytesFilterRecursive4 = TypedDict(
    'BytesFilterRecursive4',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
            },
    total=False,
)


class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


    

DecimalFilter = TypedDict(
    'DecimalFilter',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive1'],
    },
    total=False,
)


DecimalFilterRecursive1 = TypedDict(
    'DecimalFilterRecursive1',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive2'],
    },
    total=False,
)


DecimalFilterRecursive2 = TypedDict(
    'DecimalFilterRecursive2',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive3'],
    },
    total=False,
)


DecimalFilterRecursive3 = TypedDict(
    'DecimalFilterRecursive3',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive4'],
    },
    total=False,
)


DecimalFilterRecursive4 = TypedDict(
    'DecimalFilterRecursive4',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
            },
    total=False,
)


class DecimalWithAggregatesFilter(StringFilter, total=False):
    _max: 'DecimalFilter'
    _min: 'DecimalFilter'
    _sum: 'DecimalFilter'
    _avg: 'DecimalFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: Optional[List[_str]]


class _StringListFilterHasInput(TypedDict):
    has: _str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: List[_str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: List[_str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: List[_str]


class _StringListUpdatePush(TypedDict):
    push: List[_str]


StringListUpdate = Union[
    List[_str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Base64']]


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: List['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: List['fields.Base64']


BytesListUpdate = Union[
    List['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: Optional[List[datetime.datetime]]


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: List[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: List[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: List[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: List[datetime.datetime]


DateTimeListUpdate = Union[
    List[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: Optional[List[_bool]]


class _BooleanListFilterHasInput(TypedDict):
    has: _bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: List[_bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: List[_bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: List[_bool]


class _BooleanListUpdatePush(TypedDict):
    push: List[_bool]


BooleanListUpdate = Union[
    List[_bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _IntListFilterHasInput(TypedDict):
    has: _int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: List[_int]


class _IntListUpdatePush(TypedDict):
    push: List[_int]


IntListUpdate = Union[
    List[_int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _BigIntListFilterHasInput(TypedDict):
    has: _int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: List[_int]


class _BigIntListUpdatePush(TypedDict):
    push: List[_int]


BigIntListUpdate = Union[
    List[_int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: Optional[List[_float]]


class _FloatListFilterHasInput(TypedDict):
    has: _float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: List[_float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: List[_float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: List[_float]


class _FloatListUpdatePush(TypedDict):
    push: List[_float]


FloatListUpdate = Union[
    List[_float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Json']]


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: List['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: List['fields.Json']


JsonListUpdate = Union[
    List['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]

class _DecimalListFilterEqualsInput(TypedDict):
    equals: Optional[List[decimal.Decimal]]


class _DecimalListFilterHasInput(TypedDict):
    has: decimal.Decimal


class _DecimalListFilterHasEveryInput(TypedDict):
    has_every: List[decimal.Decimal]


class _DecimalListFilterHasSomeInput(TypedDict):
    has_some: List[decimal.Decimal]


class _DecimalListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DecimalListFilter = Union[
    _DecimalListFilterHasInput,
    _DecimalListFilterEqualsInput,
    _DecimalListFilterHasSomeInput,
    _DecimalListFilterIsEmptyInput,
    _DecimalListFilterHasEveryInput,
]


class _DecimalListUpdateSet(TypedDict):
    set: List[decimal.Decimal]


class _DecimalListUpdatePush(TypedDict):
    push: List[decimal.Decimal]


DecimalListUpdate = Union[
    List[decimal.Decimal],
    _DecimalListUpdateSet,
    _DecimalListUpdatePush,
]


# Monster types

class MonsterOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Monster create method"""
    id: _str
    size: Optional[_str]
    type: Optional[_str]
    alignment: Optional[_str]
    habitat: Optional[_str]
    mainHabitat: Optional[_str]
    otherHabitat: Optional[_str]
    treasure: Optional[_str]
    ac: Optional[_str]
    hp: Optional[_str]
    initiative: Optional[_str]
    walk: Optional[_str]
    burrow: Optional[_str]
    climb: Optional[_str]
    fly: Optional[_str]
    hover: Optional[_str]
    swim: Optional[_str]
    strMod: Optional[_str]
    intMod: Optional[_str]
    dexMod: Optional[_str]
    wisMod: Optional[_str]
    conMod: Optional[_str]
    chaMod: Optional[_str]
    strSave: Optional[_str]
    intSave: Optional[_str]
    dexSave: Optional[_str]
    wisSave: Optional[_str]
    conSave: Optional[_str]
    chaSave: Optional[_str]
    proficient: Optional[_str]
    expertise: Optional[_str]
    vulnerabilities: Optional[_str]
    slashing: Optional[_str]
    immunitiesConditions: Optional[_str]
    immunitiesDamage: Optional[_str]
    blindsight: Optional[_str]
    darkvision: Optional[_str]
    truesight: Optional[_str]
    tremorsense: Optional[_str]
    passivePerception: Optional[_str]
    languages: Optional[_str]
    cr: Optional[_str]
    xpVal: Optional[_str]
    pb: Optional[_str]
    traits: Optional[_str]
    legendaryResistanceCount: Optional[_str]
    numberOfAtk: Optional[_str]
    atk1Type: Optional[_str]
    atk1Mod: Optional[_str]
    atk1Range: Optional[_str]
    atk1RangeShort: Optional[_str]
    atk1Dam: Optional[_str]
    atk1DamageType: Optional[_str]
    atk2Type: Optional[_str]
    atk2Mod: Optional[_str]
    atk2Range: Optional[_str]
    atk2RangeShort: Optional[_str]
    atk2Dam: Optional[_str]
    atk2DamageType: Optional[_str]
    atk3Type: Optional[_str]
    atk3Mod: Optional[_str]
    atk3Range: Optional[_str]
    atk3RangeShort: Optional[_str]
    atk3Dam: Optional[_str]
    atk3DamageType: Optional[_str]
    atk4Type: Optional[_str]
    atk4Mod: Optional[_str]
    atk4Range: Optional[_str]
    atk4RangeShort: Optional[_str]
    atk4Dam: Optional[_str]
    atk4DamageType: Optional[_str]
    saveDC: Optional[_str]
    savingThrow: Optional[_str]
    actionNotes: Optional[_str]
    ability: Optional[_str]
    spellSaveDC: Optional[_str]
    spellSavingThrows: Optional[_str]
    spellAttack: Optional[_str]
    atWillSpells: Optional[_str]
    threePerDaySpells: Optional[_str]
    twoPerDaySpells: Optional[_str]
    onePerDaySpells: Optional[_str]
    bonusAction: Optional[_str]
    reaction: Optional[_str]
    amount: Optional[_str]
    legendaryActionSaveDC: Optional[_str]
    legendaryActionSavingThrow: Optional[_str]
    legendaryActions: Optional[_str]
    lair: Optional[_str]
    xpLair: Optional[_str]
    legendaryResistance: Optional[_str]
    legendaryActionsLair: Optional[_str]
    lairSaveDC: Optional[_str]
    lairSavingThrows: Optional[_str]
    other: Optional[_str]
    align: Optional[_str]
    speeds: Optional[_str]
    strScore: Optional[_str]
    dexScore: Optional[_str]
    conScore: Optional[_str]
    intScore: Optional[_str]
    wisScore: Optional[_str]
    chaScore: Optional[_str]
    savThrows: Optional[_str]
    skills: Optional[_str]
    wri: Optional[_str]
    senses: Optional[_str]
    additional: Optional[_str]
    font: Optional[_str]
    additionalInfo: Optional[_str]
    author: Optional[_str]


class MonsterCreateInput(MonsterOptionalCreateInput):
    """Required arguments to the Monster create method"""
    name: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class MonsterOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Monster create method, without relations"""
    id: _str
    size: Optional[_str]
    type: Optional[_str]
    alignment: Optional[_str]
    habitat: Optional[_str]
    mainHabitat: Optional[_str]
    otherHabitat: Optional[_str]
    treasure: Optional[_str]
    ac: Optional[_str]
    hp: Optional[_str]
    initiative: Optional[_str]
    walk: Optional[_str]
    burrow: Optional[_str]
    climb: Optional[_str]
    fly: Optional[_str]
    hover: Optional[_str]
    swim: Optional[_str]
    strMod: Optional[_str]
    intMod: Optional[_str]
    dexMod: Optional[_str]
    wisMod: Optional[_str]
    conMod: Optional[_str]
    chaMod: Optional[_str]
    strSave: Optional[_str]
    intSave: Optional[_str]
    dexSave: Optional[_str]
    wisSave: Optional[_str]
    conSave: Optional[_str]
    chaSave: Optional[_str]
    proficient: Optional[_str]
    expertise: Optional[_str]
    vulnerabilities: Optional[_str]
    slashing: Optional[_str]
    immunitiesConditions: Optional[_str]
    immunitiesDamage: Optional[_str]
    blindsight: Optional[_str]
    darkvision: Optional[_str]
    truesight: Optional[_str]
    tremorsense: Optional[_str]
    passivePerception: Optional[_str]
    languages: Optional[_str]
    cr: Optional[_str]
    xpVal: Optional[_str]
    pb: Optional[_str]
    traits: Optional[_str]
    legendaryResistanceCount: Optional[_str]
    numberOfAtk: Optional[_str]
    atk1Type: Optional[_str]
    atk1Mod: Optional[_str]
    atk1Range: Optional[_str]
    atk1RangeShort: Optional[_str]
    atk1Dam: Optional[_str]
    atk1DamageType: Optional[_str]
    atk2Type: Optional[_str]
    atk2Mod: Optional[_str]
    atk2Range: Optional[_str]
    atk2RangeShort: Optional[_str]
    atk2Dam: Optional[_str]
    atk2DamageType: Optional[_str]
    atk3Type: Optional[_str]
    atk3Mod: Optional[_str]
    atk3Range: Optional[_str]
    atk3RangeShort: Optional[_str]
    atk3Dam: Optional[_str]
    atk3DamageType: Optional[_str]
    atk4Type: Optional[_str]
    atk4Mod: Optional[_str]
    atk4Range: Optional[_str]
    atk4RangeShort: Optional[_str]
    atk4Dam: Optional[_str]
    atk4DamageType: Optional[_str]
    saveDC: Optional[_str]
    savingThrow: Optional[_str]
    actionNotes: Optional[_str]
    ability: Optional[_str]
    spellSaveDC: Optional[_str]
    spellSavingThrows: Optional[_str]
    spellAttack: Optional[_str]
    atWillSpells: Optional[_str]
    threePerDaySpells: Optional[_str]
    twoPerDaySpells: Optional[_str]
    onePerDaySpells: Optional[_str]
    bonusAction: Optional[_str]
    reaction: Optional[_str]
    amount: Optional[_str]
    legendaryActionSaveDC: Optional[_str]
    legendaryActionSavingThrow: Optional[_str]
    legendaryActions: Optional[_str]
    lair: Optional[_str]
    xpLair: Optional[_str]
    legendaryResistance: Optional[_str]
    legendaryActionsLair: Optional[_str]
    lairSaveDC: Optional[_str]
    lairSavingThrows: Optional[_str]
    other: Optional[_str]
    align: Optional[_str]
    speeds: Optional[_str]
    strScore: Optional[_str]
    dexScore: Optional[_str]
    conScore: Optional[_str]
    intScore: Optional[_str]
    wisScore: Optional[_str]
    chaScore: Optional[_str]
    savThrows: Optional[_str]
    skills: Optional[_str]
    wri: Optional[_str]
    senses: Optional[_str]
    additional: Optional[_str]
    font: Optional[_str]
    additionalInfo: Optional[_str]
    author: Optional[_str]


class MonsterCreateWithoutRelationsInput(MonsterOptionalCreateWithoutRelationsInput):
    """Required arguments to the Monster create method, without relations"""
    name: _str

class MonsterConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'MonsterCreateWithoutRelationsInput'
    where: 'MonsterWhereUniqueInput'

class MonsterCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'MonsterCreateWithoutRelationsInput'
    connect: 'MonsterWhereUniqueInput'
    connect_or_create: 'MonsterConnectOrCreateWithoutRelationsInput'


class MonsterCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['MonsterCreateWithoutRelationsInput', List['MonsterCreateWithoutRelationsInput']]
    connect: Union['MonsterWhereUniqueInput', List['MonsterWhereUniqueInput']]
    connect_or_create: Union['MonsterConnectOrCreateWithoutRelationsInput', List['MonsterConnectOrCreateWithoutRelationsInput']]

_MonsterWhereUnique_id_Input = TypedDict(
    '_MonsterWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

MonsterWhereUniqueInput = _MonsterWhereUnique_id_Input


class MonsterUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    name: _str
    size: Optional[_str]
    type: Optional[_str]
    alignment: Optional[_str]
    habitat: Optional[_str]
    mainHabitat: Optional[_str]
    otherHabitat: Optional[_str]
    treasure: Optional[_str]
    ac: Optional[_str]
    hp: Optional[_str]
    initiative: Optional[_str]
    walk: Optional[_str]
    burrow: Optional[_str]
    climb: Optional[_str]
    fly: Optional[_str]
    hover: Optional[_str]
    swim: Optional[_str]
    strMod: Optional[_str]
    intMod: Optional[_str]
    dexMod: Optional[_str]
    wisMod: Optional[_str]
    conMod: Optional[_str]
    chaMod: Optional[_str]
    strSave: Optional[_str]
    intSave: Optional[_str]
    dexSave: Optional[_str]
    wisSave: Optional[_str]
    conSave: Optional[_str]
    chaSave: Optional[_str]
    proficient: Optional[_str]
    expertise: Optional[_str]
    vulnerabilities: Optional[_str]
    slashing: Optional[_str]
    immunitiesConditions: Optional[_str]
    immunitiesDamage: Optional[_str]
    blindsight: Optional[_str]
    darkvision: Optional[_str]
    truesight: Optional[_str]
    tremorsense: Optional[_str]
    passivePerception: Optional[_str]
    languages: Optional[_str]
    cr: Optional[_str]
    xpVal: Optional[_str]
    pb: Optional[_str]
    traits: Optional[_str]
    legendaryResistanceCount: Optional[_str]
    numberOfAtk: Optional[_str]
    atk1Type: Optional[_str]
    atk1Mod: Optional[_str]
    atk1Range: Optional[_str]
    atk1RangeShort: Optional[_str]
    atk1Dam: Optional[_str]
    atk1DamageType: Optional[_str]
    atk2Type: Optional[_str]
    atk2Mod: Optional[_str]
    atk2Range: Optional[_str]
    atk2RangeShort: Optional[_str]
    atk2Dam: Optional[_str]
    atk2DamageType: Optional[_str]
    atk3Type: Optional[_str]
    atk3Mod: Optional[_str]
    atk3Range: Optional[_str]
    atk3RangeShort: Optional[_str]
    atk3Dam: Optional[_str]
    atk3DamageType: Optional[_str]
    atk4Type: Optional[_str]
    atk4Mod: Optional[_str]
    atk4Range: Optional[_str]
    atk4RangeShort: Optional[_str]
    atk4Dam: Optional[_str]
    atk4DamageType: Optional[_str]
    saveDC: Optional[_str]
    savingThrow: Optional[_str]
    actionNotes: Optional[_str]
    ability: Optional[_str]
    spellSaveDC: Optional[_str]
    spellSavingThrows: Optional[_str]
    spellAttack: Optional[_str]
    atWillSpells: Optional[_str]
    threePerDaySpells: Optional[_str]
    twoPerDaySpells: Optional[_str]
    onePerDaySpells: Optional[_str]
    bonusAction: Optional[_str]
    reaction: Optional[_str]
    amount: Optional[_str]
    legendaryActionSaveDC: Optional[_str]
    legendaryActionSavingThrow: Optional[_str]
    legendaryActions: Optional[_str]
    lair: Optional[_str]
    xpLair: Optional[_str]
    legendaryResistance: Optional[_str]
    legendaryActionsLair: Optional[_str]
    lairSaveDC: Optional[_str]
    lairSavingThrows: Optional[_str]
    other: Optional[_str]
    align: Optional[_str]
    speeds: Optional[_str]
    strScore: Optional[_str]
    dexScore: Optional[_str]
    conScore: Optional[_str]
    intScore: Optional[_str]
    wisScore: Optional[_str]
    chaScore: Optional[_str]
    savThrows: Optional[_str]
    skills: Optional[_str]
    wri: Optional[_str]
    senses: Optional[_str]
    additional: Optional[_str]
    font: Optional[_str]
    additionalInfo: Optional[_str]
    author: Optional[_str]


class MonsterUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    name: _str
    size: Optional[_str]
    type: Optional[_str]
    alignment: Optional[_str]
    habitat: Optional[_str]
    mainHabitat: Optional[_str]
    otherHabitat: Optional[_str]
    treasure: Optional[_str]
    ac: Optional[_str]
    hp: Optional[_str]
    initiative: Optional[_str]
    walk: Optional[_str]
    burrow: Optional[_str]
    climb: Optional[_str]
    fly: Optional[_str]
    hover: Optional[_str]
    swim: Optional[_str]
    strMod: Optional[_str]
    intMod: Optional[_str]
    dexMod: Optional[_str]
    wisMod: Optional[_str]
    conMod: Optional[_str]
    chaMod: Optional[_str]
    strSave: Optional[_str]
    intSave: Optional[_str]
    dexSave: Optional[_str]
    wisSave: Optional[_str]
    conSave: Optional[_str]
    chaSave: Optional[_str]
    proficient: Optional[_str]
    expertise: Optional[_str]
    vulnerabilities: Optional[_str]
    slashing: Optional[_str]
    immunitiesConditions: Optional[_str]
    immunitiesDamage: Optional[_str]
    blindsight: Optional[_str]
    darkvision: Optional[_str]
    truesight: Optional[_str]
    tremorsense: Optional[_str]
    passivePerception: Optional[_str]
    languages: Optional[_str]
    cr: Optional[_str]
    xpVal: Optional[_str]
    pb: Optional[_str]
    traits: Optional[_str]
    legendaryResistanceCount: Optional[_str]
    numberOfAtk: Optional[_str]
    atk1Type: Optional[_str]
    atk1Mod: Optional[_str]
    atk1Range: Optional[_str]
    atk1RangeShort: Optional[_str]
    atk1Dam: Optional[_str]
    atk1DamageType: Optional[_str]
    atk2Type: Optional[_str]
    atk2Mod: Optional[_str]
    atk2Range: Optional[_str]
    atk2RangeShort: Optional[_str]
    atk2Dam: Optional[_str]
    atk2DamageType: Optional[_str]
    atk3Type: Optional[_str]
    atk3Mod: Optional[_str]
    atk3Range: Optional[_str]
    atk3RangeShort: Optional[_str]
    atk3Dam: Optional[_str]
    atk3DamageType: Optional[_str]
    atk4Type: Optional[_str]
    atk4Mod: Optional[_str]
    atk4Range: Optional[_str]
    atk4RangeShort: Optional[_str]
    atk4Dam: Optional[_str]
    atk4DamageType: Optional[_str]
    saveDC: Optional[_str]
    savingThrow: Optional[_str]
    actionNotes: Optional[_str]
    ability: Optional[_str]
    spellSaveDC: Optional[_str]
    spellSavingThrows: Optional[_str]
    spellAttack: Optional[_str]
    atWillSpells: Optional[_str]
    threePerDaySpells: Optional[_str]
    twoPerDaySpells: Optional[_str]
    onePerDaySpells: Optional[_str]
    bonusAction: Optional[_str]
    reaction: Optional[_str]
    amount: Optional[_str]
    legendaryActionSaveDC: Optional[_str]
    legendaryActionSavingThrow: Optional[_str]
    legendaryActions: Optional[_str]
    lair: Optional[_str]
    xpLair: Optional[_str]
    legendaryResistance: Optional[_str]
    legendaryActionsLair: Optional[_str]
    lairSaveDC: Optional[_str]
    lairSavingThrows: Optional[_str]
    other: Optional[_str]
    align: Optional[_str]
    speeds: Optional[_str]
    strScore: Optional[_str]
    dexScore: Optional[_str]
    conScore: Optional[_str]
    intScore: Optional[_str]
    wisScore: Optional[_str]
    chaScore: Optional[_str]
    savThrows: Optional[_str]
    skills: Optional[_str]
    wri: Optional[_str]
    senses: Optional[_str]
    additional: Optional[_str]
    font: Optional[_str]
    additionalInfo: Optional[_str]
    author: Optional[_str]


class MonsterUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['MonsterCreateWithoutRelationsInput']
    connect: List['MonsterWhereUniqueInput']
    connect_or_create: List['MonsterConnectOrCreateWithoutRelationsInput']
    set: List['MonsterWhereUniqueInput']
    disconnect: List['MonsterWhereUniqueInput']
    delete: List['MonsterWhereUniqueInput']

    # TODO
    # update: List['MonsterUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['MonsterUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['MonsterScalarWhereInput']
    # upsert: List['MonsterUpserteWithWhereUniqueWithoutRelationsInput']


class MonsterUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'MonsterCreateWithoutRelationsInput'
    connect: 'MonsterWhereUniqueInput'
    connect_or_create: 'MonsterConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'MonsterUpdateInput'
    # upsert: 'MonsterUpsertWithoutRelationsInput'


class MonsterUpsertInput(TypedDict):
    create: 'MonsterCreateInput'
    update: 'MonsterUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Monster_id_OrderByInput = TypedDict(
    '_Monster_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Monster_name_OrderByInput = TypedDict(
    '_Monster_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Monster_size_OrderByInput = TypedDict(
    '_Monster_size_OrderByInput',
    {
        'size': 'SortOrder',
    },
    total=True
)

_Monster_type_OrderByInput = TypedDict(
    '_Monster_type_OrderByInput',
    {
        'type': 'SortOrder',
    },
    total=True
)

_Monster_alignment_OrderByInput = TypedDict(
    '_Monster_alignment_OrderByInput',
    {
        'alignment': 'SortOrder',
    },
    total=True
)

_Monster_habitat_OrderByInput = TypedDict(
    '_Monster_habitat_OrderByInput',
    {
        'habitat': 'SortOrder',
    },
    total=True
)

_Monster_mainHabitat_OrderByInput = TypedDict(
    '_Monster_mainHabitat_OrderByInput',
    {
        'mainHabitat': 'SortOrder',
    },
    total=True
)

_Monster_otherHabitat_OrderByInput = TypedDict(
    '_Monster_otherHabitat_OrderByInput',
    {
        'otherHabitat': 'SortOrder',
    },
    total=True
)

_Monster_treasure_OrderByInput = TypedDict(
    '_Monster_treasure_OrderByInput',
    {
        'treasure': 'SortOrder',
    },
    total=True
)

_Monster_ac_OrderByInput = TypedDict(
    '_Monster_ac_OrderByInput',
    {
        'ac': 'SortOrder',
    },
    total=True
)

_Monster_hp_OrderByInput = TypedDict(
    '_Monster_hp_OrderByInput',
    {
        'hp': 'SortOrder',
    },
    total=True
)

_Monster_initiative_OrderByInput = TypedDict(
    '_Monster_initiative_OrderByInput',
    {
        'initiative': 'SortOrder',
    },
    total=True
)

_Monster_walk_OrderByInput = TypedDict(
    '_Monster_walk_OrderByInput',
    {
        'walk': 'SortOrder',
    },
    total=True
)

_Monster_burrow_OrderByInput = TypedDict(
    '_Monster_burrow_OrderByInput',
    {
        'burrow': 'SortOrder',
    },
    total=True
)

_Monster_climb_OrderByInput = TypedDict(
    '_Monster_climb_OrderByInput',
    {
        'climb': 'SortOrder',
    },
    total=True
)

_Monster_fly_OrderByInput = TypedDict(
    '_Monster_fly_OrderByInput',
    {
        'fly': 'SortOrder',
    },
    total=True
)

_Monster_hover_OrderByInput = TypedDict(
    '_Monster_hover_OrderByInput',
    {
        'hover': 'SortOrder',
    },
    total=True
)

_Monster_swim_OrderByInput = TypedDict(
    '_Monster_swim_OrderByInput',
    {
        'swim': 'SortOrder',
    },
    total=True
)

_Monster_strMod_OrderByInput = TypedDict(
    '_Monster_strMod_OrderByInput',
    {
        'strMod': 'SortOrder',
    },
    total=True
)

_Monster_intMod_OrderByInput = TypedDict(
    '_Monster_intMod_OrderByInput',
    {
        'intMod': 'SortOrder',
    },
    total=True
)

_Monster_dexMod_OrderByInput = TypedDict(
    '_Monster_dexMod_OrderByInput',
    {
        'dexMod': 'SortOrder',
    },
    total=True
)

_Monster_wisMod_OrderByInput = TypedDict(
    '_Monster_wisMod_OrderByInput',
    {
        'wisMod': 'SortOrder',
    },
    total=True
)

_Monster_conMod_OrderByInput = TypedDict(
    '_Monster_conMod_OrderByInput',
    {
        'conMod': 'SortOrder',
    },
    total=True
)

_Monster_chaMod_OrderByInput = TypedDict(
    '_Monster_chaMod_OrderByInput',
    {
        'chaMod': 'SortOrder',
    },
    total=True
)

_Monster_strSave_OrderByInput = TypedDict(
    '_Monster_strSave_OrderByInput',
    {
        'strSave': 'SortOrder',
    },
    total=True
)

_Monster_intSave_OrderByInput = TypedDict(
    '_Monster_intSave_OrderByInput',
    {
        'intSave': 'SortOrder',
    },
    total=True
)

_Monster_dexSave_OrderByInput = TypedDict(
    '_Monster_dexSave_OrderByInput',
    {
        'dexSave': 'SortOrder',
    },
    total=True
)

_Monster_wisSave_OrderByInput = TypedDict(
    '_Monster_wisSave_OrderByInput',
    {
        'wisSave': 'SortOrder',
    },
    total=True
)

_Monster_conSave_OrderByInput = TypedDict(
    '_Monster_conSave_OrderByInput',
    {
        'conSave': 'SortOrder',
    },
    total=True
)

_Monster_chaSave_OrderByInput = TypedDict(
    '_Monster_chaSave_OrderByInput',
    {
        'chaSave': 'SortOrder',
    },
    total=True
)

_Monster_proficient_OrderByInput = TypedDict(
    '_Monster_proficient_OrderByInput',
    {
        'proficient': 'SortOrder',
    },
    total=True
)

_Monster_expertise_OrderByInput = TypedDict(
    '_Monster_expertise_OrderByInput',
    {
        'expertise': 'SortOrder',
    },
    total=True
)

_Monster_vulnerabilities_OrderByInput = TypedDict(
    '_Monster_vulnerabilities_OrderByInput',
    {
        'vulnerabilities': 'SortOrder',
    },
    total=True
)

_Monster_slashing_OrderByInput = TypedDict(
    '_Monster_slashing_OrderByInput',
    {
        'slashing': 'SortOrder',
    },
    total=True
)

_Monster_immunitiesConditions_OrderByInput = TypedDict(
    '_Monster_immunitiesConditions_OrderByInput',
    {
        'immunitiesConditions': 'SortOrder',
    },
    total=True
)

_Monster_immunitiesDamage_OrderByInput = TypedDict(
    '_Monster_immunitiesDamage_OrderByInput',
    {
        'immunitiesDamage': 'SortOrder',
    },
    total=True
)

_Monster_blindsight_OrderByInput = TypedDict(
    '_Monster_blindsight_OrderByInput',
    {
        'blindsight': 'SortOrder',
    },
    total=True
)

_Monster_darkvision_OrderByInput = TypedDict(
    '_Monster_darkvision_OrderByInput',
    {
        'darkvision': 'SortOrder',
    },
    total=True
)

_Monster_truesight_OrderByInput = TypedDict(
    '_Monster_truesight_OrderByInput',
    {
        'truesight': 'SortOrder',
    },
    total=True
)

_Monster_tremorsense_OrderByInput = TypedDict(
    '_Monster_tremorsense_OrderByInput',
    {
        'tremorsense': 'SortOrder',
    },
    total=True
)

_Monster_passivePerception_OrderByInput = TypedDict(
    '_Monster_passivePerception_OrderByInput',
    {
        'passivePerception': 'SortOrder',
    },
    total=True
)

_Monster_languages_OrderByInput = TypedDict(
    '_Monster_languages_OrderByInput',
    {
        'languages': 'SortOrder',
    },
    total=True
)

_Monster_cr_OrderByInput = TypedDict(
    '_Monster_cr_OrderByInput',
    {
        'cr': 'SortOrder',
    },
    total=True
)

_Monster_xpVal_OrderByInput = TypedDict(
    '_Monster_xpVal_OrderByInput',
    {
        'xpVal': 'SortOrder',
    },
    total=True
)

_Monster_pb_OrderByInput = TypedDict(
    '_Monster_pb_OrderByInput',
    {
        'pb': 'SortOrder',
    },
    total=True
)

_Monster_traits_OrderByInput = TypedDict(
    '_Monster_traits_OrderByInput',
    {
        'traits': 'SortOrder',
    },
    total=True
)

_Monster_legendaryResistanceCount_OrderByInput = TypedDict(
    '_Monster_legendaryResistanceCount_OrderByInput',
    {
        'legendaryResistanceCount': 'SortOrder',
    },
    total=True
)

_Monster_numberOfAtk_OrderByInput = TypedDict(
    '_Monster_numberOfAtk_OrderByInput',
    {
        'numberOfAtk': 'SortOrder',
    },
    total=True
)

_Monster_atk1Type_OrderByInput = TypedDict(
    '_Monster_atk1Type_OrderByInput',
    {
        'atk1Type': 'SortOrder',
    },
    total=True
)

_Monster_atk1Mod_OrderByInput = TypedDict(
    '_Monster_atk1Mod_OrderByInput',
    {
        'atk1Mod': 'SortOrder',
    },
    total=True
)

_Monster_atk1Range_OrderByInput = TypedDict(
    '_Monster_atk1Range_OrderByInput',
    {
        'atk1Range': 'SortOrder',
    },
    total=True
)

_Monster_atk1RangeShort_OrderByInput = TypedDict(
    '_Monster_atk1RangeShort_OrderByInput',
    {
        'atk1RangeShort': 'SortOrder',
    },
    total=True
)

_Monster_atk1Dam_OrderByInput = TypedDict(
    '_Monster_atk1Dam_OrderByInput',
    {
        'atk1Dam': 'SortOrder',
    },
    total=True
)

_Monster_atk1DamageType_OrderByInput = TypedDict(
    '_Monster_atk1DamageType_OrderByInput',
    {
        'atk1DamageType': 'SortOrder',
    },
    total=True
)

_Monster_atk2Type_OrderByInput = TypedDict(
    '_Monster_atk2Type_OrderByInput',
    {
        'atk2Type': 'SortOrder',
    },
    total=True
)

_Monster_atk2Mod_OrderByInput = TypedDict(
    '_Monster_atk2Mod_OrderByInput',
    {
        'atk2Mod': 'SortOrder',
    },
    total=True
)

_Monster_atk2Range_OrderByInput = TypedDict(
    '_Monster_atk2Range_OrderByInput',
    {
        'atk2Range': 'SortOrder',
    },
    total=True
)

_Monster_atk2RangeShort_OrderByInput = TypedDict(
    '_Monster_atk2RangeShort_OrderByInput',
    {
        'atk2RangeShort': 'SortOrder',
    },
    total=True
)

_Monster_atk2Dam_OrderByInput = TypedDict(
    '_Monster_atk2Dam_OrderByInput',
    {
        'atk2Dam': 'SortOrder',
    },
    total=True
)

_Monster_atk2DamageType_OrderByInput = TypedDict(
    '_Monster_atk2DamageType_OrderByInput',
    {
        'atk2DamageType': 'SortOrder',
    },
    total=True
)

_Monster_atk3Type_OrderByInput = TypedDict(
    '_Monster_atk3Type_OrderByInput',
    {
        'atk3Type': 'SortOrder',
    },
    total=True
)

_Monster_atk3Mod_OrderByInput = TypedDict(
    '_Monster_atk3Mod_OrderByInput',
    {
        'atk3Mod': 'SortOrder',
    },
    total=True
)

_Monster_atk3Range_OrderByInput = TypedDict(
    '_Monster_atk3Range_OrderByInput',
    {
        'atk3Range': 'SortOrder',
    },
    total=True
)

_Monster_atk3RangeShort_OrderByInput = TypedDict(
    '_Monster_atk3RangeShort_OrderByInput',
    {
        'atk3RangeShort': 'SortOrder',
    },
    total=True
)

_Monster_atk3Dam_OrderByInput = TypedDict(
    '_Monster_atk3Dam_OrderByInput',
    {
        'atk3Dam': 'SortOrder',
    },
    total=True
)

_Monster_atk3DamageType_OrderByInput = TypedDict(
    '_Monster_atk3DamageType_OrderByInput',
    {
        'atk3DamageType': 'SortOrder',
    },
    total=True
)

_Monster_atk4Type_OrderByInput = TypedDict(
    '_Monster_atk4Type_OrderByInput',
    {
        'atk4Type': 'SortOrder',
    },
    total=True
)

_Monster_atk4Mod_OrderByInput = TypedDict(
    '_Monster_atk4Mod_OrderByInput',
    {
        'atk4Mod': 'SortOrder',
    },
    total=True
)

_Monster_atk4Range_OrderByInput = TypedDict(
    '_Monster_atk4Range_OrderByInput',
    {
        'atk4Range': 'SortOrder',
    },
    total=True
)

_Monster_atk4RangeShort_OrderByInput = TypedDict(
    '_Monster_atk4RangeShort_OrderByInput',
    {
        'atk4RangeShort': 'SortOrder',
    },
    total=True
)

_Monster_atk4Dam_OrderByInput = TypedDict(
    '_Monster_atk4Dam_OrderByInput',
    {
        'atk4Dam': 'SortOrder',
    },
    total=True
)

_Monster_atk4DamageType_OrderByInput = TypedDict(
    '_Monster_atk4DamageType_OrderByInput',
    {
        'atk4DamageType': 'SortOrder',
    },
    total=True
)

_Monster_saveDC_OrderByInput = TypedDict(
    '_Monster_saveDC_OrderByInput',
    {
        'saveDC': 'SortOrder',
    },
    total=True
)

_Monster_savingThrow_OrderByInput = TypedDict(
    '_Monster_savingThrow_OrderByInput',
    {
        'savingThrow': 'SortOrder',
    },
    total=True
)

_Monster_actionNotes_OrderByInput = TypedDict(
    '_Monster_actionNotes_OrderByInput',
    {
        'actionNotes': 'SortOrder',
    },
    total=True
)

_Monster_ability_OrderByInput = TypedDict(
    '_Monster_ability_OrderByInput',
    {
        'ability': 'SortOrder',
    },
    total=True
)

_Monster_spellSaveDC_OrderByInput = TypedDict(
    '_Monster_spellSaveDC_OrderByInput',
    {
        'spellSaveDC': 'SortOrder',
    },
    total=True
)

_Monster_spellSavingThrows_OrderByInput = TypedDict(
    '_Monster_spellSavingThrows_OrderByInput',
    {
        'spellSavingThrows': 'SortOrder',
    },
    total=True
)

_Monster_spellAttack_OrderByInput = TypedDict(
    '_Monster_spellAttack_OrderByInput',
    {
        'spellAttack': 'SortOrder',
    },
    total=True
)

_Monster_atWillSpells_OrderByInput = TypedDict(
    '_Monster_atWillSpells_OrderByInput',
    {
        'atWillSpells': 'SortOrder',
    },
    total=True
)

_Monster_threePerDaySpells_OrderByInput = TypedDict(
    '_Monster_threePerDaySpells_OrderByInput',
    {
        'threePerDaySpells': 'SortOrder',
    },
    total=True
)

_Monster_twoPerDaySpells_OrderByInput = TypedDict(
    '_Monster_twoPerDaySpells_OrderByInput',
    {
        'twoPerDaySpells': 'SortOrder',
    },
    total=True
)

_Monster_onePerDaySpells_OrderByInput = TypedDict(
    '_Monster_onePerDaySpells_OrderByInput',
    {
        'onePerDaySpells': 'SortOrder',
    },
    total=True
)

_Monster_bonusAction_OrderByInput = TypedDict(
    '_Monster_bonusAction_OrderByInput',
    {
        'bonusAction': 'SortOrder',
    },
    total=True
)

_Monster_reaction_OrderByInput = TypedDict(
    '_Monster_reaction_OrderByInput',
    {
        'reaction': 'SortOrder',
    },
    total=True
)

_Monster_amount_OrderByInput = TypedDict(
    '_Monster_amount_OrderByInput',
    {
        'amount': 'SortOrder',
    },
    total=True
)

_Monster_legendaryActionSaveDC_OrderByInput = TypedDict(
    '_Monster_legendaryActionSaveDC_OrderByInput',
    {
        'legendaryActionSaveDC': 'SortOrder',
    },
    total=True
)

_Monster_legendaryActionSavingThrow_OrderByInput = TypedDict(
    '_Monster_legendaryActionSavingThrow_OrderByInput',
    {
        'legendaryActionSavingThrow': 'SortOrder',
    },
    total=True
)

_Monster_legendaryActions_OrderByInput = TypedDict(
    '_Monster_legendaryActions_OrderByInput',
    {
        'legendaryActions': 'SortOrder',
    },
    total=True
)

_Monster_lair_OrderByInput = TypedDict(
    '_Monster_lair_OrderByInput',
    {
        'lair': 'SortOrder',
    },
    total=True
)

_Monster_xpLair_OrderByInput = TypedDict(
    '_Monster_xpLair_OrderByInput',
    {
        'xpLair': 'SortOrder',
    },
    total=True
)

_Monster_legendaryResistance_OrderByInput = TypedDict(
    '_Monster_legendaryResistance_OrderByInput',
    {
        'legendaryResistance': 'SortOrder',
    },
    total=True
)

_Monster_legendaryActionsLair_OrderByInput = TypedDict(
    '_Monster_legendaryActionsLair_OrderByInput',
    {
        'legendaryActionsLair': 'SortOrder',
    },
    total=True
)

_Monster_lairSaveDC_OrderByInput = TypedDict(
    '_Monster_lairSaveDC_OrderByInput',
    {
        'lairSaveDC': 'SortOrder',
    },
    total=True
)

_Monster_lairSavingThrows_OrderByInput = TypedDict(
    '_Monster_lairSavingThrows_OrderByInput',
    {
        'lairSavingThrows': 'SortOrder',
    },
    total=True
)

_Monster_other_OrderByInput = TypedDict(
    '_Monster_other_OrderByInput',
    {
        'other': 'SortOrder',
    },
    total=True
)

_Monster_align_OrderByInput = TypedDict(
    '_Monster_align_OrderByInput',
    {
        'align': 'SortOrder',
    },
    total=True
)

_Monster_speeds_OrderByInput = TypedDict(
    '_Monster_speeds_OrderByInput',
    {
        'speeds': 'SortOrder',
    },
    total=True
)

_Monster_strScore_OrderByInput = TypedDict(
    '_Monster_strScore_OrderByInput',
    {
        'strScore': 'SortOrder',
    },
    total=True
)

_Monster_dexScore_OrderByInput = TypedDict(
    '_Monster_dexScore_OrderByInput',
    {
        'dexScore': 'SortOrder',
    },
    total=True
)

_Monster_conScore_OrderByInput = TypedDict(
    '_Monster_conScore_OrderByInput',
    {
        'conScore': 'SortOrder',
    },
    total=True
)

_Monster_intScore_OrderByInput = TypedDict(
    '_Monster_intScore_OrderByInput',
    {
        'intScore': 'SortOrder',
    },
    total=True
)

_Monster_wisScore_OrderByInput = TypedDict(
    '_Monster_wisScore_OrderByInput',
    {
        'wisScore': 'SortOrder',
    },
    total=True
)

_Monster_chaScore_OrderByInput = TypedDict(
    '_Monster_chaScore_OrderByInput',
    {
        'chaScore': 'SortOrder',
    },
    total=True
)

_Monster_savThrows_OrderByInput = TypedDict(
    '_Monster_savThrows_OrderByInput',
    {
        'savThrows': 'SortOrder',
    },
    total=True
)

_Monster_skills_OrderByInput = TypedDict(
    '_Monster_skills_OrderByInput',
    {
        'skills': 'SortOrder',
    },
    total=True
)

_Monster_wri_OrderByInput = TypedDict(
    '_Monster_wri_OrderByInput',
    {
        'wri': 'SortOrder',
    },
    total=True
)

_Monster_senses_OrderByInput = TypedDict(
    '_Monster_senses_OrderByInput',
    {
        'senses': 'SortOrder',
    },
    total=True
)

_Monster_additional_OrderByInput = TypedDict(
    '_Monster_additional_OrderByInput',
    {
        'additional': 'SortOrder',
    },
    total=True
)

_Monster_font_OrderByInput = TypedDict(
    '_Monster_font_OrderByInput',
    {
        'font': 'SortOrder',
    },
    total=True
)

_Monster_additionalInfo_OrderByInput = TypedDict(
    '_Monster_additionalInfo_OrderByInput',
    {
        'additionalInfo': 'SortOrder',
    },
    total=True
)

_Monster_author_OrderByInput = TypedDict(
    '_Monster_author_OrderByInput',
    {
        'author': 'SortOrder',
    },
    total=True
)

_Monster_RelevanceInner = TypedDict(
    '_Monster_RelevanceInner',
    {
        'fields': 'List[MonsterScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Monster_RelevanceOrderByInput = TypedDict(
    '_Monster_RelevanceOrderByInput',
    {
        '_relevance': '_Monster_RelevanceInner',
    },
    total=True
)

MonsterOrderByInput = Union[
    '_Monster_id_OrderByInput',
    '_Monster_name_OrderByInput',
    '_Monster_size_OrderByInput',
    '_Monster_type_OrderByInput',
    '_Monster_alignment_OrderByInput',
    '_Monster_habitat_OrderByInput',
    '_Monster_mainHabitat_OrderByInput',
    '_Monster_otherHabitat_OrderByInput',
    '_Monster_treasure_OrderByInput',
    '_Monster_ac_OrderByInput',
    '_Monster_hp_OrderByInput',
    '_Monster_initiative_OrderByInput',
    '_Monster_walk_OrderByInput',
    '_Monster_burrow_OrderByInput',
    '_Monster_climb_OrderByInput',
    '_Monster_fly_OrderByInput',
    '_Monster_hover_OrderByInput',
    '_Monster_swim_OrderByInput',
    '_Monster_strMod_OrderByInput',
    '_Monster_intMod_OrderByInput',
    '_Monster_dexMod_OrderByInput',
    '_Monster_wisMod_OrderByInput',
    '_Monster_conMod_OrderByInput',
    '_Monster_chaMod_OrderByInput',
    '_Monster_strSave_OrderByInput',
    '_Monster_intSave_OrderByInput',
    '_Monster_dexSave_OrderByInput',
    '_Monster_wisSave_OrderByInput',
    '_Monster_conSave_OrderByInput',
    '_Monster_chaSave_OrderByInput',
    '_Monster_proficient_OrderByInput',
    '_Monster_expertise_OrderByInput',
    '_Monster_vulnerabilities_OrderByInput',
    '_Monster_slashing_OrderByInput',
    '_Monster_immunitiesConditions_OrderByInput',
    '_Monster_immunitiesDamage_OrderByInput',
    '_Monster_blindsight_OrderByInput',
    '_Monster_darkvision_OrderByInput',
    '_Monster_truesight_OrderByInput',
    '_Monster_tremorsense_OrderByInput',
    '_Monster_passivePerception_OrderByInput',
    '_Monster_languages_OrderByInput',
    '_Monster_cr_OrderByInput',
    '_Monster_xpVal_OrderByInput',
    '_Monster_pb_OrderByInput',
    '_Monster_traits_OrderByInput',
    '_Monster_legendaryResistanceCount_OrderByInput',
    '_Monster_numberOfAtk_OrderByInput',
    '_Monster_atk1Type_OrderByInput',
    '_Monster_atk1Mod_OrderByInput',
    '_Monster_atk1Range_OrderByInput',
    '_Monster_atk1RangeShort_OrderByInput',
    '_Monster_atk1Dam_OrderByInput',
    '_Monster_atk1DamageType_OrderByInput',
    '_Monster_atk2Type_OrderByInput',
    '_Monster_atk2Mod_OrderByInput',
    '_Monster_atk2Range_OrderByInput',
    '_Monster_atk2RangeShort_OrderByInput',
    '_Monster_atk2Dam_OrderByInput',
    '_Monster_atk2DamageType_OrderByInput',
    '_Monster_atk3Type_OrderByInput',
    '_Monster_atk3Mod_OrderByInput',
    '_Monster_atk3Range_OrderByInput',
    '_Monster_atk3RangeShort_OrderByInput',
    '_Monster_atk3Dam_OrderByInput',
    '_Monster_atk3DamageType_OrderByInput',
    '_Monster_atk4Type_OrderByInput',
    '_Monster_atk4Mod_OrderByInput',
    '_Monster_atk4Range_OrderByInput',
    '_Monster_atk4RangeShort_OrderByInput',
    '_Monster_atk4Dam_OrderByInput',
    '_Monster_atk4DamageType_OrderByInput',
    '_Monster_saveDC_OrderByInput',
    '_Monster_savingThrow_OrderByInput',
    '_Monster_actionNotes_OrderByInput',
    '_Monster_ability_OrderByInput',
    '_Monster_spellSaveDC_OrderByInput',
    '_Monster_spellSavingThrows_OrderByInput',
    '_Monster_spellAttack_OrderByInput',
    '_Monster_atWillSpells_OrderByInput',
    '_Monster_threePerDaySpells_OrderByInput',
    '_Monster_twoPerDaySpells_OrderByInput',
    '_Monster_onePerDaySpells_OrderByInput',
    '_Monster_bonusAction_OrderByInput',
    '_Monster_reaction_OrderByInput',
    '_Monster_amount_OrderByInput',
    '_Monster_legendaryActionSaveDC_OrderByInput',
    '_Monster_legendaryActionSavingThrow_OrderByInput',
    '_Monster_legendaryActions_OrderByInput',
    '_Monster_lair_OrderByInput',
    '_Monster_xpLair_OrderByInput',
    '_Monster_legendaryResistance_OrderByInput',
    '_Monster_legendaryActionsLair_OrderByInput',
    '_Monster_lairSaveDC_OrderByInput',
    '_Monster_lairSavingThrows_OrderByInput',
    '_Monster_other_OrderByInput',
    '_Monster_align_OrderByInput',
    '_Monster_speeds_OrderByInput',
    '_Monster_strScore_OrderByInput',
    '_Monster_dexScore_OrderByInput',
    '_Monster_conScore_OrderByInput',
    '_Monster_intScore_OrderByInput',
    '_Monster_wisScore_OrderByInput',
    '_Monster_chaScore_OrderByInput',
    '_Monster_savThrows_OrderByInput',
    '_Monster_skills_OrderByInput',
    '_Monster_wri_OrderByInput',
    '_Monster_senses_OrderByInput',
    '_Monster_additional_OrderByInput',
    '_Monster_font_OrderByInput',
    '_Monster_additionalInfo_OrderByInput',
    '_Monster_author_OrderByInput',
    '_Monster_RelevanceOrderByInput',
]



# recursive Monster types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

MonsterRelationFilter = TypedDict(
    'MonsterRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class MonsterListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class MonsterInclude(TypedDict, total=False):
    """Monster relational arguments"""


    

class MonsterIncludeFromMonster(TypedDict, total=False):
    """Relational arguments for Monster"""


class MonsterIncludeFromMonsterRecursive1(TypedDict, total=False):
    """Relational arguments for Monster"""


class MonsterIncludeFromMonsterRecursive2(TypedDict, total=False):
    """Relational arguments for Monster"""


class MonsterIncludeFromMonsterRecursive3(TypedDict, total=False):
    """Relational arguments for Monster"""


class MonsterIncludeFromMonsterRecursive4(TypedDict, total=False):
    """Relational arguments for Monster"""

    

class MonsterArgsFromMonster(TypedDict, total=False):
    """Arguments for Monster"""
    include: 'MonsterIncludeFromMonsterRecursive1'


class MonsterArgsFromMonsterRecursive1(TypedDict, total=False):
    """Arguments for Monster"""
    include: 'MonsterIncludeFromMonsterRecursive2'


class MonsterArgsFromMonsterRecursive2(TypedDict, total=False):
    """Arguments for Monster"""
    include: 'MonsterIncludeFromMonsterRecursive3'


class MonsterArgsFromMonsterRecursive3(TypedDict, total=False):
    """Arguments for Monster"""
    include: 'MonsterIncludeFromMonsterRecursive4'


class MonsterArgsFromMonsterRecursive4(TypedDict, total=False):
    """Arguments for Monster"""
    
    

class FindManyMonsterArgsFromMonster(TypedDict, total=False):
    """Arguments for Monster"""
    take: int
    skip: int
    order_by: Union['MonsterOrderByInput', List['MonsterOrderByInput']]
    where: 'MonsterWhereInput'
    cursor: 'MonsterWhereUniqueInput'
    distinct: List['MonsterScalarFieldKeys']
    include: 'MonsterIncludeFromMonsterRecursive1'


class FindManyMonsterArgsFromMonsterRecursive1(TypedDict, total=False):
    """Arguments for Monster"""
    take: int
    skip: int
    order_by: Union['MonsterOrderByInput', List['MonsterOrderByInput']]
    where: 'MonsterWhereInput'
    cursor: 'MonsterWhereUniqueInput'
    distinct: List['MonsterScalarFieldKeys']
    include: 'MonsterIncludeFromMonsterRecursive2'


class FindManyMonsterArgsFromMonsterRecursive2(TypedDict, total=False):
    """Arguments for Monster"""
    take: int
    skip: int
    order_by: Union['MonsterOrderByInput', List['MonsterOrderByInput']]
    where: 'MonsterWhereInput'
    cursor: 'MonsterWhereUniqueInput'
    distinct: List['MonsterScalarFieldKeys']
    include: 'MonsterIncludeFromMonsterRecursive3'


class FindManyMonsterArgsFromMonsterRecursive3(TypedDict, total=False):
    """Arguments for Monster"""
    take: int
    skip: int
    order_by: Union['MonsterOrderByInput', List['MonsterOrderByInput']]
    where: 'MonsterWhereInput'
    cursor: 'MonsterWhereUniqueInput'
    distinct: List['MonsterScalarFieldKeys']
    include: 'MonsterIncludeFromMonsterRecursive4'


class FindManyMonsterArgsFromMonsterRecursive4(TypedDict, total=False):
    """Arguments for Monster"""
    take: int
    skip: int
    order_by: Union['MonsterOrderByInput', List['MonsterOrderByInput']]
    where: 'MonsterWhereInput'
    cursor: 'MonsterWhereUniqueInput'
    distinct: List['MonsterScalarFieldKeys']
    
    

class RaceIncludeFromMonster(TypedDict, total=False):
    """Relational arguments for Monster"""


class RaceIncludeFromMonsterRecursive1(TypedDict, total=False):
    """Relational arguments for Monster"""


class RaceIncludeFromMonsterRecursive2(TypedDict, total=False):
    """Relational arguments for Monster"""


class RaceIncludeFromMonsterRecursive3(TypedDict, total=False):
    """Relational arguments for Monster"""


class RaceIncludeFromMonsterRecursive4(TypedDict, total=False):
    """Relational arguments for Monster"""

    

class RaceArgsFromMonster(TypedDict, total=False):
    """Arguments for Monster"""
    include: 'RaceIncludeFromRaceRecursive1'


class RaceArgsFromMonsterRecursive1(TypedDict, total=False):
    """Arguments for Monster"""
    include: 'RaceIncludeFromRaceRecursive2'


class RaceArgsFromMonsterRecursive2(TypedDict, total=False):
    """Arguments for Monster"""
    include: 'RaceIncludeFromRaceRecursive3'


class RaceArgsFromMonsterRecursive3(TypedDict, total=False):
    """Arguments for Monster"""
    include: 'RaceIncludeFromRaceRecursive4'


class RaceArgsFromMonsterRecursive4(TypedDict, total=False):
    """Arguments for Monster"""
    
    

class FindManyRaceArgsFromMonster(TypedDict, total=False):
    """Arguments for Monster"""
    take: int
    skip: int
    order_by: Union['RaceOrderByInput', List['RaceOrderByInput']]
    where: 'RaceWhereInput'
    cursor: 'RaceWhereUniqueInput'
    distinct: List['RaceScalarFieldKeys']
    include: 'RaceIncludeFromRaceRecursive1'


class FindManyRaceArgsFromMonsterRecursive1(TypedDict, total=False):
    """Arguments for Monster"""
    take: int
    skip: int
    order_by: Union['RaceOrderByInput', List['RaceOrderByInput']]
    where: 'RaceWhereInput'
    cursor: 'RaceWhereUniqueInput'
    distinct: List['RaceScalarFieldKeys']
    include: 'RaceIncludeFromRaceRecursive2'


class FindManyRaceArgsFromMonsterRecursive2(TypedDict, total=False):
    """Arguments for Monster"""
    take: int
    skip: int
    order_by: Union['RaceOrderByInput', List['RaceOrderByInput']]
    where: 'RaceWhereInput'
    cursor: 'RaceWhereUniqueInput'
    distinct: List['RaceScalarFieldKeys']
    include: 'RaceIncludeFromRaceRecursive3'


class FindManyRaceArgsFromMonsterRecursive3(TypedDict, total=False):
    """Arguments for Monster"""
    take: int
    skip: int
    order_by: Union['RaceOrderByInput', List['RaceOrderByInput']]
    where: 'RaceWhereInput'
    cursor: 'RaceWhereUniqueInput'
    distinct: List['RaceScalarFieldKeys']
    include: 'RaceIncludeFromRaceRecursive4'


class FindManyRaceArgsFromMonsterRecursive4(TypedDict, total=False):
    """Arguments for Monster"""
    take: int
    skip: int
    order_by: Union['RaceOrderByInput', List['RaceOrderByInput']]
    where: 'RaceWhereInput'
    cursor: 'RaceWhereUniqueInput'
    distinct: List['RaceScalarFieldKeys']
    
    

class SpellIncludeFromMonster(TypedDict, total=False):
    """Relational arguments for Monster"""


class SpellIncludeFromMonsterRecursive1(TypedDict, total=False):
    """Relational arguments for Monster"""


class SpellIncludeFromMonsterRecursive2(TypedDict, total=False):
    """Relational arguments for Monster"""


class SpellIncludeFromMonsterRecursive3(TypedDict, total=False):
    """Relational arguments for Monster"""


class SpellIncludeFromMonsterRecursive4(TypedDict, total=False):
    """Relational arguments for Monster"""

    

class SpellArgsFromMonster(TypedDict, total=False):
    """Arguments for Monster"""
    include: 'SpellIncludeFromSpellRecursive1'


class SpellArgsFromMonsterRecursive1(TypedDict, total=False):
    """Arguments for Monster"""
    include: 'SpellIncludeFromSpellRecursive2'


class SpellArgsFromMonsterRecursive2(TypedDict, total=False):
    """Arguments for Monster"""
    include: 'SpellIncludeFromSpellRecursive3'


class SpellArgsFromMonsterRecursive3(TypedDict, total=False):
    """Arguments for Monster"""
    include: 'SpellIncludeFromSpellRecursive4'


class SpellArgsFromMonsterRecursive4(TypedDict, total=False):
    """Arguments for Monster"""
    
    

class FindManySpellArgsFromMonster(TypedDict, total=False):
    """Arguments for Monster"""
    take: int
    skip: int
    order_by: Union['SpellOrderByInput', List['SpellOrderByInput']]
    where: 'SpellWhereInput'
    cursor: 'SpellWhereUniqueInput'
    distinct: List['SpellScalarFieldKeys']
    include: 'SpellIncludeFromSpellRecursive1'


class FindManySpellArgsFromMonsterRecursive1(TypedDict, total=False):
    """Arguments for Monster"""
    take: int
    skip: int
    order_by: Union['SpellOrderByInput', List['SpellOrderByInput']]
    where: 'SpellWhereInput'
    cursor: 'SpellWhereUniqueInput'
    distinct: List['SpellScalarFieldKeys']
    include: 'SpellIncludeFromSpellRecursive2'


class FindManySpellArgsFromMonsterRecursive2(TypedDict, total=False):
    """Arguments for Monster"""
    take: int
    skip: int
    order_by: Union['SpellOrderByInput', List['SpellOrderByInput']]
    where: 'SpellWhereInput'
    cursor: 'SpellWhereUniqueInput'
    distinct: List['SpellScalarFieldKeys']
    include: 'SpellIncludeFromSpellRecursive3'


class FindManySpellArgsFromMonsterRecursive3(TypedDict, total=False):
    """Arguments for Monster"""
    take: int
    skip: int
    order_by: Union['SpellOrderByInput', List['SpellOrderByInput']]
    where: 'SpellWhereInput'
    cursor: 'SpellWhereUniqueInput'
    distinct: List['SpellScalarFieldKeys']
    include: 'SpellIncludeFromSpellRecursive4'


class FindManySpellArgsFromMonsterRecursive4(TypedDict, total=False):
    """Arguments for Monster"""
    take: int
    skip: int
    order_by: Union['SpellOrderByInput', List['SpellOrderByInput']]
    where: 'SpellWhereInput'
    cursor: 'SpellWhereUniqueInput'
    distinct: List['SpellScalarFieldKeys']
    
    

class PlayerClassIncludeFromMonster(TypedDict, total=False):
    """Relational arguments for Monster"""


class PlayerClassIncludeFromMonsterRecursive1(TypedDict, total=False):
    """Relational arguments for Monster"""


class PlayerClassIncludeFromMonsterRecursive2(TypedDict, total=False):
    """Relational arguments for Monster"""


class PlayerClassIncludeFromMonsterRecursive3(TypedDict, total=False):
    """Relational arguments for Monster"""


class PlayerClassIncludeFromMonsterRecursive4(TypedDict, total=False):
    """Relational arguments for Monster"""

    

class PlayerClassArgsFromMonster(TypedDict, total=False):
    """Arguments for Monster"""
    include: 'PlayerClassIncludeFromPlayerClassRecursive1'


class PlayerClassArgsFromMonsterRecursive1(TypedDict, total=False):
    """Arguments for Monster"""
    include: 'PlayerClassIncludeFromPlayerClassRecursive2'


class PlayerClassArgsFromMonsterRecursive2(TypedDict, total=False):
    """Arguments for Monster"""
    include: 'PlayerClassIncludeFromPlayerClassRecursive3'


class PlayerClassArgsFromMonsterRecursive3(TypedDict, total=False):
    """Arguments for Monster"""
    include: 'PlayerClassIncludeFromPlayerClassRecursive4'


class PlayerClassArgsFromMonsterRecursive4(TypedDict, total=False):
    """Arguments for Monster"""
    
    

class FindManyPlayerClassArgsFromMonster(TypedDict, total=False):
    """Arguments for Monster"""
    take: int
    skip: int
    order_by: Union['PlayerClassOrderByInput', List['PlayerClassOrderByInput']]
    where: 'PlayerClassWhereInput'
    cursor: 'PlayerClassWhereUniqueInput'
    distinct: List['PlayerClassScalarFieldKeys']
    include: 'PlayerClassIncludeFromPlayerClassRecursive1'


class FindManyPlayerClassArgsFromMonsterRecursive1(TypedDict, total=False):
    """Arguments for Monster"""
    take: int
    skip: int
    order_by: Union['PlayerClassOrderByInput', List['PlayerClassOrderByInput']]
    where: 'PlayerClassWhereInput'
    cursor: 'PlayerClassWhereUniqueInput'
    distinct: List['PlayerClassScalarFieldKeys']
    include: 'PlayerClassIncludeFromPlayerClassRecursive2'


class FindManyPlayerClassArgsFromMonsterRecursive2(TypedDict, total=False):
    """Arguments for Monster"""
    take: int
    skip: int
    order_by: Union['PlayerClassOrderByInput', List['PlayerClassOrderByInput']]
    where: 'PlayerClassWhereInput'
    cursor: 'PlayerClassWhereUniqueInput'
    distinct: List['PlayerClassScalarFieldKeys']
    include: 'PlayerClassIncludeFromPlayerClassRecursive3'


class FindManyPlayerClassArgsFromMonsterRecursive3(TypedDict, total=False):
    """Arguments for Monster"""
    take: int
    skip: int
    order_by: Union['PlayerClassOrderByInput', List['PlayerClassOrderByInput']]
    where: 'PlayerClassWhereInput'
    cursor: 'PlayerClassWhereUniqueInput'
    distinct: List['PlayerClassScalarFieldKeys']
    include: 'PlayerClassIncludeFromPlayerClassRecursive4'


class FindManyPlayerClassArgsFromMonsterRecursive4(TypedDict, total=False):
    """Arguments for Monster"""
    take: int
    skip: int
    order_by: Union['PlayerClassOrderByInput', List['PlayerClassOrderByInput']]
    where: 'PlayerClassWhereInput'
    cursor: 'PlayerClassWhereUniqueInput'
    distinct: List['PlayerClassScalarFieldKeys']
    
    

class MagicItemIncludeFromMonster(TypedDict, total=False):
    """Relational arguments for Monster"""


class MagicItemIncludeFromMonsterRecursive1(TypedDict, total=False):
    """Relational arguments for Monster"""


class MagicItemIncludeFromMonsterRecursive2(TypedDict, total=False):
    """Relational arguments for Monster"""


class MagicItemIncludeFromMonsterRecursive3(TypedDict, total=False):
    """Relational arguments for Monster"""


class MagicItemIncludeFromMonsterRecursive4(TypedDict, total=False):
    """Relational arguments for Monster"""

    

class MagicItemArgsFromMonster(TypedDict, total=False):
    """Arguments for Monster"""
    include: 'MagicItemIncludeFromMagicItemRecursive1'


class MagicItemArgsFromMonsterRecursive1(TypedDict, total=False):
    """Arguments for Monster"""
    include: 'MagicItemIncludeFromMagicItemRecursive2'


class MagicItemArgsFromMonsterRecursive2(TypedDict, total=False):
    """Arguments for Monster"""
    include: 'MagicItemIncludeFromMagicItemRecursive3'


class MagicItemArgsFromMonsterRecursive3(TypedDict, total=False):
    """Arguments for Monster"""
    include: 'MagicItemIncludeFromMagicItemRecursive4'


class MagicItemArgsFromMonsterRecursive4(TypedDict, total=False):
    """Arguments for Monster"""
    
    

class FindManyMagicItemArgsFromMonster(TypedDict, total=False):
    """Arguments for Monster"""
    take: int
    skip: int
    order_by: Union['MagicItemOrderByInput', List['MagicItemOrderByInput']]
    where: 'MagicItemWhereInput'
    cursor: 'MagicItemWhereUniqueInput'
    distinct: List['MagicItemScalarFieldKeys']
    include: 'MagicItemIncludeFromMagicItemRecursive1'


class FindManyMagicItemArgsFromMonsterRecursive1(TypedDict, total=False):
    """Arguments for Monster"""
    take: int
    skip: int
    order_by: Union['MagicItemOrderByInput', List['MagicItemOrderByInput']]
    where: 'MagicItemWhereInput'
    cursor: 'MagicItemWhereUniqueInput'
    distinct: List['MagicItemScalarFieldKeys']
    include: 'MagicItemIncludeFromMagicItemRecursive2'


class FindManyMagicItemArgsFromMonsterRecursive2(TypedDict, total=False):
    """Arguments for Monster"""
    take: int
    skip: int
    order_by: Union['MagicItemOrderByInput', List['MagicItemOrderByInput']]
    where: 'MagicItemWhereInput'
    cursor: 'MagicItemWhereUniqueInput'
    distinct: List['MagicItemScalarFieldKeys']
    include: 'MagicItemIncludeFromMagicItemRecursive3'


class FindManyMagicItemArgsFromMonsterRecursive3(TypedDict, total=False):
    """Arguments for Monster"""
    take: int
    skip: int
    order_by: Union['MagicItemOrderByInput', List['MagicItemOrderByInput']]
    where: 'MagicItemWhereInput'
    cursor: 'MagicItemWhereUniqueInput'
    distinct: List['MagicItemScalarFieldKeys']
    include: 'MagicItemIncludeFromMagicItemRecursive4'


class FindManyMagicItemArgsFromMonsterRecursive4(TypedDict, total=False):
    """Arguments for Monster"""
    take: int
    skip: int
    order_by: Union['MagicItemOrderByInput', List['MagicItemOrderByInput']]
    where: 'MagicItemWhereInput'
    cursor: 'MagicItemWhereUniqueInput'
    distinct: List['MagicItemScalarFieldKeys']
    
    

class GeneralEquipmentIncludeFromMonster(TypedDict, total=False):
    """Relational arguments for Monster"""


class GeneralEquipmentIncludeFromMonsterRecursive1(TypedDict, total=False):
    """Relational arguments for Monster"""


class GeneralEquipmentIncludeFromMonsterRecursive2(TypedDict, total=False):
    """Relational arguments for Monster"""


class GeneralEquipmentIncludeFromMonsterRecursive3(TypedDict, total=False):
    """Relational arguments for Monster"""


class GeneralEquipmentIncludeFromMonsterRecursive4(TypedDict, total=False):
    """Relational arguments for Monster"""

    

class GeneralEquipmentArgsFromMonster(TypedDict, total=False):
    """Arguments for Monster"""
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive1'


class GeneralEquipmentArgsFromMonsterRecursive1(TypedDict, total=False):
    """Arguments for Monster"""
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive2'


class GeneralEquipmentArgsFromMonsterRecursive2(TypedDict, total=False):
    """Arguments for Monster"""
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive3'


class GeneralEquipmentArgsFromMonsterRecursive3(TypedDict, total=False):
    """Arguments for Monster"""
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive4'


class GeneralEquipmentArgsFromMonsterRecursive4(TypedDict, total=False):
    """Arguments for Monster"""
    
    

class FindManyGeneralEquipmentArgsFromMonster(TypedDict, total=False):
    """Arguments for Monster"""
    take: int
    skip: int
    order_by: Union['GeneralEquipmentOrderByInput', List['GeneralEquipmentOrderByInput']]
    where: 'GeneralEquipmentWhereInput'
    cursor: 'GeneralEquipmentWhereUniqueInput'
    distinct: List['GeneralEquipmentScalarFieldKeys']
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive1'


class FindManyGeneralEquipmentArgsFromMonsterRecursive1(TypedDict, total=False):
    """Arguments for Monster"""
    take: int
    skip: int
    order_by: Union['GeneralEquipmentOrderByInput', List['GeneralEquipmentOrderByInput']]
    where: 'GeneralEquipmentWhereInput'
    cursor: 'GeneralEquipmentWhereUniqueInput'
    distinct: List['GeneralEquipmentScalarFieldKeys']
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive2'


class FindManyGeneralEquipmentArgsFromMonsterRecursive2(TypedDict, total=False):
    """Arguments for Monster"""
    take: int
    skip: int
    order_by: Union['GeneralEquipmentOrderByInput', List['GeneralEquipmentOrderByInput']]
    where: 'GeneralEquipmentWhereInput'
    cursor: 'GeneralEquipmentWhereUniqueInput'
    distinct: List['GeneralEquipmentScalarFieldKeys']
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive3'


class FindManyGeneralEquipmentArgsFromMonsterRecursive3(TypedDict, total=False):
    """Arguments for Monster"""
    take: int
    skip: int
    order_by: Union['GeneralEquipmentOrderByInput', List['GeneralEquipmentOrderByInput']]
    where: 'GeneralEquipmentWhereInput'
    cursor: 'GeneralEquipmentWhereUniqueInput'
    distinct: List['GeneralEquipmentScalarFieldKeys']
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive4'


class FindManyGeneralEquipmentArgsFromMonsterRecursive4(TypedDict, total=False):
    """Arguments for Monster"""
    take: int
    skip: int
    order_by: Union['GeneralEquipmentOrderByInput', List['GeneralEquipmentOrderByInput']]
    where: 'GeneralEquipmentWhereInput'
    cursor: 'GeneralEquipmentWhereUniqueInput'
    distinct: List['GeneralEquipmentScalarFieldKeys']
    


FindManyMonsterArgs = FindManyMonsterArgsFromMonster
FindFirstMonsterArgs = FindManyMonsterArgsFromMonster


    

class MonsterWhereInput(TypedDict, total=False):
    """Monster arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    size: Union[None, _str, 'types.StringFilter']
    type: Union[None, _str, 'types.StringFilter']
    alignment: Union[None, _str, 'types.StringFilter']
    habitat: Union[None, _str, 'types.StringFilter']
    mainHabitat: Union[None, _str, 'types.StringFilter']
    otherHabitat: Union[None, _str, 'types.StringFilter']
    treasure: Union[None, _str, 'types.StringFilter']
    ac: Union[None, _str, 'types.StringFilter']
    hp: Union[None, _str, 'types.StringFilter']
    initiative: Union[None, _str, 'types.StringFilter']
    walk: Union[None, _str, 'types.StringFilter']
    burrow: Union[None, _str, 'types.StringFilter']
    climb: Union[None, _str, 'types.StringFilter']
    fly: Union[None, _str, 'types.StringFilter']
    hover: Union[None, _str, 'types.StringFilter']
    swim: Union[None, _str, 'types.StringFilter']
    strMod: Union[None, _str, 'types.StringFilter']
    intMod: Union[None, _str, 'types.StringFilter']
    dexMod: Union[None, _str, 'types.StringFilter']
    wisMod: Union[None, _str, 'types.StringFilter']
    conMod: Union[None, _str, 'types.StringFilter']
    chaMod: Union[None, _str, 'types.StringFilter']
    strSave: Union[None, _str, 'types.StringFilter']
    intSave: Union[None, _str, 'types.StringFilter']
    dexSave: Union[None, _str, 'types.StringFilter']
    wisSave: Union[None, _str, 'types.StringFilter']
    conSave: Union[None, _str, 'types.StringFilter']
    chaSave: Union[None, _str, 'types.StringFilter']
    proficient: Union[None, _str, 'types.StringFilter']
    expertise: Union[None, _str, 'types.StringFilter']
    vulnerabilities: Union[None, _str, 'types.StringFilter']
    slashing: Union[None, _str, 'types.StringFilter']
    immunitiesConditions: Union[None, _str, 'types.StringFilter']
    immunitiesDamage: Union[None, _str, 'types.StringFilter']
    blindsight: Union[None, _str, 'types.StringFilter']
    darkvision: Union[None, _str, 'types.StringFilter']
    truesight: Union[None, _str, 'types.StringFilter']
    tremorsense: Union[None, _str, 'types.StringFilter']
    passivePerception: Union[None, _str, 'types.StringFilter']
    languages: Union[None, _str, 'types.StringFilter']
    cr: Union[None, _str, 'types.StringFilter']
    xpVal: Union[None, _str, 'types.StringFilter']
    pb: Union[None, _str, 'types.StringFilter']
    traits: Union[None, _str, 'types.StringFilter']
    legendaryResistanceCount: Union[None, _str, 'types.StringFilter']
    numberOfAtk: Union[None, _str, 'types.StringFilter']
    atk1Type: Union[None, _str, 'types.StringFilter']
    atk1Mod: Union[None, _str, 'types.StringFilter']
    atk1Range: Union[None, _str, 'types.StringFilter']
    atk1RangeShort: Union[None, _str, 'types.StringFilter']
    atk1Dam: Union[None, _str, 'types.StringFilter']
    atk1DamageType: Union[None, _str, 'types.StringFilter']
    atk2Type: Union[None, _str, 'types.StringFilter']
    atk2Mod: Union[None, _str, 'types.StringFilter']
    atk2Range: Union[None, _str, 'types.StringFilter']
    atk2RangeShort: Union[None, _str, 'types.StringFilter']
    atk2Dam: Union[None, _str, 'types.StringFilter']
    atk2DamageType: Union[None, _str, 'types.StringFilter']
    atk3Type: Union[None, _str, 'types.StringFilter']
    atk3Mod: Union[None, _str, 'types.StringFilter']
    atk3Range: Union[None, _str, 'types.StringFilter']
    atk3RangeShort: Union[None, _str, 'types.StringFilter']
    atk3Dam: Union[None, _str, 'types.StringFilter']
    atk3DamageType: Union[None, _str, 'types.StringFilter']
    atk4Type: Union[None, _str, 'types.StringFilter']
    atk4Mod: Union[None, _str, 'types.StringFilter']
    atk4Range: Union[None, _str, 'types.StringFilter']
    atk4RangeShort: Union[None, _str, 'types.StringFilter']
    atk4Dam: Union[None, _str, 'types.StringFilter']
    atk4DamageType: Union[None, _str, 'types.StringFilter']
    saveDC: Union[None, _str, 'types.StringFilter']
    savingThrow: Union[None, _str, 'types.StringFilter']
    actionNotes: Union[None, _str, 'types.StringFilter']
    ability: Union[None, _str, 'types.StringFilter']
    spellSaveDC: Union[None, _str, 'types.StringFilter']
    spellSavingThrows: Union[None, _str, 'types.StringFilter']
    spellAttack: Union[None, _str, 'types.StringFilter']
    atWillSpells: Union[None, _str, 'types.StringFilter']
    threePerDaySpells: Union[None, _str, 'types.StringFilter']
    twoPerDaySpells: Union[None, _str, 'types.StringFilter']
    onePerDaySpells: Union[None, _str, 'types.StringFilter']
    bonusAction: Union[None, _str, 'types.StringFilter']
    reaction: Union[None, _str, 'types.StringFilter']
    amount: Union[None, _str, 'types.StringFilter']
    legendaryActionSaveDC: Union[None, _str, 'types.StringFilter']
    legendaryActionSavingThrow: Union[None, _str, 'types.StringFilter']
    legendaryActions: Union[None, _str, 'types.StringFilter']
    lair: Union[None, _str, 'types.StringFilter']
    xpLair: Union[None, _str, 'types.StringFilter']
    legendaryResistance: Union[None, _str, 'types.StringFilter']
    legendaryActionsLair: Union[None, _str, 'types.StringFilter']
    lairSaveDC: Union[None, _str, 'types.StringFilter']
    lairSavingThrows: Union[None, _str, 'types.StringFilter']
    other: Union[None, _str, 'types.StringFilter']
    align: Union[None, _str, 'types.StringFilter']
    speeds: Union[None, _str, 'types.StringFilter']
    strScore: Union[None, _str, 'types.StringFilter']
    dexScore: Union[None, _str, 'types.StringFilter']
    conScore: Union[None, _str, 'types.StringFilter']
    intScore: Union[None, _str, 'types.StringFilter']
    wisScore: Union[None, _str, 'types.StringFilter']
    chaScore: Union[None, _str, 'types.StringFilter']
    savThrows: Union[None, _str, 'types.StringFilter']
    skills: Union[None, _str, 'types.StringFilter']
    wri: Union[None, _str, 'types.StringFilter']
    senses: Union[None, _str, 'types.StringFilter']
    additional: Union[None, _str, 'types.StringFilter']
    font: Union[None, _str, 'types.StringFilter']
    additionalInfo: Union[None, _str, 'types.StringFilter']
    author: Union[None, _str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['MonsterWhereInputRecursive1', List['MonsterWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['MonsterWhereInputRecursive1']
    OR: List['MonsterWhereInputRecursive1']
    NOT: List['MonsterWhereInputRecursive1']


class MonsterWhereInputRecursive1(TypedDict, total=False):
    """Monster arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    size: Union[None, _str, 'types.StringFilter']
    type: Union[None, _str, 'types.StringFilter']
    alignment: Union[None, _str, 'types.StringFilter']
    habitat: Union[None, _str, 'types.StringFilter']
    mainHabitat: Union[None, _str, 'types.StringFilter']
    otherHabitat: Union[None, _str, 'types.StringFilter']
    treasure: Union[None, _str, 'types.StringFilter']
    ac: Union[None, _str, 'types.StringFilter']
    hp: Union[None, _str, 'types.StringFilter']
    initiative: Union[None, _str, 'types.StringFilter']
    walk: Union[None, _str, 'types.StringFilter']
    burrow: Union[None, _str, 'types.StringFilter']
    climb: Union[None, _str, 'types.StringFilter']
    fly: Union[None, _str, 'types.StringFilter']
    hover: Union[None, _str, 'types.StringFilter']
    swim: Union[None, _str, 'types.StringFilter']
    strMod: Union[None, _str, 'types.StringFilter']
    intMod: Union[None, _str, 'types.StringFilter']
    dexMod: Union[None, _str, 'types.StringFilter']
    wisMod: Union[None, _str, 'types.StringFilter']
    conMod: Union[None, _str, 'types.StringFilter']
    chaMod: Union[None, _str, 'types.StringFilter']
    strSave: Union[None, _str, 'types.StringFilter']
    intSave: Union[None, _str, 'types.StringFilter']
    dexSave: Union[None, _str, 'types.StringFilter']
    wisSave: Union[None, _str, 'types.StringFilter']
    conSave: Union[None, _str, 'types.StringFilter']
    chaSave: Union[None, _str, 'types.StringFilter']
    proficient: Union[None, _str, 'types.StringFilter']
    expertise: Union[None, _str, 'types.StringFilter']
    vulnerabilities: Union[None, _str, 'types.StringFilter']
    slashing: Union[None, _str, 'types.StringFilter']
    immunitiesConditions: Union[None, _str, 'types.StringFilter']
    immunitiesDamage: Union[None, _str, 'types.StringFilter']
    blindsight: Union[None, _str, 'types.StringFilter']
    darkvision: Union[None, _str, 'types.StringFilter']
    truesight: Union[None, _str, 'types.StringFilter']
    tremorsense: Union[None, _str, 'types.StringFilter']
    passivePerception: Union[None, _str, 'types.StringFilter']
    languages: Union[None, _str, 'types.StringFilter']
    cr: Union[None, _str, 'types.StringFilter']
    xpVal: Union[None, _str, 'types.StringFilter']
    pb: Union[None, _str, 'types.StringFilter']
    traits: Union[None, _str, 'types.StringFilter']
    legendaryResistanceCount: Union[None, _str, 'types.StringFilter']
    numberOfAtk: Union[None, _str, 'types.StringFilter']
    atk1Type: Union[None, _str, 'types.StringFilter']
    atk1Mod: Union[None, _str, 'types.StringFilter']
    atk1Range: Union[None, _str, 'types.StringFilter']
    atk1RangeShort: Union[None, _str, 'types.StringFilter']
    atk1Dam: Union[None, _str, 'types.StringFilter']
    atk1DamageType: Union[None, _str, 'types.StringFilter']
    atk2Type: Union[None, _str, 'types.StringFilter']
    atk2Mod: Union[None, _str, 'types.StringFilter']
    atk2Range: Union[None, _str, 'types.StringFilter']
    atk2RangeShort: Union[None, _str, 'types.StringFilter']
    atk2Dam: Union[None, _str, 'types.StringFilter']
    atk2DamageType: Union[None, _str, 'types.StringFilter']
    atk3Type: Union[None, _str, 'types.StringFilter']
    atk3Mod: Union[None, _str, 'types.StringFilter']
    atk3Range: Union[None, _str, 'types.StringFilter']
    atk3RangeShort: Union[None, _str, 'types.StringFilter']
    atk3Dam: Union[None, _str, 'types.StringFilter']
    atk3DamageType: Union[None, _str, 'types.StringFilter']
    atk4Type: Union[None, _str, 'types.StringFilter']
    atk4Mod: Union[None, _str, 'types.StringFilter']
    atk4Range: Union[None, _str, 'types.StringFilter']
    atk4RangeShort: Union[None, _str, 'types.StringFilter']
    atk4Dam: Union[None, _str, 'types.StringFilter']
    atk4DamageType: Union[None, _str, 'types.StringFilter']
    saveDC: Union[None, _str, 'types.StringFilter']
    savingThrow: Union[None, _str, 'types.StringFilter']
    actionNotes: Union[None, _str, 'types.StringFilter']
    ability: Union[None, _str, 'types.StringFilter']
    spellSaveDC: Union[None, _str, 'types.StringFilter']
    spellSavingThrows: Union[None, _str, 'types.StringFilter']
    spellAttack: Union[None, _str, 'types.StringFilter']
    atWillSpells: Union[None, _str, 'types.StringFilter']
    threePerDaySpells: Union[None, _str, 'types.StringFilter']
    twoPerDaySpells: Union[None, _str, 'types.StringFilter']
    onePerDaySpells: Union[None, _str, 'types.StringFilter']
    bonusAction: Union[None, _str, 'types.StringFilter']
    reaction: Union[None, _str, 'types.StringFilter']
    amount: Union[None, _str, 'types.StringFilter']
    legendaryActionSaveDC: Union[None, _str, 'types.StringFilter']
    legendaryActionSavingThrow: Union[None, _str, 'types.StringFilter']
    legendaryActions: Union[None, _str, 'types.StringFilter']
    lair: Union[None, _str, 'types.StringFilter']
    xpLair: Union[None, _str, 'types.StringFilter']
    legendaryResistance: Union[None, _str, 'types.StringFilter']
    legendaryActionsLair: Union[None, _str, 'types.StringFilter']
    lairSaveDC: Union[None, _str, 'types.StringFilter']
    lairSavingThrows: Union[None, _str, 'types.StringFilter']
    other: Union[None, _str, 'types.StringFilter']
    align: Union[None, _str, 'types.StringFilter']
    speeds: Union[None, _str, 'types.StringFilter']
    strScore: Union[None, _str, 'types.StringFilter']
    dexScore: Union[None, _str, 'types.StringFilter']
    conScore: Union[None, _str, 'types.StringFilter']
    intScore: Union[None, _str, 'types.StringFilter']
    wisScore: Union[None, _str, 'types.StringFilter']
    chaScore: Union[None, _str, 'types.StringFilter']
    savThrows: Union[None, _str, 'types.StringFilter']
    skills: Union[None, _str, 'types.StringFilter']
    wri: Union[None, _str, 'types.StringFilter']
    senses: Union[None, _str, 'types.StringFilter']
    additional: Union[None, _str, 'types.StringFilter']
    font: Union[None, _str, 'types.StringFilter']
    additionalInfo: Union[None, _str, 'types.StringFilter']
    author: Union[None, _str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['MonsterWhereInputRecursive2', List['MonsterWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['MonsterWhereInputRecursive2']
    OR: List['MonsterWhereInputRecursive2']
    NOT: List['MonsterWhereInputRecursive2']


class MonsterWhereInputRecursive2(TypedDict, total=False):
    """Monster arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    size: Union[None, _str, 'types.StringFilter']
    type: Union[None, _str, 'types.StringFilter']
    alignment: Union[None, _str, 'types.StringFilter']
    habitat: Union[None, _str, 'types.StringFilter']
    mainHabitat: Union[None, _str, 'types.StringFilter']
    otherHabitat: Union[None, _str, 'types.StringFilter']
    treasure: Union[None, _str, 'types.StringFilter']
    ac: Union[None, _str, 'types.StringFilter']
    hp: Union[None, _str, 'types.StringFilter']
    initiative: Union[None, _str, 'types.StringFilter']
    walk: Union[None, _str, 'types.StringFilter']
    burrow: Union[None, _str, 'types.StringFilter']
    climb: Union[None, _str, 'types.StringFilter']
    fly: Union[None, _str, 'types.StringFilter']
    hover: Union[None, _str, 'types.StringFilter']
    swim: Union[None, _str, 'types.StringFilter']
    strMod: Union[None, _str, 'types.StringFilter']
    intMod: Union[None, _str, 'types.StringFilter']
    dexMod: Union[None, _str, 'types.StringFilter']
    wisMod: Union[None, _str, 'types.StringFilter']
    conMod: Union[None, _str, 'types.StringFilter']
    chaMod: Union[None, _str, 'types.StringFilter']
    strSave: Union[None, _str, 'types.StringFilter']
    intSave: Union[None, _str, 'types.StringFilter']
    dexSave: Union[None, _str, 'types.StringFilter']
    wisSave: Union[None, _str, 'types.StringFilter']
    conSave: Union[None, _str, 'types.StringFilter']
    chaSave: Union[None, _str, 'types.StringFilter']
    proficient: Union[None, _str, 'types.StringFilter']
    expertise: Union[None, _str, 'types.StringFilter']
    vulnerabilities: Union[None, _str, 'types.StringFilter']
    slashing: Union[None, _str, 'types.StringFilter']
    immunitiesConditions: Union[None, _str, 'types.StringFilter']
    immunitiesDamage: Union[None, _str, 'types.StringFilter']
    blindsight: Union[None, _str, 'types.StringFilter']
    darkvision: Union[None, _str, 'types.StringFilter']
    truesight: Union[None, _str, 'types.StringFilter']
    tremorsense: Union[None, _str, 'types.StringFilter']
    passivePerception: Union[None, _str, 'types.StringFilter']
    languages: Union[None, _str, 'types.StringFilter']
    cr: Union[None, _str, 'types.StringFilter']
    xpVal: Union[None, _str, 'types.StringFilter']
    pb: Union[None, _str, 'types.StringFilter']
    traits: Union[None, _str, 'types.StringFilter']
    legendaryResistanceCount: Union[None, _str, 'types.StringFilter']
    numberOfAtk: Union[None, _str, 'types.StringFilter']
    atk1Type: Union[None, _str, 'types.StringFilter']
    atk1Mod: Union[None, _str, 'types.StringFilter']
    atk1Range: Union[None, _str, 'types.StringFilter']
    atk1RangeShort: Union[None, _str, 'types.StringFilter']
    atk1Dam: Union[None, _str, 'types.StringFilter']
    atk1DamageType: Union[None, _str, 'types.StringFilter']
    atk2Type: Union[None, _str, 'types.StringFilter']
    atk2Mod: Union[None, _str, 'types.StringFilter']
    atk2Range: Union[None, _str, 'types.StringFilter']
    atk2RangeShort: Union[None, _str, 'types.StringFilter']
    atk2Dam: Union[None, _str, 'types.StringFilter']
    atk2DamageType: Union[None, _str, 'types.StringFilter']
    atk3Type: Union[None, _str, 'types.StringFilter']
    atk3Mod: Union[None, _str, 'types.StringFilter']
    atk3Range: Union[None, _str, 'types.StringFilter']
    atk3RangeShort: Union[None, _str, 'types.StringFilter']
    atk3Dam: Union[None, _str, 'types.StringFilter']
    atk3DamageType: Union[None, _str, 'types.StringFilter']
    atk4Type: Union[None, _str, 'types.StringFilter']
    atk4Mod: Union[None, _str, 'types.StringFilter']
    atk4Range: Union[None, _str, 'types.StringFilter']
    atk4RangeShort: Union[None, _str, 'types.StringFilter']
    atk4Dam: Union[None, _str, 'types.StringFilter']
    atk4DamageType: Union[None, _str, 'types.StringFilter']
    saveDC: Union[None, _str, 'types.StringFilter']
    savingThrow: Union[None, _str, 'types.StringFilter']
    actionNotes: Union[None, _str, 'types.StringFilter']
    ability: Union[None, _str, 'types.StringFilter']
    spellSaveDC: Union[None, _str, 'types.StringFilter']
    spellSavingThrows: Union[None, _str, 'types.StringFilter']
    spellAttack: Union[None, _str, 'types.StringFilter']
    atWillSpells: Union[None, _str, 'types.StringFilter']
    threePerDaySpells: Union[None, _str, 'types.StringFilter']
    twoPerDaySpells: Union[None, _str, 'types.StringFilter']
    onePerDaySpells: Union[None, _str, 'types.StringFilter']
    bonusAction: Union[None, _str, 'types.StringFilter']
    reaction: Union[None, _str, 'types.StringFilter']
    amount: Union[None, _str, 'types.StringFilter']
    legendaryActionSaveDC: Union[None, _str, 'types.StringFilter']
    legendaryActionSavingThrow: Union[None, _str, 'types.StringFilter']
    legendaryActions: Union[None, _str, 'types.StringFilter']
    lair: Union[None, _str, 'types.StringFilter']
    xpLair: Union[None, _str, 'types.StringFilter']
    legendaryResistance: Union[None, _str, 'types.StringFilter']
    legendaryActionsLair: Union[None, _str, 'types.StringFilter']
    lairSaveDC: Union[None, _str, 'types.StringFilter']
    lairSavingThrows: Union[None, _str, 'types.StringFilter']
    other: Union[None, _str, 'types.StringFilter']
    align: Union[None, _str, 'types.StringFilter']
    speeds: Union[None, _str, 'types.StringFilter']
    strScore: Union[None, _str, 'types.StringFilter']
    dexScore: Union[None, _str, 'types.StringFilter']
    conScore: Union[None, _str, 'types.StringFilter']
    intScore: Union[None, _str, 'types.StringFilter']
    wisScore: Union[None, _str, 'types.StringFilter']
    chaScore: Union[None, _str, 'types.StringFilter']
    savThrows: Union[None, _str, 'types.StringFilter']
    skills: Union[None, _str, 'types.StringFilter']
    wri: Union[None, _str, 'types.StringFilter']
    senses: Union[None, _str, 'types.StringFilter']
    additional: Union[None, _str, 'types.StringFilter']
    font: Union[None, _str, 'types.StringFilter']
    additionalInfo: Union[None, _str, 'types.StringFilter']
    author: Union[None, _str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['MonsterWhereInputRecursive3', List['MonsterWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['MonsterWhereInputRecursive3']
    OR: List['MonsterWhereInputRecursive3']
    NOT: List['MonsterWhereInputRecursive3']


class MonsterWhereInputRecursive3(TypedDict, total=False):
    """Monster arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    size: Union[None, _str, 'types.StringFilter']
    type: Union[None, _str, 'types.StringFilter']
    alignment: Union[None, _str, 'types.StringFilter']
    habitat: Union[None, _str, 'types.StringFilter']
    mainHabitat: Union[None, _str, 'types.StringFilter']
    otherHabitat: Union[None, _str, 'types.StringFilter']
    treasure: Union[None, _str, 'types.StringFilter']
    ac: Union[None, _str, 'types.StringFilter']
    hp: Union[None, _str, 'types.StringFilter']
    initiative: Union[None, _str, 'types.StringFilter']
    walk: Union[None, _str, 'types.StringFilter']
    burrow: Union[None, _str, 'types.StringFilter']
    climb: Union[None, _str, 'types.StringFilter']
    fly: Union[None, _str, 'types.StringFilter']
    hover: Union[None, _str, 'types.StringFilter']
    swim: Union[None, _str, 'types.StringFilter']
    strMod: Union[None, _str, 'types.StringFilter']
    intMod: Union[None, _str, 'types.StringFilter']
    dexMod: Union[None, _str, 'types.StringFilter']
    wisMod: Union[None, _str, 'types.StringFilter']
    conMod: Union[None, _str, 'types.StringFilter']
    chaMod: Union[None, _str, 'types.StringFilter']
    strSave: Union[None, _str, 'types.StringFilter']
    intSave: Union[None, _str, 'types.StringFilter']
    dexSave: Union[None, _str, 'types.StringFilter']
    wisSave: Union[None, _str, 'types.StringFilter']
    conSave: Union[None, _str, 'types.StringFilter']
    chaSave: Union[None, _str, 'types.StringFilter']
    proficient: Union[None, _str, 'types.StringFilter']
    expertise: Union[None, _str, 'types.StringFilter']
    vulnerabilities: Union[None, _str, 'types.StringFilter']
    slashing: Union[None, _str, 'types.StringFilter']
    immunitiesConditions: Union[None, _str, 'types.StringFilter']
    immunitiesDamage: Union[None, _str, 'types.StringFilter']
    blindsight: Union[None, _str, 'types.StringFilter']
    darkvision: Union[None, _str, 'types.StringFilter']
    truesight: Union[None, _str, 'types.StringFilter']
    tremorsense: Union[None, _str, 'types.StringFilter']
    passivePerception: Union[None, _str, 'types.StringFilter']
    languages: Union[None, _str, 'types.StringFilter']
    cr: Union[None, _str, 'types.StringFilter']
    xpVal: Union[None, _str, 'types.StringFilter']
    pb: Union[None, _str, 'types.StringFilter']
    traits: Union[None, _str, 'types.StringFilter']
    legendaryResistanceCount: Union[None, _str, 'types.StringFilter']
    numberOfAtk: Union[None, _str, 'types.StringFilter']
    atk1Type: Union[None, _str, 'types.StringFilter']
    atk1Mod: Union[None, _str, 'types.StringFilter']
    atk1Range: Union[None, _str, 'types.StringFilter']
    atk1RangeShort: Union[None, _str, 'types.StringFilter']
    atk1Dam: Union[None, _str, 'types.StringFilter']
    atk1DamageType: Union[None, _str, 'types.StringFilter']
    atk2Type: Union[None, _str, 'types.StringFilter']
    atk2Mod: Union[None, _str, 'types.StringFilter']
    atk2Range: Union[None, _str, 'types.StringFilter']
    atk2RangeShort: Union[None, _str, 'types.StringFilter']
    atk2Dam: Union[None, _str, 'types.StringFilter']
    atk2DamageType: Union[None, _str, 'types.StringFilter']
    atk3Type: Union[None, _str, 'types.StringFilter']
    atk3Mod: Union[None, _str, 'types.StringFilter']
    atk3Range: Union[None, _str, 'types.StringFilter']
    atk3RangeShort: Union[None, _str, 'types.StringFilter']
    atk3Dam: Union[None, _str, 'types.StringFilter']
    atk3DamageType: Union[None, _str, 'types.StringFilter']
    atk4Type: Union[None, _str, 'types.StringFilter']
    atk4Mod: Union[None, _str, 'types.StringFilter']
    atk4Range: Union[None, _str, 'types.StringFilter']
    atk4RangeShort: Union[None, _str, 'types.StringFilter']
    atk4Dam: Union[None, _str, 'types.StringFilter']
    atk4DamageType: Union[None, _str, 'types.StringFilter']
    saveDC: Union[None, _str, 'types.StringFilter']
    savingThrow: Union[None, _str, 'types.StringFilter']
    actionNotes: Union[None, _str, 'types.StringFilter']
    ability: Union[None, _str, 'types.StringFilter']
    spellSaveDC: Union[None, _str, 'types.StringFilter']
    spellSavingThrows: Union[None, _str, 'types.StringFilter']
    spellAttack: Union[None, _str, 'types.StringFilter']
    atWillSpells: Union[None, _str, 'types.StringFilter']
    threePerDaySpells: Union[None, _str, 'types.StringFilter']
    twoPerDaySpells: Union[None, _str, 'types.StringFilter']
    onePerDaySpells: Union[None, _str, 'types.StringFilter']
    bonusAction: Union[None, _str, 'types.StringFilter']
    reaction: Union[None, _str, 'types.StringFilter']
    amount: Union[None, _str, 'types.StringFilter']
    legendaryActionSaveDC: Union[None, _str, 'types.StringFilter']
    legendaryActionSavingThrow: Union[None, _str, 'types.StringFilter']
    legendaryActions: Union[None, _str, 'types.StringFilter']
    lair: Union[None, _str, 'types.StringFilter']
    xpLair: Union[None, _str, 'types.StringFilter']
    legendaryResistance: Union[None, _str, 'types.StringFilter']
    legendaryActionsLair: Union[None, _str, 'types.StringFilter']
    lairSaveDC: Union[None, _str, 'types.StringFilter']
    lairSavingThrows: Union[None, _str, 'types.StringFilter']
    other: Union[None, _str, 'types.StringFilter']
    align: Union[None, _str, 'types.StringFilter']
    speeds: Union[None, _str, 'types.StringFilter']
    strScore: Union[None, _str, 'types.StringFilter']
    dexScore: Union[None, _str, 'types.StringFilter']
    conScore: Union[None, _str, 'types.StringFilter']
    intScore: Union[None, _str, 'types.StringFilter']
    wisScore: Union[None, _str, 'types.StringFilter']
    chaScore: Union[None, _str, 'types.StringFilter']
    savThrows: Union[None, _str, 'types.StringFilter']
    skills: Union[None, _str, 'types.StringFilter']
    wri: Union[None, _str, 'types.StringFilter']
    senses: Union[None, _str, 'types.StringFilter']
    additional: Union[None, _str, 'types.StringFilter']
    font: Union[None, _str, 'types.StringFilter']
    additionalInfo: Union[None, _str, 'types.StringFilter']
    author: Union[None, _str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['MonsterWhereInputRecursive4', List['MonsterWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['MonsterWhereInputRecursive4']
    OR: List['MonsterWhereInputRecursive4']
    NOT: List['MonsterWhereInputRecursive4']


class MonsterWhereInputRecursive4(TypedDict, total=False):
    """Monster arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    size: Union[None, _str, 'types.StringFilter']
    type: Union[None, _str, 'types.StringFilter']
    alignment: Union[None, _str, 'types.StringFilter']
    habitat: Union[None, _str, 'types.StringFilter']
    mainHabitat: Union[None, _str, 'types.StringFilter']
    otherHabitat: Union[None, _str, 'types.StringFilter']
    treasure: Union[None, _str, 'types.StringFilter']
    ac: Union[None, _str, 'types.StringFilter']
    hp: Union[None, _str, 'types.StringFilter']
    initiative: Union[None, _str, 'types.StringFilter']
    walk: Union[None, _str, 'types.StringFilter']
    burrow: Union[None, _str, 'types.StringFilter']
    climb: Union[None, _str, 'types.StringFilter']
    fly: Union[None, _str, 'types.StringFilter']
    hover: Union[None, _str, 'types.StringFilter']
    swim: Union[None, _str, 'types.StringFilter']
    strMod: Union[None, _str, 'types.StringFilter']
    intMod: Union[None, _str, 'types.StringFilter']
    dexMod: Union[None, _str, 'types.StringFilter']
    wisMod: Union[None, _str, 'types.StringFilter']
    conMod: Union[None, _str, 'types.StringFilter']
    chaMod: Union[None, _str, 'types.StringFilter']
    strSave: Union[None, _str, 'types.StringFilter']
    intSave: Union[None, _str, 'types.StringFilter']
    dexSave: Union[None, _str, 'types.StringFilter']
    wisSave: Union[None, _str, 'types.StringFilter']
    conSave: Union[None, _str, 'types.StringFilter']
    chaSave: Union[None, _str, 'types.StringFilter']
    proficient: Union[None, _str, 'types.StringFilter']
    expertise: Union[None, _str, 'types.StringFilter']
    vulnerabilities: Union[None, _str, 'types.StringFilter']
    slashing: Union[None, _str, 'types.StringFilter']
    immunitiesConditions: Union[None, _str, 'types.StringFilter']
    immunitiesDamage: Union[None, _str, 'types.StringFilter']
    blindsight: Union[None, _str, 'types.StringFilter']
    darkvision: Union[None, _str, 'types.StringFilter']
    truesight: Union[None, _str, 'types.StringFilter']
    tremorsense: Union[None, _str, 'types.StringFilter']
    passivePerception: Union[None, _str, 'types.StringFilter']
    languages: Union[None, _str, 'types.StringFilter']
    cr: Union[None, _str, 'types.StringFilter']
    xpVal: Union[None, _str, 'types.StringFilter']
    pb: Union[None, _str, 'types.StringFilter']
    traits: Union[None, _str, 'types.StringFilter']
    legendaryResistanceCount: Union[None, _str, 'types.StringFilter']
    numberOfAtk: Union[None, _str, 'types.StringFilter']
    atk1Type: Union[None, _str, 'types.StringFilter']
    atk1Mod: Union[None, _str, 'types.StringFilter']
    atk1Range: Union[None, _str, 'types.StringFilter']
    atk1RangeShort: Union[None, _str, 'types.StringFilter']
    atk1Dam: Union[None, _str, 'types.StringFilter']
    atk1DamageType: Union[None, _str, 'types.StringFilter']
    atk2Type: Union[None, _str, 'types.StringFilter']
    atk2Mod: Union[None, _str, 'types.StringFilter']
    atk2Range: Union[None, _str, 'types.StringFilter']
    atk2RangeShort: Union[None, _str, 'types.StringFilter']
    atk2Dam: Union[None, _str, 'types.StringFilter']
    atk2DamageType: Union[None, _str, 'types.StringFilter']
    atk3Type: Union[None, _str, 'types.StringFilter']
    atk3Mod: Union[None, _str, 'types.StringFilter']
    atk3Range: Union[None, _str, 'types.StringFilter']
    atk3RangeShort: Union[None, _str, 'types.StringFilter']
    atk3Dam: Union[None, _str, 'types.StringFilter']
    atk3DamageType: Union[None, _str, 'types.StringFilter']
    atk4Type: Union[None, _str, 'types.StringFilter']
    atk4Mod: Union[None, _str, 'types.StringFilter']
    atk4Range: Union[None, _str, 'types.StringFilter']
    atk4RangeShort: Union[None, _str, 'types.StringFilter']
    atk4Dam: Union[None, _str, 'types.StringFilter']
    atk4DamageType: Union[None, _str, 'types.StringFilter']
    saveDC: Union[None, _str, 'types.StringFilter']
    savingThrow: Union[None, _str, 'types.StringFilter']
    actionNotes: Union[None, _str, 'types.StringFilter']
    ability: Union[None, _str, 'types.StringFilter']
    spellSaveDC: Union[None, _str, 'types.StringFilter']
    spellSavingThrows: Union[None, _str, 'types.StringFilter']
    spellAttack: Union[None, _str, 'types.StringFilter']
    atWillSpells: Union[None, _str, 'types.StringFilter']
    threePerDaySpells: Union[None, _str, 'types.StringFilter']
    twoPerDaySpells: Union[None, _str, 'types.StringFilter']
    onePerDaySpells: Union[None, _str, 'types.StringFilter']
    bonusAction: Union[None, _str, 'types.StringFilter']
    reaction: Union[None, _str, 'types.StringFilter']
    amount: Union[None, _str, 'types.StringFilter']
    legendaryActionSaveDC: Union[None, _str, 'types.StringFilter']
    legendaryActionSavingThrow: Union[None, _str, 'types.StringFilter']
    legendaryActions: Union[None, _str, 'types.StringFilter']
    lair: Union[None, _str, 'types.StringFilter']
    xpLair: Union[None, _str, 'types.StringFilter']
    legendaryResistance: Union[None, _str, 'types.StringFilter']
    legendaryActionsLair: Union[None, _str, 'types.StringFilter']
    lairSaveDC: Union[None, _str, 'types.StringFilter']
    lairSavingThrows: Union[None, _str, 'types.StringFilter']
    other: Union[None, _str, 'types.StringFilter']
    align: Union[None, _str, 'types.StringFilter']
    speeds: Union[None, _str, 'types.StringFilter']
    strScore: Union[None, _str, 'types.StringFilter']
    dexScore: Union[None, _str, 'types.StringFilter']
    conScore: Union[None, _str, 'types.StringFilter']
    intScore: Union[None, _str, 'types.StringFilter']
    wisScore: Union[None, _str, 'types.StringFilter']
    chaScore: Union[None, _str, 'types.StringFilter']
    savThrows: Union[None, _str, 'types.StringFilter']
    skills: Union[None, _str, 'types.StringFilter']
    wri: Union[None, _str, 'types.StringFilter']
    senses: Union[None, _str, 'types.StringFilter']
    additional: Union[None, _str, 'types.StringFilter']
    font: Union[None, _str, 'types.StringFilter']
    additionalInfo: Union[None, _str, 'types.StringFilter']
    author: Union[None, _str, 'types.StringFilter']



# aggregate Monster types


    

class MonsterScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Monster arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    size: Union[_str, 'types.StringWithAggregatesFilter']
    type: Union[_str, 'types.StringWithAggregatesFilter']
    alignment: Union[_str, 'types.StringWithAggregatesFilter']
    habitat: Union[_str, 'types.StringWithAggregatesFilter']
    mainHabitat: Union[_str, 'types.StringWithAggregatesFilter']
    otherHabitat: Union[_str, 'types.StringWithAggregatesFilter']
    treasure: Union[_str, 'types.StringWithAggregatesFilter']
    ac: Union[_str, 'types.StringWithAggregatesFilter']
    hp: Union[_str, 'types.StringWithAggregatesFilter']
    initiative: Union[_str, 'types.StringWithAggregatesFilter']
    walk: Union[_str, 'types.StringWithAggregatesFilter']
    burrow: Union[_str, 'types.StringWithAggregatesFilter']
    climb: Union[_str, 'types.StringWithAggregatesFilter']
    fly: Union[_str, 'types.StringWithAggregatesFilter']
    hover: Union[_str, 'types.StringWithAggregatesFilter']
    swim: Union[_str, 'types.StringWithAggregatesFilter']
    strMod: Union[_str, 'types.StringWithAggregatesFilter']
    intMod: Union[_str, 'types.StringWithAggregatesFilter']
    dexMod: Union[_str, 'types.StringWithAggregatesFilter']
    wisMod: Union[_str, 'types.StringWithAggregatesFilter']
    conMod: Union[_str, 'types.StringWithAggregatesFilter']
    chaMod: Union[_str, 'types.StringWithAggregatesFilter']
    strSave: Union[_str, 'types.StringWithAggregatesFilter']
    intSave: Union[_str, 'types.StringWithAggregatesFilter']
    dexSave: Union[_str, 'types.StringWithAggregatesFilter']
    wisSave: Union[_str, 'types.StringWithAggregatesFilter']
    conSave: Union[_str, 'types.StringWithAggregatesFilter']
    chaSave: Union[_str, 'types.StringWithAggregatesFilter']
    proficient: Union[_str, 'types.StringWithAggregatesFilter']
    expertise: Union[_str, 'types.StringWithAggregatesFilter']
    vulnerabilities: Union[_str, 'types.StringWithAggregatesFilter']
    slashing: Union[_str, 'types.StringWithAggregatesFilter']
    immunitiesConditions: Union[_str, 'types.StringWithAggregatesFilter']
    immunitiesDamage: Union[_str, 'types.StringWithAggregatesFilter']
    blindsight: Union[_str, 'types.StringWithAggregatesFilter']
    darkvision: Union[_str, 'types.StringWithAggregatesFilter']
    truesight: Union[_str, 'types.StringWithAggregatesFilter']
    tremorsense: Union[_str, 'types.StringWithAggregatesFilter']
    passivePerception: Union[_str, 'types.StringWithAggregatesFilter']
    languages: Union[_str, 'types.StringWithAggregatesFilter']
    cr: Union[_str, 'types.StringWithAggregatesFilter']
    xpVal: Union[_str, 'types.StringWithAggregatesFilter']
    pb: Union[_str, 'types.StringWithAggregatesFilter']
    traits: Union[_str, 'types.StringWithAggregatesFilter']
    legendaryResistanceCount: Union[_str, 'types.StringWithAggregatesFilter']
    numberOfAtk: Union[_str, 'types.StringWithAggregatesFilter']
    atk1Type: Union[_str, 'types.StringWithAggregatesFilter']
    atk1Mod: Union[_str, 'types.StringWithAggregatesFilter']
    atk1Range: Union[_str, 'types.StringWithAggregatesFilter']
    atk1RangeShort: Union[_str, 'types.StringWithAggregatesFilter']
    atk1Dam: Union[_str, 'types.StringWithAggregatesFilter']
    atk1DamageType: Union[_str, 'types.StringWithAggregatesFilter']
    atk2Type: Union[_str, 'types.StringWithAggregatesFilter']
    atk2Mod: Union[_str, 'types.StringWithAggregatesFilter']
    atk2Range: Union[_str, 'types.StringWithAggregatesFilter']
    atk2RangeShort: Union[_str, 'types.StringWithAggregatesFilter']
    atk2Dam: Union[_str, 'types.StringWithAggregatesFilter']
    atk2DamageType: Union[_str, 'types.StringWithAggregatesFilter']
    atk3Type: Union[_str, 'types.StringWithAggregatesFilter']
    atk3Mod: Union[_str, 'types.StringWithAggregatesFilter']
    atk3Range: Union[_str, 'types.StringWithAggregatesFilter']
    atk3RangeShort: Union[_str, 'types.StringWithAggregatesFilter']
    atk3Dam: Union[_str, 'types.StringWithAggregatesFilter']
    atk3DamageType: Union[_str, 'types.StringWithAggregatesFilter']
    atk4Type: Union[_str, 'types.StringWithAggregatesFilter']
    atk4Mod: Union[_str, 'types.StringWithAggregatesFilter']
    atk4Range: Union[_str, 'types.StringWithAggregatesFilter']
    atk4RangeShort: Union[_str, 'types.StringWithAggregatesFilter']
    atk4Dam: Union[_str, 'types.StringWithAggregatesFilter']
    atk4DamageType: Union[_str, 'types.StringWithAggregatesFilter']
    saveDC: Union[_str, 'types.StringWithAggregatesFilter']
    savingThrow: Union[_str, 'types.StringWithAggregatesFilter']
    actionNotes: Union[_str, 'types.StringWithAggregatesFilter']
    ability: Union[_str, 'types.StringWithAggregatesFilter']
    spellSaveDC: Union[_str, 'types.StringWithAggregatesFilter']
    spellSavingThrows: Union[_str, 'types.StringWithAggregatesFilter']
    spellAttack: Union[_str, 'types.StringWithAggregatesFilter']
    atWillSpells: Union[_str, 'types.StringWithAggregatesFilter']
    threePerDaySpells: Union[_str, 'types.StringWithAggregatesFilter']
    twoPerDaySpells: Union[_str, 'types.StringWithAggregatesFilter']
    onePerDaySpells: Union[_str, 'types.StringWithAggregatesFilter']
    bonusAction: Union[_str, 'types.StringWithAggregatesFilter']
    reaction: Union[_str, 'types.StringWithAggregatesFilter']
    amount: Union[_str, 'types.StringWithAggregatesFilter']
    legendaryActionSaveDC: Union[_str, 'types.StringWithAggregatesFilter']
    legendaryActionSavingThrow: Union[_str, 'types.StringWithAggregatesFilter']
    legendaryActions: Union[_str, 'types.StringWithAggregatesFilter']
    lair: Union[_str, 'types.StringWithAggregatesFilter']
    xpLair: Union[_str, 'types.StringWithAggregatesFilter']
    legendaryResistance: Union[_str, 'types.StringWithAggregatesFilter']
    legendaryActionsLair: Union[_str, 'types.StringWithAggregatesFilter']
    lairSaveDC: Union[_str, 'types.StringWithAggregatesFilter']
    lairSavingThrows: Union[_str, 'types.StringWithAggregatesFilter']
    other: Union[_str, 'types.StringWithAggregatesFilter']
    align: Union[_str, 'types.StringWithAggregatesFilter']
    speeds: Union[_str, 'types.StringWithAggregatesFilter']
    strScore: Union[_str, 'types.StringWithAggregatesFilter']
    dexScore: Union[_str, 'types.StringWithAggregatesFilter']
    conScore: Union[_str, 'types.StringWithAggregatesFilter']
    intScore: Union[_str, 'types.StringWithAggregatesFilter']
    wisScore: Union[_str, 'types.StringWithAggregatesFilter']
    chaScore: Union[_str, 'types.StringWithAggregatesFilter']
    savThrows: Union[_str, 'types.StringWithAggregatesFilter']
    skills: Union[_str, 'types.StringWithAggregatesFilter']
    wri: Union[_str, 'types.StringWithAggregatesFilter']
    senses: Union[_str, 'types.StringWithAggregatesFilter']
    additional: Union[_str, 'types.StringWithAggregatesFilter']
    font: Union[_str, 'types.StringWithAggregatesFilter']
    additionalInfo: Union[_str, 'types.StringWithAggregatesFilter']
    author: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['MonsterScalarWhereWithAggregatesInputRecursive1']
    OR: List['MonsterScalarWhereWithAggregatesInputRecursive1']
    NOT: List['MonsterScalarWhereWithAggregatesInputRecursive1']


class MonsterScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Monster arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    size: Union[_str, 'types.StringWithAggregatesFilter']
    type: Union[_str, 'types.StringWithAggregatesFilter']
    alignment: Union[_str, 'types.StringWithAggregatesFilter']
    habitat: Union[_str, 'types.StringWithAggregatesFilter']
    mainHabitat: Union[_str, 'types.StringWithAggregatesFilter']
    otherHabitat: Union[_str, 'types.StringWithAggregatesFilter']
    treasure: Union[_str, 'types.StringWithAggregatesFilter']
    ac: Union[_str, 'types.StringWithAggregatesFilter']
    hp: Union[_str, 'types.StringWithAggregatesFilter']
    initiative: Union[_str, 'types.StringWithAggregatesFilter']
    walk: Union[_str, 'types.StringWithAggregatesFilter']
    burrow: Union[_str, 'types.StringWithAggregatesFilter']
    climb: Union[_str, 'types.StringWithAggregatesFilter']
    fly: Union[_str, 'types.StringWithAggregatesFilter']
    hover: Union[_str, 'types.StringWithAggregatesFilter']
    swim: Union[_str, 'types.StringWithAggregatesFilter']
    strMod: Union[_str, 'types.StringWithAggregatesFilter']
    intMod: Union[_str, 'types.StringWithAggregatesFilter']
    dexMod: Union[_str, 'types.StringWithAggregatesFilter']
    wisMod: Union[_str, 'types.StringWithAggregatesFilter']
    conMod: Union[_str, 'types.StringWithAggregatesFilter']
    chaMod: Union[_str, 'types.StringWithAggregatesFilter']
    strSave: Union[_str, 'types.StringWithAggregatesFilter']
    intSave: Union[_str, 'types.StringWithAggregatesFilter']
    dexSave: Union[_str, 'types.StringWithAggregatesFilter']
    wisSave: Union[_str, 'types.StringWithAggregatesFilter']
    conSave: Union[_str, 'types.StringWithAggregatesFilter']
    chaSave: Union[_str, 'types.StringWithAggregatesFilter']
    proficient: Union[_str, 'types.StringWithAggregatesFilter']
    expertise: Union[_str, 'types.StringWithAggregatesFilter']
    vulnerabilities: Union[_str, 'types.StringWithAggregatesFilter']
    slashing: Union[_str, 'types.StringWithAggregatesFilter']
    immunitiesConditions: Union[_str, 'types.StringWithAggregatesFilter']
    immunitiesDamage: Union[_str, 'types.StringWithAggregatesFilter']
    blindsight: Union[_str, 'types.StringWithAggregatesFilter']
    darkvision: Union[_str, 'types.StringWithAggregatesFilter']
    truesight: Union[_str, 'types.StringWithAggregatesFilter']
    tremorsense: Union[_str, 'types.StringWithAggregatesFilter']
    passivePerception: Union[_str, 'types.StringWithAggregatesFilter']
    languages: Union[_str, 'types.StringWithAggregatesFilter']
    cr: Union[_str, 'types.StringWithAggregatesFilter']
    xpVal: Union[_str, 'types.StringWithAggregatesFilter']
    pb: Union[_str, 'types.StringWithAggregatesFilter']
    traits: Union[_str, 'types.StringWithAggregatesFilter']
    legendaryResistanceCount: Union[_str, 'types.StringWithAggregatesFilter']
    numberOfAtk: Union[_str, 'types.StringWithAggregatesFilter']
    atk1Type: Union[_str, 'types.StringWithAggregatesFilter']
    atk1Mod: Union[_str, 'types.StringWithAggregatesFilter']
    atk1Range: Union[_str, 'types.StringWithAggregatesFilter']
    atk1RangeShort: Union[_str, 'types.StringWithAggregatesFilter']
    atk1Dam: Union[_str, 'types.StringWithAggregatesFilter']
    atk1DamageType: Union[_str, 'types.StringWithAggregatesFilter']
    atk2Type: Union[_str, 'types.StringWithAggregatesFilter']
    atk2Mod: Union[_str, 'types.StringWithAggregatesFilter']
    atk2Range: Union[_str, 'types.StringWithAggregatesFilter']
    atk2RangeShort: Union[_str, 'types.StringWithAggregatesFilter']
    atk2Dam: Union[_str, 'types.StringWithAggregatesFilter']
    atk2DamageType: Union[_str, 'types.StringWithAggregatesFilter']
    atk3Type: Union[_str, 'types.StringWithAggregatesFilter']
    atk3Mod: Union[_str, 'types.StringWithAggregatesFilter']
    atk3Range: Union[_str, 'types.StringWithAggregatesFilter']
    atk3RangeShort: Union[_str, 'types.StringWithAggregatesFilter']
    atk3Dam: Union[_str, 'types.StringWithAggregatesFilter']
    atk3DamageType: Union[_str, 'types.StringWithAggregatesFilter']
    atk4Type: Union[_str, 'types.StringWithAggregatesFilter']
    atk4Mod: Union[_str, 'types.StringWithAggregatesFilter']
    atk4Range: Union[_str, 'types.StringWithAggregatesFilter']
    atk4RangeShort: Union[_str, 'types.StringWithAggregatesFilter']
    atk4Dam: Union[_str, 'types.StringWithAggregatesFilter']
    atk4DamageType: Union[_str, 'types.StringWithAggregatesFilter']
    saveDC: Union[_str, 'types.StringWithAggregatesFilter']
    savingThrow: Union[_str, 'types.StringWithAggregatesFilter']
    actionNotes: Union[_str, 'types.StringWithAggregatesFilter']
    ability: Union[_str, 'types.StringWithAggregatesFilter']
    spellSaveDC: Union[_str, 'types.StringWithAggregatesFilter']
    spellSavingThrows: Union[_str, 'types.StringWithAggregatesFilter']
    spellAttack: Union[_str, 'types.StringWithAggregatesFilter']
    atWillSpells: Union[_str, 'types.StringWithAggregatesFilter']
    threePerDaySpells: Union[_str, 'types.StringWithAggregatesFilter']
    twoPerDaySpells: Union[_str, 'types.StringWithAggregatesFilter']
    onePerDaySpells: Union[_str, 'types.StringWithAggregatesFilter']
    bonusAction: Union[_str, 'types.StringWithAggregatesFilter']
    reaction: Union[_str, 'types.StringWithAggregatesFilter']
    amount: Union[_str, 'types.StringWithAggregatesFilter']
    legendaryActionSaveDC: Union[_str, 'types.StringWithAggregatesFilter']
    legendaryActionSavingThrow: Union[_str, 'types.StringWithAggregatesFilter']
    legendaryActions: Union[_str, 'types.StringWithAggregatesFilter']
    lair: Union[_str, 'types.StringWithAggregatesFilter']
    xpLair: Union[_str, 'types.StringWithAggregatesFilter']
    legendaryResistance: Union[_str, 'types.StringWithAggregatesFilter']
    legendaryActionsLair: Union[_str, 'types.StringWithAggregatesFilter']
    lairSaveDC: Union[_str, 'types.StringWithAggregatesFilter']
    lairSavingThrows: Union[_str, 'types.StringWithAggregatesFilter']
    other: Union[_str, 'types.StringWithAggregatesFilter']
    align: Union[_str, 'types.StringWithAggregatesFilter']
    speeds: Union[_str, 'types.StringWithAggregatesFilter']
    strScore: Union[_str, 'types.StringWithAggregatesFilter']
    dexScore: Union[_str, 'types.StringWithAggregatesFilter']
    conScore: Union[_str, 'types.StringWithAggregatesFilter']
    intScore: Union[_str, 'types.StringWithAggregatesFilter']
    wisScore: Union[_str, 'types.StringWithAggregatesFilter']
    chaScore: Union[_str, 'types.StringWithAggregatesFilter']
    savThrows: Union[_str, 'types.StringWithAggregatesFilter']
    skills: Union[_str, 'types.StringWithAggregatesFilter']
    wri: Union[_str, 'types.StringWithAggregatesFilter']
    senses: Union[_str, 'types.StringWithAggregatesFilter']
    additional: Union[_str, 'types.StringWithAggregatesFilter']
    font: Union[_str, 'types.StringWithAggregatesFilter']
    additionalInfo: Union[_str, 'types.StringWithAggregatesFilter']
    author: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['MonsterScalarWhereWithAggregatesInputRecursive2']
    OR: List['MonsterScalarWhereWithAggregatesInputRecursive2']
    NOT: List['MonsterScalarWhereWithAggregatesInputRecursive2']


class MonsterScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Monster arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    size: Union[_str, 'types.StringWithAggregatesFilter']
    type: Union[_str, 'types.StringWithAggregatesFilter']
    alignment: Union[_str, 'types.StringWithAggregatesFilter']
    habitat: Union[_str, 'types.StringWithAggregatesFilter']
    mainHabitat: Union[_str, 'types.StringWithAggregatesFilter']
    otherHabitat: Union[_str, 'types.StringWithAggregatesFilter']
    treasure: Union[_str, 'types.StringWithAggregatesFilter']
    ac: Union[_str, 'types.StringWithAggregatesFilter']
    hp: Union[_str, 'types.StringWithAggregatesFilter']
    initiative: Union[_str, 'types.StringWithAggregatesFilter']
    walk: Union[_str, 'types.StringWithAggregatesFilter']
    burrow: Union[_str, 'types.StringWithAggregatesFilter']
    climb: Union[_str, 'types.StringWithAggregatesFilter']
    fly: Union[_str, 'types.StringWithAggregatesFilter']
    hover: Union[_str, 'types.StringWithAggregatesFilter']
    swim: Union[_str, 'types.StringWithAggregatesFilter']
    strMod: Union[_str, 'types.StringWithAggregatesFilter']
    intMod: Union[_str, 'types.StringWithAggregatesFilter']
    dexMod: Union[_str, 'types.StringWithAggregatesFilter']
    wisMod: Union[_str, 'types.StringWithAggregatesFilter']
    conMod: Union[_str, 'types.StringWithAggregatesFilter']
    chaMod: Union[_str, 'types.StringWithAggregatesFilter']
    strSave: Union[_str, 'types.StringWithAggregatesFilter']
    intSave: Union[_str, 'types.StringWithAggregatesFilter']
    dexSave: Union[_str, 'types.StringWithAggregatesFilter']
    wisSave: Union[_str, 'types.StringWithAggregatesFilter']
    conSave: Union[_str, 'types.StringWithAggregatesFilter']
    chaSave: Union[_str, 'types.StringWithAggregatesFilter']
    proficient: Union[_str, 'types.StringWithAggregatesFilter']
    expertise: Union[_str, 'types.StringWithAggregatesFilter']
    vulnerabilities: Union[_str, 'types.StringWithAggregatesFilter']
    slashing: Union[_str, 'types.StringWithAggregatesFilter']
    immunitiesConditions: Union[_str, 'types.StringWithAggregatesFilter']
    immunitiesDamage: Union[_str, 'types.StringWithAggregatesFilter']
    blindsight: Union[_str, 'types.StringWithAggregatesFilter']
    darkvision: Union[_str, 'types.StringWithAggregatesFilter']
    truesight: Union[_str, 'types.StringWithAggregatesFilter']
    tremorsense: Union[_str, 'types.StringWithAggregatesFilter']
    passivePerception: Union[_str, 'types.StringWithAggregatesFilter']
    languages: Union[_str, 'types.StringWithAggregatesFilter']
    cr: Union[_str, 'types.StringWithAggregatesFilter']
    xpVal: Union[_str, 'types.StringWithAggregatesFilter']
    pb: Union[_str, 'types.StringWithAggregatesFilter']
    traits: Union[_str, 'types.StringWithAggregatesFilter']
    legendaryResistanceCount: Union[_str, 'types.StringWithAggregatesFilter']
    numberOfAtk: Union[_str, 'types.StringWithAggregatesFilter']
    atk1Type: Union[_str, 'types.StringWithAggregatesFilter']
    atk1Mod: Union[_str, 'types.StringWithAggregatesFilter']
    atk1Range: Union[_str, 'types.StringWithAggregatesFilter']
    atk1RangeShort: Union[_str, 'types.StringWithAggregatesFilter']
    atk1Dam: Union[_str, 'types.StringWithAggregatesFilter']
    atk1DamageType: Union[_str, 'types.StringWithAggregatesFilter']
    atk2Type: Union[_str, 'types.StringWithAggregatesFilter']
    atk2Mod: Union[_str, 'types.StringWithAggregatesFilter']
    atk2Range: Union[_str, 'types.StringWithAggregatesFilter']
    atk2RangeShort: Union[_str, 'types.StringWithAggregatesFilter']
    atk2Dam: Union[_str, 'types.StringWithAggregatesFilter']
    atk2DamageType: Union[_str, 'types.StringWithAggregatesFilter']
    atk3Type: Union[_str, 'types.StringWithAggregatesFilter']
    atk3Mod: Union[_str, 'types.StringWithAggregatesFilter']
    atk3Range: Union[_str, 'types.StringWithAggregatesFilter']
    atk3RangeShort: Union[_str, 'types.StringWithAggregatesFilter']
    atk3Dam: Union[_str, 'types.StringWithAggregatesFilter']
    atk3DamageType: Union[_str, 'types.StringWithAggregatesFilter']
    atk4Type: Union[_str, 'types.StringWithAggregatesFilter']
    atk4Mod: Union[_str, 'types.StringWithAggregatesFilter']
    atk4Range: Union[_str, 'types.StringWithAggregatesFilter']
    atk4RangeShort: Union[_str, 'types.StringWithAggregatesFilter']
    atk4Dam: Union[_str, 'types.StringWithAggregatesFilter']
    atk4DamageType: Union[_str, 'types.StringWithAggregatesFilter']
    saveDC: Union[_str, 'types.StringWithAggregatesFilter']
    savingThrow: Union[_str, 'types.StringWithAggregatesFilter']
    actionNotes: Union[_str, 'types.StringWithAggregatesFilter']
    ability: Union[_str, 'types.StringWithAggregatesFilter']
    spellSaveDC: Union[_str, 'types.StringWithAggregatesFilter']
    spellSavingThrows: Union[_str, 'types.StringWithAggregatesFilter']
    spellAttack: Union[_str, 'types.StringWithAggregatesFilter']
    atWillSpells: Union[_str, 'types.StringWithAggregatesFilter']
    threePerDaySpells: Union[_str, 'types.StringWithAggregatesFilter']
    twoPerDaySpells: Union[_str, 'types.StringWithAggregatesFilter']
    onePerDaySpells: Union[_str, 'types.StringWithAggregatesFilter']
    bonusAction: Union[_str, 'types.StringWithAggregatesFilter']
    reaction: Union[_str, 'types.StringWithAggregatesFilter']
    amount: Union[_str, 'types.StringWithAggregatesFilter']
    legendaryActionSaveDC: Union[_str, 'types.StringWithAggregatesFilter']
    legendaryActionSavingThrow: Union[_str, 'types.StringWithAggregatesFilter']
    legendaryActions: Union[_str, 'types.StringWithAggregatesFilter']
    lair: Union[_str, 'types.StringWithAggregatesFilter']
    xpLair: Union[_str, 'types.StringWithAggregatesFilter']
    legendaryResistance: Union[_str, 'types.StringWithAggregatesFilter']
    legendaryActionsLair: Union[_str, 'types.StringWithAggregatesFilter']
    lairSaveDC: Union[_str, 'types.StringWithAggregatesFilter']
    lairSavingThrows: Union[_str, 'types.StringWithAggregatesFilter']
    other: Union[_str, 'types.StringWithAggregatesFilter']
    align: Union[_str, 'types.StringWithAggregatesFilter']
    speeds: Union[_str, 'types.StringWithAggregatesFilter']
    strScore: Union[_str, 'types.StringWithAggregatesFilter']
    dexScore: Union[_str, 'types.StringWithAggregatesFilter']
    conScore: Union[_str, 'types.StringWithAggregatesFilter']
    intScore: Union[_str, 'types.StringWithAggregatesFilter']
    wisScore: Union[_str, 'types.StringWithAggregatesFilter']
    chaScore: Union[_str, 'types.StringWithAggregatesFilter']
    savThrows: Union[_str, 'types.StringWithAggregatesFilter']
    skills: Union[_str, 'types.StringWithAggregatesFilter']
    wri: Union[_str, 'types.StringWithAggregatesFilter']
    senses: Union[_str, 'types.StringWithAggregatesFilter']
    additional: Union[_str, 'types.StringWithAggregatesFilter']
    font: Union[_str, 'types.StringWithAggregatesFilter']
    additionalInfo: Union[_str, 'types.StringWithAggregatesFilter']
    author: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['MonsterScalarWhereWithAggregatesInputRecursive3']
    OR: List['MonsterScalarWhereWithAggregatesInputRecursive3']
    NOT: List['MonsterScalarWhereWithAggregatesInputRecursive3']


class MonsterScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Monster arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    size: Union[_str, 'types.StringWithAggregatesFilter']
    type: Union[_str, 'types.StringWithAggregatesFilter']
    alignment: Union[_str, 'types.StringWithAggregatesFilter']
    habitat: Union[_str, 'types.StringWithAggregatesFilter']
    mainHabitat: Union[_str, 'types.StringWithAggregatesFilter']
    otherHabitat: Union[_str, 'types.StringWithAggregatesFilter']
    treasure: Union[_str, 'types.StringWithAggregatesFilter']
    ac: Union[_str, 'types.StringWithAggregatesFilter']
    hp: Union[_str, 'types.StringWithAggregatesFilter']
    initiative: Union[_str, 'types.StringWithAggregatesFilter']
    walk: Union[_str, 'types.StringWithAggregatesFilter']
    burrow: Union[_str, 'types.StringWithAggregatesFilter']
    climb: Union[_str, 'types.StringWithAggregatesFilter']
    fly: Union[_str, 'types.StringWithAggregatesFilter']
    hover: Union[_str, 'types.StringWithAggregatesFilter']
    swim: Union[_str, 'types.StringWithAggregatesFilter']
    strMod: Union[_str, 'types.StringWithAggregatesFilter']
    intMod: Union[_str, 'types.StringWithAggregatesFilter']
    dexMod: Union[_str, 'types.StringWithAggregatesFilter']
    wisMod: Union[_str, 'types.StringWithAggregatesFilter']
    conMod: Union[_str, 'types.StringWithAggregatesFilter']
    chaMod: Union[_str, 'types.StringWithAggregatesFilter']
    strSave: Union[_str, 'types.StringWithAggregatesFilter']
    intSave: Union[_str, 'types.StringWithAggregatesFilter']
    dexSave: Union[_str, 'types.StringWithAggregatesFilter']
    wisSave: Union[_str, 'types.StringWithAggregatesFilter']
    conSave: Union[_str, 'types.StringWithAggregatesFilter']
    chaSave: Union[_str, 'types.StringWithAggregatesFilter']
    proficient: Union[_str, 'types.StringWithAggregatesFilter']
    expertise: Union[_str, 'types.StringWithAggregatesFilter']
    vulnerabilities: Union[_str, 'types.StringWithAggregatesFilter']
    slashing: Union[_str, 'types.StringWithAggregatesFilter']
    immunitiesConditions: Union[_str, 'types.StringWithAggregatesFilter']
    immunitiesDamage: Union[_str, 'types.StringWithAggregatesFilter']
    blindsight: Union[_str, 'types.StringWithAggregatesFilter']
    darkvision: Union[_str, 'types.StringWithAggregatesFilter']
    truesight: Union[_str, 'types.StringWithAggregatesFilter']
    tremorsense: Union[_str, 'types.StringWithAggregatesFilter']
    passivePerception: Union[_str, 'types.StringWithAggregatesFilter']
    languages: Union[_str, 'types.StringWithAggregatesFilter']
    cr: Union[_str, 'types.StringWithAggregatesFilter']
    xpVal: Union[_str, 'types.StringWithAggregatesFilter']
    pb: Union[_str, 'types.StringWithAggregatesFilter']
    traits: Union[_str, 'types.StringWithAggregatesFilter']
    legendaryResistanceCount: Union[_str, 'types.StringWithAggregatesFilter']
    numberOfAtk: Union[_str, 'types.StringWithAggregatesFilter']
    atk1Type: Union[_str, 'types.StringWithAggregatesFilter']
    atk1Mod: Union[_str, 'types.StringWithAggregatesFilter']
    atk1Range: Union[_str, 'types.StringWithAggregatesFilter']
    atk1RangeShort: Union[_str, 'types.StringWithAggregatesFilter']
    atk1Dam: Union[_str, 'types.StringWithAggregatesFilter']
    atk1DamageType: Union[_str, 'types.StringWithAggregatesFilter']
    atk2Type: Union[_str, 'types.StringWithAggregatesFilter']
    atk2Mod: Union[_str, 'types.StringWithAggregatesFilter']
    atk2Range: Union[_str, 'types.StringWithAggregatesFilter']
    atk2RangeShort: Union[_str, 'types.StringWithAggregatesFilter']
    atk2Dam: Union[_str, 'types.StringWithAggregatesFilter']
    atk2DamageType: Union[_str, 'types.StringWithAggregatesFilter']
    atk3Type: Union[_str, 'types.StringWithAggregatesFilter']
    atk3Mod: Union[_str, 'types.StringWithAggregatesFilter']
    atk3Range: Union[_str, 'types.StringWithAggregatesFilter']
    atk3RangeShort: Union[_str, 'types.StringWithAggregatesFilter']
    atk3Dam: Union[_str, 'types.StringWithAggregatesFilter']
    atk3DamageType: Union[_str, 'types.StringWithAggregatesFilter']
    atk4Type: Union[_str, 'types.StringWithAggregatesFilter']
    atk4Mod: Union[_str, 'types.StringWithAggregatesFilter']
    atk4Range: Union[_str, 'types.StringWithAggregatesFilter']
    atk4RangeShort: Union[_str, 'types.StringWithAggregatesFilter']
    atk4Dam: Union[_str, 'types.StringWithAggregatesFilter']
    atk4DamageType: Union[_str, 'types.StringWithAggregatesFilter']
    saveDC: Union[_str, 'types.StringWithAggregatesFilter']
    savingThrow: Union[_str, 'types.StringWithAggregatesFilter']
    actionNotes: Union[_str, 'types.StringWithAggregatesFilter']
    ability: Union[_str, 'types.StringWithAggregatesFilter']
    spellSaveDC: Union[_str, 'types.StringWithAggregatesFilter']
    spellSavingThrows: Union[_str, 'types.StringWithAggregatesFilter']
    spellAttack: Union[_str, 'types.StringWithAggregatesFilter']
    atWillSpells: Union[_str, 'types.StringWithAggregatesFilter']
    threePerDaySpells: Union[_str, 'types.StringWithAggregatesFilter']
    twoPerDaySpells: Union[_str, 'types.StringWithAggregatesFilter']
    onePerDaySpells: Union[_str, 'types.StringWithAggregatesFilter']
    bonusAction: Union[_str, 'types.StringWithAggregatesFilter']
    reaction: Union[_str, 'types.StringWithAggregatesFilter']
    amount: Union[_str, 'types.StringWithAggregatesFilter']
    legendaryActionSaveDC: Union[_str, 'types.StringWithAggregatesFilter']
    legendaryActionSavingThrow: Union[_str, 'types.StringWithAggregatesFilter']
    legendaryActions: Union[_str, 'types.StringWithAggregatesFilter']
    lair: Union[_str, 'types.StringWithAggregatesFilter']
    xpLair: Union[_str, 'types.StringWithAggregatesFilter']
    legendaryResistance: Union[_str, 'types.StringWithAggregatesFilter']
    legendaryActionsLair: Union[_str, 'types.StringWithAggregatesFilter']
    lairSaveDC: Union[_str, 'types.StringWithAggregatesFilter']
    lairSavingThrows: Union[_str, 'types.StringWithAggregatesFilter']
    other: Union[_str, 'types.StringWithAggregatesFilter']
    align: Union[_str, 'types.StringWithAggregatesFilter']
    speeds: Union[_str, 'types.StringWithAggregatesFilter']
    strScore: Union[_str, 'types.StringWithAggregatesFilter']
    dexScore: Union[_str, 'types.StringWithAggregatesFilter']
    conScore: Union[_str, 'types.StringWithAggregatesFilter']
    intScore: Union[_str, 'types.StringWithAggregatesFilter']
    wisScore: Union[_str, 'types.StringWithAggregatesFilter']
    chaScore: Union[_str, 'types.StringWithAggregatesFilter']
    savThrows: Union[_str, 'types.StringWithAggregatesFilter']
    skills: Union[_str, 'types.StringWithAggregatesFilter']
    wri: Union[_str, 'types.StringWithAggregatesFilter']
    senses: Union[_str, 'types.StringWithAggregatesFilter']
    additional: Union[_str, 'types.StringWithAggregatesFilter']
    font: Union[_str, 'types.StringWithAggregatesFilter']
    additionalInfo: Union[_str, 'types.StringWithAggregatesFilter']
    author: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['MonsterScalarWhereWithAggregatesInputRecursive4']
    OR: List['MonsterScalarWhereWithAggregatesInputRecursive4']
    NOT: List['MonsterScalarWhereWithAggregatesInputRecursive4']


class MonsterScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Monster arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    size: Union[_str, 'types.StringWithAggregatesFilter']
    type: Union[_str, 'types.StringWithAggregatesFilter']
    alignment: Union[_str, 'types.StringWithAggregatesFilter']
    habitat: Union[_str, 'types.StringWithAggregatesFilter']
    mainHabitat: Union[_str, 'types.StringWithAggregatesFilter']
    otherHabitat: Union[_str, 'types.StringWithAggregatesFilter']
    treasure: Union[_str, 'types.StringWithAggregatesFilter']
    ac: Union[_str, 'types.StringWithAggregatesFilter']
    hp: Union[_str, 'types.StringWithAggregatesFilter']
    initiative: Union[_str, 'types.StringWithAggregatesFilter']
    walk: Union[_str, 'types.StringWithAggregatesFilter']
    burrow: Union[_str, 'types.StringWithAggregatesFilter']
    climb: Union[_str, 'types.StringWithAggregatesFilter']
    fly: Union[_str, 'types.StringWithAggregatesFilter']
    hover: Union[_str, 'types.StringWithAggregatesFilter']
    swim: Union[_str, 'types.StringWithAggregatesFilter']
    strMod: Union[_str, 'types.StringWithAggregatesFilter']
    intMod: Union[_str, 'types.StringWithAggregatesFilter']
    dexMod: Union[_str, 'types.StringWithAggregatesFilter']
    wisMod: Union[_str, 'types.StringWithAggregatesFilter']
    conMod: Union[_str, 'types.StringWithAggregatesFilter']
    chaMod: Union[_str, 'types.StringWithAggregatesFilter']
    strSave: Union[_str, 'types.StringWithAggregatesFilter']
    intSave: Union[_str, 'types.StringWithAggregatesFilter']
    dexSave: Union[_str, 'types.StringWithAggregatesFilter']
    wisSave: Union[_str, 'types.StringWithAggregatesFilter']
    conSave: Union[_str, 'types.StringWithAggregatesFilter']
    chaSave: Union[_str, 'types.StringWithAggregatesFilter']
    proficient: Union[_str, 'types.StringWithAggregatesFilter']
    expertise: Union[_str, 'types.StringWithAggregatesFilter']
    vulnerabilities: Union[_str, 'types.StringWithAggregatesFilter']
    slashing: Union[_str, 'types.StringWithAggregatesFilter']
    immunitiesConditions: Union[_str, 'types.StringWithAggregatesFilter']
    immunitiesDamage: Union[_str, 'types.StringWithAggregatesFilter']
    blindsight: Union[_str, 'types.StringWithAggregatesFilter']
    darkvision: Union[_str, 'types.StringWithAggregatesFilter']
    truesight: Union[_str, 'types.StringWithAggregatesFilter']
    tremorsense: Union[_str, 'types.StringWithAggregatesFilter']
    passivePerception: Union[_str, 'types.StringWithAggregatesFilter']
    languages: Union[_str, 'types.StringWithAggregatesFilter']
    cr: Union[_str, 'types.StringWithAggregatesFilter']
    xpVal: Union[_str, 'types.StringWithAggregatesFilter']
    pb: Union[_str, 'types.StringWithAggregatesFilter']
    traits: Union[_str, 'types.StringWithAggregatesFilter']
    legendaryResistanceCount: Union[_str, 'types.StringWithAggregatesFilter']
    numberOfAtk: Union[_str, 'types.StringWithAggregatesFilter']
    atk1Type: Union[_str, 'types.StringWithAggregatesFilter']
    atk1Mod: Union[_str, 'types.StringWithAggregatesFilter']
    atk1Range: Union[_str, 'types.StringWithAggregatesFilter']
    atk1RangeShort: Union[_str, 'types.StringWithAggregatesFilter']
    atk1Dam: Union[_str, 'types.StringWithAggregatesFilter']
    atk1DamageType: Union[_str, 'types.StringWithAggregatesFilter']
    atk2Type: Union[_str, 'types.StringWithAggregatesFilter']
    atk2Mod: Union[_str, 'types.StringWithAggregatesFilter']
    atk2Range: Union[_str, 'types.StringWithAggregatesFilter']
    atk2RangeShort: Union[_str, 'types.StringWithAggregatesFilter']
    atk2Dam: Union[_str, 'types.StringWithAggregatesFilter']
    atk2DamageType: Union[_str, 'types.StringWithAggregatesFilter']
    atk3Type: Union[_str, 'types.StringWithAggregatesFilter']
    atk3Mod: Union[_str, 'types.StringWithAggregatesFilter']
    atk3Range: Union[_str, 'types.StringWithAggregatesFilter']
    atk3RangeShort: Union[_str, 'types.StringWithAggregatesFilter']
    atk3Dam: Union[_str, 'types.StringWithAggregatesFilter']
    atk3DamageType: Union[_str, 'types.StringWithAggregatesFilter']
    atk4Type: Union[_str, 'types.StringWithAggregatesFilter']
    atk4Mod: Union[_str, 'types.StringWithAggregatesFilter']
    atk4Range: Union[_str, 'types.StringWithAggregatesFilter']
    atk4RangeShort: Union[_str, 'types.StringWithAggregatesFilter']
    atk4Dam: Union[_str, 'types.StringWithAggregatesFilter']
    atk4DamageType: Union[_str, 'types.StringWithAggregatesFilter']
    saveDC: Union[_str, 'types.StringWithAggregatesFilter']
    savingThrow: Union[_str, 'types.StringWithAggregatesFilter']
    actionNotes: Union[_str, 'types.StringWithAggregatesFilter']
    ability: Union[_str, 'types.StringWithAggregatesFilter']
    spellSaveDC: Union[_str, 'types.StringWithAggregatesFilter']
    spellSavingThrows: Union[_str, 'types.StringWithAggregatesFilter']
    spellAttack: Union[_str, 'types.StringWithAggregatesFilter']
    atWillSpells: Union[_str, 'types.StringWithAggregatesFilter']
    threePerDaySpells: Union[_str, 'types.StringWithAggregatesFilter']
    twoPerDaySpells: Union[_str, 'types.StringWithAggregatesFilter']
    onePerDaySpells: Union[_str, 'types.StringWithAggregatesFilter']
    bonusAction: Union[_str, 'types.StringWithAggregatesFilter']
    reaction: Union[_str, 'types.StringWithAggregatesFilter']
    amount: Union[_str, 'types.StringWithAggregatesFilter']
    legendaryActionSaveDC: Union[_str, 'types.StringWithAggregatesFilter']
    legendaryActionSavingThrow: Union[_str, 'types.StringWithAggregatesFilter']
    legendaryActions: Union[_str, 'types.StringWithAggregatesFilter']
    lair: Union[_str, 'types.StringWithAggregatesFilter']
    xpLair: Union[_str, 'types.StringWithAggregatesFilter']
    legendaryResistance: Union[_str, 'types.StringWithAggregatesFilter']
    legendaryActionsLair: Union[_str, 'types.StringWithAggregatesFilter']
    lairSaveDC: Union[_str, 'types.StringWithAggregatesFilter']
    lairSavingThrows: Union[_str, 'types.StringWithAggregatesFilter']
    other: Union[_str, 'types.StringWithAggregatesFilter']
    align: Union[_str, 'types.StringWithAggregatesFilter']
    speeds: Union[_str, 'types.StringWithAggregatesFilter']
    strScore: Union[_str, 'types.StringWithAggregatesFilter']
    dexScore: Union[_str, 'types.StringWithAggregatesFilter']
    conScore: Union[_str, 'types.StringWithAggregatesFilter']
    intScore: Union[_str, 'types.StringWithAggregatesFilter']
    wisScore: Union[_str, 'types.StringWithAggregatesFilter']
    chaScore: Union[_str, 'types.StringWithAggregatesFilter']
    savThrows: Union[_str, 'types.StringWithAggregatesFilter']
    skills: Union[_str, 'types.StringWithAggregatesFilter']
    wri: Union[_str, 'types.StringWithAggregatesFilter']
    senses: Union[_str, 'types.StringWithAggregatesFilter']
    additional: Union[_str, 'types.StringWithAggregatesFilter']
    font: Union[_str, 'types.StringWithAggregatesFilter']
    additionalInfo: Union[_str, 'types.StringWithAggregatesFilter']
    author: Union[_str, 'types.StringWithAggregatesFilter']



class MonsterGroupByOutput(TypedDict, total=False):
    id: _str
    name: _str
    size: _str
    type: _str
    alignment: _str
    habitat: _str
    mainHabitat: _str
    otherHabitat: _str
    treasure: _str
    ac: _str
    hp: _str
    initiative: _str
    walk: _str
    burrow: _str
    climb: _str
    fly: _str
    hover: _str
    swim: _str
    strMod: _str
    intMod: _str
    dexMod: _str
    wisMod: _str
    conMod: _str
    chaMod: _str
    strSave: _str
    intSave: _str
    dexSave: _str
    wisSave: _str
    conSave: _str
    chaSave: _str
    proficient: _str
    expertise: _str
    vulnerabilities: _str
    slashing: _str
    immunitiesConditions: _str
    immunitiesDamage: _str
    blindsight: _str
    darkvision: _str
    truesight: _str
    tremorsense: _str
    passivePerception: _str
    languages: _str
    cr: _str
    xpVal: _str
    pb: _str
    traits: _str
    legendaryResistanceCount: _str
    numberOfAtk: _str
    atk1Type: _str
    atk1Mod: _str
    atk1Range: _str
    atk1RangeShort: _str
    atk1Dam: _str
    atk1DamageType: _str
    atk2Type: _str
    atk2Mod: _str
    atk2Range: _str
    atk2RangeShort: _str
    atk2Dam: _str
    atk2DamageType: _str
    atk3Type: _str
    atk3Mod: _str
    atk3Range: _str
    atk3RangeShort: _str
    atk3Dam: _str
    atk3DamageType: _str
    atk4Type: _str
    atk4Mod: _str
    atk4Range: _str
    atk4RangeShort: _str
    atk4Dam: _str
    atk4DamageType: _str
    saveDC: _str
    savingThrow: _str
    actionNotes: _str
    ability: _str
    spellSaveDC: _str
    spellSavingThrows: _str
    spellAttack: _str
    atWillSpells: _str
    threePerDaySpells: _str
    twoPerDaySpells: _str
    onePerDaySpells: _str
    bonusAction: _str
    reaction: _str
    amount: _str
    legendaryActionSaveDC: _str
    legendaryActionSavingThrow: _str
    legendaryActions: _str
    lair: _str
    xpLair: _str
    legendaryResistance: _str
    legendaryActionsLair: _str
    lairSaveDC: _str
    lairSavingThrows: _str
    other: _str
    align: _str
    speeds: _str
    strScore: _str
    dexScore: _str
    conScore: _str
    intScore: _str
    wisScore: _str
    chaScore: _str
    savThrows: _str
    skills: _str
    wri: _str
    senses: _str
    additional: _str
    font: _str
    additionalInfo: _str
    author: _str
    _sum: 'MonsterSumAggregateOutput'
    _avg: 'MonsterAvgAggregateOutput'
    _min: 'MonsterMinAggregateOutput'
    _max: 'MonsterMaxAggregateOutput'
    _count: 'MonsterCountAggregateOutput'


class MonsterAvgAggregateOutput(TypedDict, total=False):
    """Monster output for aggregating averages"""


class MonsterSumAggregateOutput(TypedDict, total=False):
    """Monster output for aggregating sums"""


class MonsterScalarAggregateOutput(TypedDict, total=False):
    """Monster output including scalar fields"""
    id: _str
    name: _str
    size: _str
    type: _str
    alignment: _str
    habitat: _str
    mainHabitat: _str
    otherHabitat: _str
    treasure: _str
    ac: _str
    hp: _str
    initiative: _str
    walk: _str
    burrow: _str
    climb: _str
    fly: _str
    hover: _str
    swim: _str
    strMod: _str
    intMod: _str
    dexMod: _str
    wisMod: _str
    conMod: _str
    chaMod: _str
    strSave: _str
    intSave: _str
    dexSave: _str
    wisSave: _str
    conSave: _str
    chaSave: _str
    proficient: _str
    expertise: _str
    vulnerabilities: _str
    slashing: _str
    immunitiesConditions: _str
    immunitiesDamage: _str
    blindsight: _str
    darkvision: _str
    truesight: _str
    tremorsense: _str
    passivePerception: _str
    languages: _str
    cr: _str
    xpVal: _str
    pb: _str
    traits: _str
    legendaryResistanceCount: _str
    numberOfAtk: _str
    atk1Type: _str
    atk1Mod: _str
    atk1Range: _str
    atk1RangeShort: _str
    atk1Dam: _str
    atk1DamageType: _str
    atk2Type: _str
    atk2Mod: _str
    atk2Range: _str
    atk2RangeShort: _str
    atk2Dam: _str
    atk2DamageType: _str
    atk3Type: _str
    atk3Mod: _str
    atk3Range: _str
    atk3RangeShort: _str
    atk3Dam: _str
    atk3DamageType: _str
    atk4Type: _str
    atk4Mod: _str
    atk4Range: _str
    atk4RangeShort: _str
    atk4Dam: _str
    atk4DamageType: _str
    saveDC: _str
    savingThrow: _str
    actionNotes: _str
    ability: _str
    spellSaveDC: _str
    spellSavingThrows: _str
    spellAttack: _str
    atWillSpells: _str
    threePerDaySpells: _str
    twoPerDaySpells: _str
    onePerDaySpells: _str
    bonusAction: _str
    reaction: _str
    amount: _str
    legendaryActionSaveDC: _str
    legendaryActionSavingThrow: _str
    legendaryActions: _str
    lair: _str
    xpLair: _str
    legendaryResistance: _str
    legendaryActionsLair: _str
    lairSaveDC: _str
    lairSavingThrows: _str
    other: _str
    align: _str
    speeds: _str
    strScore: _str
    dexScore: _str
    conScore: _str
    intScore: _str
    wisScore: _str
    chaScore: _str
    savThrows: _str
    skills: _str
    wri: _str
    senses: _str
    additional: _str
    font: _str
    additionalInfo: _str
    author: _str


MonsterMinAggregateOutput = MonsterScalarAggregateOutput
MonsterMaxAggregateOutput = MonsterScalarAggregateOutput


class MonsterMaxAggregateInput(TypedDict, total=False):
    """Monster input for aggregating by max"""
    id: bool
    name: bool
    size: bool
    type: bool
    alignment: bool
    habitat: bool
    mainHabitat: bool
    otherHabitat: bool
    treasure: bool
    ac: bool
    hp: bool
    initiative: bool
    walk: bool
    burrow: bool
    climb: bool
    fly: bool
    hover: bool
    swim: bool
    strMod: bool
    intMod: bool
    dexMod: bool
    wisMod: bool
    conMod: bool
    chaMod: bool
    strSave: bool
    intSave: bool
    dexSave: bool
    wisSave: bool
    conSave: bool
    chaSave: bool
    proficient: bool
    expertise: bool
    vulnerabilities: bool
    slashing: bool
    immunitiesConditions: bool
    immunitiesDamage: bool
    blindsight: bool
    darkvision: bool
    truesight: bool
    tremorsense: bool
    passivePerception: bool
    languages: bool
    cr: bool
    xpVal: bool
    pb: bool
    traits: bool
    legendaryResistanceCount: bool
    numberOfAtk: bool
    atk1Type: bool
    atk1Mod: bool
    atk1Range: bool
    atk1RangeShort: bool
    atk1Dam: bool
    atk1DamageType: bool
    atk2Type: bool
    atk2Mod: bool
    atk2Range: bool
    atk2RangeShort: bool
    atk2Dam: bool
    atk2DamageType: bool
    atk3Type: bool
    atk3Mod: bool
    atk3Range: bool
    atk3RangeShort: bool
    atk3Dam: bool
    atk3DamageType: bool
    atk4Type: bool
    atk4Mod: bool
    atk4Range: bool
    atk4RangeShort: bool
    atk4Dam: bool
    atk4DamageType: bool
    saveDC: bool
    savingThrow: bool
    actionNotes: bool
    ability: bool
    spellSaveDC: bool
    spellSavingThrows: bool
    spellAttack: bool
    atWillSpells: bool
    threePerDaySpells: bool
    twoPerDaySpells: bool
    onePerDaySpells: bool
    bonusAction: bool
    reaction: bool
    amount: bool
    legendaryActionSaveDC: bool
    legendaryActionSavingThrow: bool
    legendaryActions: bool
    lair: bool
    xpLair: bool
    legendaryResistance: bool
    legendaryActionsLair: bool
    lairSaveDC: bool
    lairSavingThrows: bool
    other: bool
    align: bool
    speeds: bool
    strScore: bool
    dexScore: bool
    conScore: bool
    intScore: bool
    wisScore: bool
    chaScore: bool
    savThrows: bool
    skills: bool
    wri: bool
    senses: bool
    additional: bool
    font: bool
    additionalInfo: bool
    author: bool


class MonsterMinAggregateInput(TypedDict, total=False):
    """Monster input for aggregating by min"""
    id: bool
    name: bool
    size: bool
    type: bool
    alignment: bool
    habitat: bool
    mainHabitat: bool
    otherHabitat: bool
    treasure: bool
    ac: bool
    hp: bool
    initiative: bool
    walk: bool
    burrow: bool
    climb: bool
    fly: bool
    hover: bool
    swim: bool
    strMod: bool
    intMod: bool
    dexMod: bool
    wisMod: bool
    conMod: bool
    chaMod: bool
    strSave: bool
    intSave: bool
    dexSave: bool
    wisSave: bool
    conSave: bool
    chaSave: bool
    proficient: bool
    expertise: bool
    vulnerabilities: bool
    slashing: bool
    immunitiesConditions: bool
    immunitiesDamage: bool
    blindsight: bool
    darkvision: bool
    truesight: bool
    tremorsense: bool
    passivePerception: bool
    languages: bool
    cr: bool
    xpVal: bool
    pb: bool
    traits: bool
    legendaryResistanceCount: bool
    numberOfAtk: bool
    atk1Type: bool
    atk1Mod: bool
    atk1Range: bool
    atk1RangeShort: bool
    atk1Dam: bool
    atk1DamageType: bool
    atk2Type: bool
    atk2Mod: bool
    atk2Range: bool
    atk2RangeShort: bool
    atk2Dam: bool
    atk2DamageType: bool
    atk3Type: bool
    atk3Mod: bool
    atk3Range: bool
    atk3RangeShort: bool
    atk3Dam: bool
    atk3DamageType: bool
    atk4Type: bool
    atk4Mod: bool
    atk4Range: bool
    atk4RangeShort: bool
    atk4Dam: bool
    atk4DamageType: bool
    saveDC: bool
    savingThrow: bool
    actionNotes: bool
    ability: bool
    spellSaveDC: bool
    spellSavingThrows: bool
    spellAttack: bool
    atWillSpells: bool
    threePerDaySpells: bool
    twoPerDaySpells: bool
    onePerDaySpells: bool
    bonusAction: bool
    reaction: bool
    amount: bool
    legendaryActionSaveDC: bool
    legendaryActionSavingThrow: bool
    legendaryActions: bool
    lair: bool
    xpLair: bool
    legendaryResistance: bool
    legendaryActionsLair: bool
    lairSaveDC: bool
    lairSavingThrows: bool
    other: bool
    align: bool
    speeds: bool
    strScore: bool
    dexScore: bool
    conScore: bool
    intScore: bool
    wisScore: bool
    chaScore: bool
    savThrows: bool
    skills: bool
    wri: bool
    senses: bool
    additional: bool
    font: bool
    additionalInfo: bool
    author: bool


class MonsterNumberAggregateInput(TypedDict, total=False):
    """Monster input for aggregating numbers"""


MonsterAvgAggregateInput = MonsterNumberAggregateInput
MonsterSumAggregateInput = MonsterNumberAggregateInput


MonsterCountAggregateInput = TypedDict(
    'MonsterCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'size': bool,
        'type': bool,
        'alignment': bool,
        'habitat': bool,
        'mainHabitat': bool,
        'otherHabitat': bool,
        'treasure': bool,
        'ac': bool,
        'hp': bool,
        'initiative': bool,
        'walk': bool,
        'burrow': bool,
        'climb': bool,
        'fly': bool,
        'hover': bool,
        'swim': bool,
        'strMod': bool,
        'intMod': bool,
        'dexMod': bool,
        'wisMod': bool,
        'conMod': bool,
        'chaMod': bool,
        'strSave': bool,
        'intSave': bool,
        'dexSave': bool,
        'wisSave': bool,
        'conSave': bool,
        'chaSave': bool,
        'proficient': bool,
        'expertise': bool,
        'vulnerabilities': bool,
        'slashing': bool,
        'immunitiesConditions': bool,
        'immunitiesDamage': bool,
        'blindsight': bool,
        'darkvision': bool,
        'truesight': bool,
        'tremorsense': bool,
        'passivePerception': bool,
        'languages': bool,
        'cr': bool,
        'xpVal': bool,
        'pb': bool,
        'traits': bool,
        'legendaryResistanceCount': bool,
        'numberOfAtk': bool,
        'atk1Type': bool,
        'atk1Mod': bool,
        'atk1Range': bool,
        'atk1RangeShort': bool,
        'atk1Dam': bool,
        'atk1DamageType': bool,
        'atk2Type': bool,
        'atk2Mod': bool,
        'atk2Range': bool,
        'atk2RangeShort': bool,
        'atk2Dam': bool,
        'atk2DamageType': bool,
        'atk3Type': bool,
        'atk3Mod': bool,
        'atk3Range': bool,
        'atk3RangeShort': bool,
        'atk3Dam': bool,
        'atk3DamageType': bool,
        'atk4Type': bool,
        'atk4Mod': bool,
        'atk4Range': bool,
        'atk4RangeShort': bool,
        'atk4Dam': bool,
        'atk4DamageType': bool,
        'saveDC': bool,
        'savingThrow': bool,
        'actionNotes': bool,
        'ability': bool,
        'spellSaveDC': bool,
        'spellSavingThrows': bool,
        'spellAttack': bool,
        'atWillSpells': bool,
        'threePerDaySpells': bool,
        'twoPerDaySpells': bool,
        'onePerDaySpells': bool,
        'bonusAction': bool,
        'reaction': bool,
        'amount': bool,
        'legendaryActionSaveDC': bool,
        'legendaryActionSavingThrow': bool,
        'legendaryActions': bool,
        'lair': bool,
        'xpLair': bool,
        'legendaryResistance': bool,
        'legendaryActionsLair': bool,
        'lairSaveDC': bool,
        'lairSavingThrows': bool,
        'other': bool,
        'align': bool,
        'speeds': bool,
        'strScore': bool,
        'dexScore': bool,
        'conScore': bool,
        'intScore': bool,
        'wisScore': bool,
        'chaScore': bool,
        'savThrows': bool,
        'skills': bool,
        'wri': bool,
        'senses': bool,
        'additional': bool,
        'font': bool,
        'additionalInfo': bool,
        'author': bool,
        '_all': bool,
    },
    total=False,
)

MonsterCountAggregateOutput = TypedDict(
    'MonsterCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'size': int,
        'type': int,
        'alignment': int,
        'habitat': int,
        'mainHabitat': int,
        'otherHabitat': int,
        'treasure': int,
        'ac': int,
        'hp': int,
        'initiative': int,
        'walk': int,
        'burrow': int,
        'climb': int,
        'fly': int,
        'hover': int,
        'swim': int,
        'strMod': int,
        'intMod': int,
        'dexMod': int,
        'wisMod': int,
        'conMod': int,
        'chaMod': int,
        'strSave': int,
        'intSave': int,
        'dexSave': int,
        'wisSave': int,
        'conSave': int,
        'chaSave': int,
        'proficient': int,
        'expertise': int,
        'vulnerabilities': int,
        'slashing': int,
        'immunitiesConditions': int,
        'immunitiesDamage': int,
        'blindsight': int,
        'darkvision': int,
        'truesight': int,
        'tremorsense': int,
        'passivePerception': int,
        'languages': int,
        'cr': int,
        'xpVal': int,
        'pb': int,
        'traits': int,
        'legendaryResistanceCount': int,
        'numberOfAtk': int,
        'atk1Type': int,
        'atk1Mod': int,
        'atk1Range': int,
        'atk1RangeShort': int,
        'atk1Dam': int,
        'atk1DamageType': int,
        'atk2Type': int,
        'atk2Mod': int,
        'atk2Range': int,
        'atk2RangeShort': int,
        'atk2Dam': int,
        'atk2DamageType': int,
        'atk3Type': int,
        'atk3Mod': int,
        'atk3Range': int,
        'atk3RangeShort': int,
        'atk3Dam': int,
        'atk3DamageType': int,
        'atk4Type': int,
        'atk4Mod': int,
        'atk4Range': int,
        'atk4RangeShort': int,
        'atk4Dam': int,
        'atk4DamageType': int,
        'saveDC': int,
        'savingThrow': int,
        'actionNotes': int,
        'ability': int,
        'spellSaveDC': int,
        'spellSavingThrows': int,
        'spellAttack': int,
        'atWillSpells': int,
        'threePerDaySpells': int,
        'twoPerDaySpells': int,
        'onePerDaySpells': int,
        'bonusAction': int,
        'reaction': int,
        'amount': int,
        'legendaryActionSaveDC': int,
        'legendaryActionSavingThrow': int,
        'legendaryActions': int,
        'lair': int,
        'xpLair': int,
        'legendaryResistance': int,
        'legendaryActionsLair': int,
        'lairSaveDC': int,
        'lairSavingThrows': int,
        'other': int,
        'align': int,
        'speeds': int,
        'strScore': int,
        'dexScore': int,
        'conScore': int,
        'intScore': int,
        'wisScore': int,
        'chaScore': int,
        'savThrows': int,
        'skills': int,
        'wri': int,
        'senses': int,
        'additional': int,
        'font': int,
        'additionalInfo': int,
        'author': int,
        '_all': int,
    },
    total=False,
)


MonsterKeys = Literal[
    'id',
    'name',
    'size',
    'type',
    'alignment',
    'habitat',
    'mainHabitat',
    'otherHabitat',
    'treasure',
    'ac',
    'hp',
    'initiative',
    'walk',
    'burrow',
    'climb',
    'fly',
    'hover',
    'swim',
    'strMod',
    'intMod',
    'dexMod',
    'wisMod',
    'conMod',
    'chaMod',
    'strSave',
    'intSave',
    'dexSave',
    'wisSave',
    'conSave',
    'chaSave',
    'proficient',
    'expertise',
    'vulnerabilities',
    'slashing',
    'immunitiesConditions',
    'immunitiesDamage',
    'blindsight',
    'darkvision',
    'truesight',
    'tremorsense',
    'passivePerception',
    'languages',
    'cr',
    'xpVal',
    'pb',
    'traits',
    'legendaryResistanceCount',
    'numberOfAtk',
    'atk1Type',
    'atk1Mod',
    'atk1Range',
    'atk1RangeShort',
    'atk1Dam',
    'atk1DamageType',
    'atk2Type',
    'atk2Mod',
    'atk2Range',
    'atk2RangeShort',
    'atk2Dam',
    'atk2DamageType',
    'atk3Type',
    'atk3Mod',
    'atk3Range',
    'atk3RangeShort',
    'atk3Dam',
    'atk3DamageType',
    'atk4Type',
    'atk4Mod',
    'atk4Range',
    'atk4RangeShort',
    'atk4Dam',
    'atk4DamageType',
    'saveDC',
    'savingThrow',
    'actionNotes',
    'ability',
    'spellSaveDC',
    'spellSavingThrows',
    'spellAttack',
    'atWillSpells',
    'threePerDaySpells',
    'twoPerDaySpells',
    'onePerDaySpells',
    'bonusAction',
    'reaction',
    'amount',
    'legendaryActionSaveDC',
    'legendaryActionSavingThrow',
    'legendaryActions',
    'lair',
    'xpLair',
    'legendaryResistance',
    'legendaryActionsLair',
    'lairSaveDC',
    'lairSavingThrows',
    'other',
    'align',
    'speeds',
    'strScore',
    'dexScore',
    'conScore',
    'intScore',
    'wisScore',
    'chaScore',
    'savThrows',
    'skills',
    'wri',
    'senses',
    'additional',
    'font',
    'additionalInfo',
    'author',
]
MonsterScalarFieldKeys = Literal[
    'id',
    'name',
    'size',
    'type',
    'alignment',
    'habitat',
    'mainHabitat',
    'otherHabitat',
    'treasure',
    'ac',
    'hp',
    'initiative',
    'walk',
    'burrow',
    'climb',
    'fly',
    'hover',
    'swim',
    'strMod',
    'intMod',
    'dexMod',
    'wisMod',
    'conMod',
    'chaMod',
    'strSave',
    'intSave',
    'dexSave',
    'wisSave',
    'conSave',
    'chaSave',
    'proficient',
    'expertise',
    'vulnerabilities',
    'slashing',
    'immunitiesConditions',
    'immunitiesDamage',
    'blindsight',
    'darkvision',
    'truesight',
    'tremorsense',
    'passivePerception',
    'languages',
    'cr',
    'xpVal',
    'pb',
    'traits',
    'legendaryResistanceCount',
    'numberOfAtk',
    'atk1Type',
    'atk1Mod',
    'atk1Range',
    'atk1RangeShort',
    'atk1Dam',
    'atk1DamageType',
    'atk2Type',
    'atk2Mod',
    'atk2Range',
    'atk2RangeShort',
    'atk2Dam',
    'atk2DamageType',
    'atk3Type',
    'atk3Mod',
    'atk3Range',
    'atk3RangeShort',
    'atk3Dam',
    'atk3DamageType',
    'atk4Type',
    'atk4Mod',
    'atk4Range',
    'atk4RangeShort',
    'atk4Dam',
    'atk4DamageType',
    'saveDC',
    'savingThrow',
    'actionNotes',
    'ability',
    'spellSaveDC',
    'spellSavingThrows',
    'spellAttack',
    'atWillSpells',
    'threePerDaySpells',
    'twoPerDaySpells',
    'onePerDaySpells',
    'bonusAction',
    'reaction',
    'amount',
    'legendaryActionSaveDC',
    'legendaryActionSavingThrow',
    'legendaryActions',
    'lair',
    'xpLair',
    'legendaryResistance',
    'legendaryActionsLair',
    'lairSaveDC',
    'lairSavingThrows',
    'other',
    'align',
    'speeds',
    'strScore',
    'dexScore',
    'conScore',
    'intScore',
    'wisScore',
    'chaScore',
    'savThrows',
    'skills',
    'wri',
    'senses',
    'additional',
    'font',
    'additionalInfo',
    'author',
]
MonsterScalarFieldKeysT = TypeVar('MonsterScalarFieldKeysT', bound=MonsterScalarFieldKeys)

MonsterRelationalFieldKeys = _NoneType

# Race types

class RaceOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Race create method"""
    id: _int
    str: Optional[_str]
    dex: Optional[_str]
    con: Optional[_str]
    int: Optional[_str]
    wis: Optional[_str]
    cha: Optional[_str]
    special: Optional[_str]
    notes: Optional[_str]


class RaceCreateInput(RaceOptionalCreateInput):
    """Required arguments to the Race create method"""
    race: _str
    source: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class RaceOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Race create method, without relations"""
    id: _int
    str: Optional[_str]
    dex: Optional[_str]
    con: Optional[_str]
    int: Optional[_str]
    wis: Optional[_str]
    cha: Optional[_str]
    special: Optional[_str]
    notes: Optional[_str]


class RaceCreateWithoutRelationsInput(RaceOptionalCreateWithoutRelationsInput):
    """Required arguments to the Race create method, without relations"""
    race: _str
    source: _str

class RaceConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'RaceCreateWithoutRelationsInput'
    where: 'RaceWhereUniqueInput'

class RaceCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'RaceCreateWithoutRelationsInput'
    connect: 'RaceWhereUniqueInput'
    connect_or_create: 'RaceConnectOrCreateWithoutRelationsInput'


class RaceCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['RaceCreateWithoutRelationsInput', List['RaceCreateWithoutRelationsInput']]
    connect: Union['RaceWhereUniqueInput', List['RaceWhereUniqueInput']]
    connect_or_create: Union['RaceConnectOrCreateWithoutRelationsInput', List['RaceConnectOrCreateWithoutRelationsInput']]

_RaceWhereUnique_id_Input = TypedDict(
    '_RaceWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_RaceWhereUnique_race_Input = TypedDict(
    '_RaceWhereUnique_race_Input',
    {
        'race': '_str',
    },
    total=True
)

RaceWhereUniqueInput = Union[
    '_RaceWhereUnique_id_Input',
    '_RaceWhereUnique_race_Input',
]


class RaceUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    race: _str
    str: Optional[_str]
    dex: Optional[_str]
    con: Optional[_str]
    int: Optional[_str]
    wis: Optional[_str]
    cha: Optional[_str]
    special: Optional[_str]
    source: _str
    notes: Optional[_str]


class RaceUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    race: _str
    str: Optional[_str]
    dex: Optional[_str]
    con: Optional[_str]
    int: Optional[_str]
    wis: Optional[_str]
    cha: Optional[_str]
    special: Optional[_str]
    source: _str
    notes: Optional[_str]


class RaceUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['RaceCreateWithoutRelationsInput']
    connect: List['RaceWhereUniqueInput']
    connect_or_create: List['RaceConnectOrCreateWithoutRelationsInput']
    set: List['RaceWhereUniqueInput']
    disconnect: List['RaceWhereUniqueInput']
    delete: List['RaceWhereUniqueInput']

    # TODO
    # update: List['RaceUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['RaceUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['RaceScalarWhereInput']
    # upsert: List['RaceUpserteWithWhereUniqueWithoutRelationsInput']


class RaceUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'RaceCreateWithoutRelationsInput'
    connect: 'RaceWhereUniqueInput'
    connect_or_create: 'RaceConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'RaceUpdateInput'
    # upsert: 'RaceUpsertWithoutRelationsInput'


class RaceUpsertInput(TypedDict):
    create: 'RaceCreateInput'
    update: 'RaceUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Race_id_OrderByInput = TypedDict(
    '_Race_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Race_race_OrderByInput = TypedDict(
    '_Race_race_OrderByInput',
    {
        'race': 'SortOrder',
    },
    total=True
)

_Race_str_OrderByInput = TypedDict(
    '_Race_str_OrderByInput',
    {
        'str': 'SortOrder',
    },
    total=True
)

_Race_dex_OrderByInput = TypedDict(
    '_Race_dex_OrderByInput',
    {
        'dex': 'SortOrder',
    },
    total=True
)

_Race_con_OrderByInput = TypedDict(
    '_Race_con_OrderByInput',
    {
        'con': 'SortOrder',
    },
    total=True
)

_Race_int_OrderByInput = TypedDict(
    '_Race_int_OrderByInput',
    {
        'int': 'SortOrder',
    },
    total=True
)

_Race_wis_OrderByInput = TypedDict(
    '_Race_wis_OrderByInput',
    {
        'wis': 'SortOrder',
    },
    total=True
)

_Race_cha_OrderByInput = TypedDict(
    '_Race_cha_OrderByInput',
    {
        'cha': 'SortOrder',
    },
    total=True
)

_Race_special_OrderByInput = TypedDict(
    '_Race_special_OrderByInput',
    {
        'special': 'SortOrder',
    },
    total=True
)

_Race_source_OrderByInput = TypedDict(
    '_Race_source_OrderByInput',
    {
        'source': 'SortOrder',
    },
    total=True
)

_Race_notes_OrderByInput = TypedDict(
    '_Race_notes_OrderByInput',
    {
        'notes': 'SortOrder',
    },
    total=True
)

_Race_RelevanceInner = TypedDict(
    '_Race_RelevanceInner',
    {
        'fields': 'List[RaceScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Race_RelevanceOrderByInput = TypedDict(
    '_Race_RelevanceOrderByInput',
    {
        '_relevance': '_Race_RelevanceInner',
    },
    total=True
)

RaceOrderByInput = Union[
    '_Race_id_OrderByInput',
    '_Race_race_OrderByInput',
    '_Race_str_OrderByInput',
    '_Race_dex_OrderByInput',
    '_Race_con_OrderByInput',
    '_Race_int_OrderByInput',
    '_Race_wis_OrderByInput',
    '_Race_cha_OrderByInput',
    '_Race_special_OrderByInput',
    '_Race_source_OrderByInput',
    '_Race_notes_OrderByInput',
    '_Race_RelevanceOrderByInput',
]



# recursive Race types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

RaceRelationFilter = TypedDict(
    'RaceRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class RaceListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class RaceInclude(TypedDict, total=False):
    """Race relational arguments"""


    

class MonsterIncludeFromRace(TypedDict, total=False):
    """Relational arguments for Race"""


class MonsterIncludeFromRaceRecursive1(TypedDict, total=False):
    """Relational arguments for Race"""


class MonsterIncludeFromRaceRecursive2(TypedDict, total=False):
    """Relational arguments for Race"""


class MonsterIncludeFromRaceRecursive3(TypedDict, total=False):
    """Relational arguments for Race"""


class MonsterIncludeFromRaceRecursive4(TypedDict, total=False):
    """Relational arguments for Race"""

    

class MonsterArgsFromRace(TypedDict, total=False):
    """Arguments for Race"""
    include: 'MonsterIncludeFromMonsterRecursive1'


class MonsterArgsFromRaceRecursive1(TypedDict, total=False):
    """Arguments for Race"""
    include: 'MonsterIncludeFromMonsterRecursive2'


class MonsterArgsFromRaceRecursive2(TypedDict, total=False):
    """Arguments for Race"""
    include: 'MonsterIncludeFromMonsterRecursive3'


class MonsterArgsFromRaceRecursive3(TypedDict, total=False):
    """Arguments for Race"""
    include: 'MonsterIncludeFromMonsterRecursive4'


class MonsterArgsFromRaceRecursive4(TypedDict, total=False):
    """Arguments for Race"""
    
    

class FindManyMonsterArgsFromRace(TypedDict, total=False):
    """Arguments for Race"""
    take: int
    skip: int
    order_by: Union['MonsterOrderByInput', List['MonsterOrderByInput']]
    where: 'MonsterWhereInput'
    cursor: 'MonsterWhereUniqueInput'
    distinct: List['MonsterScalarFieldKeys']
    include: 'MonsterIncludeFromMonsterRecursive1'


class FindManyMonsterArgsFromRaceRecursive1(TypedDict, total=False):
    """Arguments for Race"""
    take: int
    skip: int
    order_by: Union['MonsterOrderByInput', List['MonsterOrderByInput']]
    where: 'MonsterWhereInput'
    cursor: 'MonsterWhereUniqueInput'
    distinct: List['MonsterScalarFieldKeys']
    include: 'MonsterIncludeFromMonsterRecursive2'


class FindManyMonsterArgsFromRaceRecursive2(TypedDict, total=False):
    """Arguments for Race"""
    take: int
    skip: int
    order_by: Union['MonsterOrderByInput', List['MonsterOrderByInput']]
    where: 'MonsterWhereInput'
    cursor: 'MonsterWhereUniqueInput'
    distinct: List['MonsterScalarFieldKeys']
    include: 'MonsterIncludeFromMonsterRecursive3'


class FindManyMonsterArgsFromRaceRecursive3(TypedDict, total=False):
    """Arguments for Race"""
    take: int
    skip: int
    order_by: Union['MonsterOrderByInput', List['MonsterOrderByInput']]
    where: 'MonsterWhereInput'
    cursor: 'MonsterWhereUniqueInput'
    distinct: List['MonsterScalarFieldKeys']
    include: 'MonsterIncludeFromMonsterRecursive4'


class FindManyMonsterArgsFromRaceRecursive4(TypedDict, total=False):
    """Arguments for Race"""
    take: int
    skip: int
    order_by: Union['MonsterOrderByInput', List['MonsterOrderByInput']]
    where: 'MonsterWhereInput'
    cursor: 'MonsterWhereUniqueInput'
    distinct: List['MonsterScalarFieldKeys']
    
    

class RaceIncludeFromRace(TypedDict, total=False):
    """Relational arguments for Race"""


class RaceIncludeFromRaceRecursive1(TypedDict, total=False):
    """Relational arguments for Race"""


class RaceIncludeFromRaceRecursive2(TypedDict, total=False):
    """Relational arguments for Race"""


class RaceIncludeFromRaceRecursive3(TypedDict, total=False):
    """Relational arguments for Race"""


class RaceIncludeFromRaceRecursive4(TypedDict, total=False):
    """Relational arguments for Race"""

    

class RaceArgsFromRace(TypedDict, total=False):
    """Arguments for Race"""
    include: 'RaceIncludeFromRaceRecursive1'


class RaceArgsFromRaceRecursive1(TypedDict, total=False):
    """Arguments for Race"""
    include: 'RaceIncludeFromRaceRecursive2'


class RaceArgsFromRaceRecursive2(TypedDict, total=False):
    """Arguments for Race"""
    include: 'RaceIncludeFromRaceRecursive3'


class RaceArgsFromRaceRecursive3(TypedDict, total=False):
    """Arguments for Race"""
    include: 'RaceIncludeFromRaceRecursive4'


class RaceArgsFromRaceRecursive4(TypedDict, total=False):
    """Arguments for Race"""
    
    

class FindManyRaceArgsFromRace(TypedDict, total=False):
    """Arguments for Race"""
    take: int
    skip: int
    order_by: Union['RaceOrderByInput', List['RaceOrderByInput']]
    where: 'RaceWhereInput'
    cursor: 'RaceWhereUniqueInput'
    distinct: List['RaceScalarFieldKeys']
    include: 'RaceIncludeFromRaceRecursive1'


class FindManyRaceArgsFromRaceRecursive1(TypedDict, total=False):
    """Arguments for Race"""
    take: int
    skip: int
    order_by: Union['RaceOrderByInput', List['RaceOrderByInput']]
    where: 'RaceWhereInput'
    cursor: 'RaceWhereUniqueInput'
    distinct: List['RaceScalarFieldKeys']
    include: 'RaceIncludeFromRaceRecursive2'


class FindManyRaceArgsFromRaceRecursive2(TypedDict, total=False):
    """Arguments for Race"""
    take: int
    skip: int
    order_by: Union['RaceOrderByInput', List['RaceOrderByInput']]
    where: 'RaceWhereInput'
    cursor: 'RaceWhereUniqueInput'
    distinct: List['RaceScalarFieldKeys']
    include: 'RaceIncludeFromRaceRecursive3'


class FindManyRaceArgsFromRaceRecursive3(TypedDict, total=False):
    """Arguments for Race"""
    take: int
    skip: int
    order_by: Union['RaceOrderByInput', List['RaceOrderByInput']]
    where: 'RaceWhereInput'
    cursor: 'RaceWhereUniqueInput'
    distinct: List['RaceScalarFieldKeys']
    include: 'RaceIncludeFromRaceRecursive4'


class FindManyRaceArgsFromRaceRecursive4(TypedDict, total=False):
    """Arguments for Race"""
    take: int
    skip: int
    order_by: Union['RaceOrderByInput', List['RaceOrderByInput']]
    where: 'RaceWhereInput'
    cursor: 'RaceWhereUniqueInput'
    distinct: List['RaceScalarFieldKeys']
    
    

class SpellIncludeFromRace(TypedDict, total=False):
    """Relational arguments for Race"""


class SpellIncludeFromRaceRecursive1(TypedDict, total=False):
    """Relational arguments for Race"""


class SpellIncludeFromRaceRecursive2(TypedDict, total=False):
    """Relational arguments for Race"""


class SpellIncludeFromRaceRecursive3(TypedDict, total=False):
    """Relational arguments for Race"""


class SpellIncludeFromRaceRecursive4(TypedDict, total=False):
    """Relational arguments for Race"""

    

class SpellArgsFromRace(TypedDict, total=False):
    """Arguments for Race"""
    include: 'SpellIncludeFromSpellRecursive1'


class SpellArgsFromRaceRecursive1(TypedDict, total=False):
    """Arguments for Race"""
    include: 'SpellIncludeFromSpellRecursive2'


class SpellArgsFromRaceRecursive2(TypedDict, total=False):
    """Arguments for Race"""
    include: 'SpellIncludeFromSpellRecursive3'


class SpellArgsFromRaceRecursive3(TypedDict, total=False):
    """Arguments for Race"""
    include: 'SpellIncludeFromSpellRecursive4'


class SpellArgsFromRaceRecursive4(TypedDict, total=False):
    """Arguments for Race"""
    
    

class FindManySpellArgsFromRace(TypedDict, total=False):
    """Arguments for Race"""
    take: int
    skip: int
    order_by: Union['SpellOrderByInput', List['SpellOrderByInput']]
    where: 'SpellWhereInput'
    cursor: 'SpellWhereUniqueInput'
    distinct: List['SpellScalarFieldKeys']
    include: 'SpellIncludeFromSpellRecursive1'


class FindManySpellArgsFromRaceRecursive1(TypedDict, total=False):
    """Arguments for Race"""
    take: int
    skip: int
    order_by: Union['SpellOrderByInput', List['SpellOrderByInput']]
    where: 'SpellWhereInput'
    cursor: 'SpellWhereUniqueInput'
    distinct: List['SpellScalarFieldKeys']
    include: 'SpellIncludeFromSpellRecursive2'


class FindManySpellArgsFromRaceRecursive2(TypedDict, total=False):
    """Arguments for Race"""
    take: int
    skip: int
    order_by: Union['SpellOrderByInput', List['SpellOrderByInput']]
    where: 'SpellWhereInput'
    cursor: 'SpellWhereUniqueInput'
    distinct: List['SpellScalarFieldKeys']
    include: 'SpellIncludeFromSpellRecursive3'


class FindManySpellArgsFromRaceRecursive3(TypedDict, total=False):
    """Arguments for Race"""
    take: int
    skip: int
    order_by: Union['SpellOrderByInput', List['SpellOrderByInput']]
    where: 'SpellWhereInput'
    cursor: 'SpellWhereUniqueInput'
    distinct: List['SpellScalarFieldKeys']
    include: 'SpellIncludeFromSpellRecursive4'


class FindManySpellArgsFromRaceRecursive4(TypedDict, total=False):
    """Arguments for Race"""
    take: int
    skip: int
    order_by: Union['SpellOrderByInput', List['SpellOrderByInput']]
    where: 'SpellWhereInput'
    cursor: 'SpellWhereUniqueInput'
    distinct: List['SpellScalarFieldKeys']
    
    

class PlayerClassIncludeFromRace(TypedDict, total=False):
    """Relational arguments for Race"""


class PlayerClassIncludeFromRaceRecursive1(TypedDict, total=False):
    """Relational arguments for Race"""


class PlayerClassIncludeFromRaceRecursive2(TypedDict, total=False):
    """Relational arguments for Race"""


class PlayerClassIncludeFromRaceRecursive3(TypedDict, total=False):
    """Relational arguments for Race"""


class PlayerClassIncludeFromRaceRecursive4(TypedDict, total=False):
    """Relational arguments for Race"""

    

class PlayerClassArgsFromRace(TypedDict, total=False):
    """Arguments for Race"""
    include: 'PlayerClassIncludeFromPlayerClassRecursive1'


class PlayerClassArgsFromRaceRecursive1(TypedDict, total=False):
    """Arguments for Race"""
    include: 'PlayerClassIncludeFromPlayerClassRecursive2'


class PlayerClassArgsFromRaceRecursive2(TypedDict, total=False):
    """Arguments for Race"""
    include: 'PlayerClassIncludeFromPlayerClassRecursive3'


class PlayerClassArgsFromRaceRecursive3(TypedDict, total=False):
    """Arguments for Race"""
    include: 'PlayerClassIncludeFromPlayerClassRecursive4'


class PlayerClassArgsFromRaceRecursive4(TypedDict, total=False):
    """Arguments for Race"""
    
    

class FindManyPlayerClassArgsFromRace(TypedDict, total=False):
    """Arguments for Race"""
    take: int
    skip: int
    order_by: Union['PlayerClassOrderByInput', List['PlayerClassOrderByInput']]
    where: 'PlayerClassWhereInput'
    cursor: 'PlayerClassWhereUniqueInput'
    distinct: List['PlayerClassScalarFieldKeys']
    include: 'PlayerClassIncludeFromPlayerClassRecursive1'


class FindManyPlayerClassArgsFromRaceRecursive1(TypedDict, total=False):
    """Arguments for Race"""
    take: int
    skip: int
    order_by: Union['PlayerClassOrderByInput', List['PlayerClassOrderByInput']]
    where: 'PlayerClassWhereInput'
    cursor: 'PlayerClassWhereUniqueInput'
    distinct: List['PlayerClassScalarFieldKeys']
    include: 'PlayerClassIncludeFromPlayerClassRecursive2'


class FindManyPlayerClassArgsFromRaceRecursive2(TypedDict, total=False):
    """Arguments for Race"""
    take: int
    skip: int
    order_by: Union['PlayerClassOrderByInput', List['PlayerClassOrderByInput']]
    where: 'PlayerClassWhereInput'
    cursor: 'PlayerClassWhereUniqueInput'
    distinct: List['PlayerClassScalarFieldKeys']
    include: 'PlayerClassIncludeFromPlayerClassRecursive3'


class FindManyPlayerClassArgsFromRaceRecursive3(TypedDict, total=False):
    """Arguments for Race"""
    take: int
    skip: int
    order_by: Union['PlayerClassOrderByInput', List['PlayerClassOrderByInput']]
    where: 'PlayerClassWhereInput'
    cursor: 'PlayerClassWhereUniqueInput'
    distinct: List['PlayerClassScalarFieldKeys']
    include: 'PlayerClassIncludeFromPlayerClassRecursive4'


class FindManyPlayerClassArgsFromRaceRecursive4(TypedDict, total=False):
    """Arguments for Race"""
    take: int
    skip: int
    order_by: Union['PlayerClassOrderByInput', List['PlayerClassOrderByInput']]
    where: 'PlayerClassWhereInput'
    cursor: 'PlayerClassWhereUniqueInput'
    distinct: List['PlayerClassScalarFieldKeys']
    
    

class MagicItemIncludeFromRace(TypedDict, total=False):
    """Relational arguments for Race"""


class MagicItemIncludeFromRaceRecursive1(TypedDict, total=False):
    """Relational arguments for Race"""


class MagicItemIncludeFromRaceRecursive2(TypedDict, total=False):
    """Relational arguments for Race"""


class MagicItemIncludeFromRaceRecursive3(TypedDict, total=False):
    """Relational arguments for Race"""


class MagicItemIncludeFromRaceRecursive4(TypedDict, total=False):
    """Relational arguments for Race"""

    

class MagicItemArgsFromRace(TypedDict, total=False):
    """Arguments for Race"""
    include: 'MagicItemIncludeFromMagicItemRecursive1'


class MagicItemArgsFromRaceRecursive1(TypedDict, total=False):
    """Arguments for Race"""
    include: 'MagicItemIncludeFromMagicItemRecursive2'


class MagicItemArgsFromRaceRecursive2(TypedDict, total=False):
    """Arguments for Race"""
    include: 'MagicItemIncludeFromMagicItemRecursive3'


class MagicItemArgsFromRaceRecursive3(TypedDict, total=False):
    """Arguments for Race"""
    include: 'MagicItemIncludeFromMagicItemRecursive4'


class MagicItemArgsFromRaceRecursive4(TypedDict, total=False):
    """Arguments for Race"""
    
    

class FindManyMagicItemArgsFromRace(TypedDict, total=False):
    """Arguments for Race"""
    take: int
    skip: int
    order_by: Union['MagicItemOrderByInput', List['MagicItemOrderByInput']]
    where: 'MagicItemWhereInput'
    cursor: 'MagicItemWhereUniqueInput'
    distinct: List['MagicItemScalarFieldKeys']
    include: 'MagicItemIncludeFromMagicItemRecursive1'


class FindManyMagicItemArgsFromRaceRecursive1(TypedDict, total=False):
    """Arguments for Race"""
    take: int
    skip: int
    order_by: Union['MagicItemOrderByInput', List['MagicItemOrderByInput']]
    where: 'MagicItemWhereInput'
    cursor: 'MagicItemWhereUniqueInput'
    distinct: List['MagicItemScalarFieldKeys']
    include: 'MagicItemIncludeFromMagicItemRecursive2'


class FindManyMagicItemArgsFromRaceRecursive2(TypedDict, total=False):
    """Arguments for Race"""
    take: int
    skip: int
    order_by: Union['MagicItemOrderByInput', List['MagicItemOrderByInput']]
    where: 'MagicItemWhereInput'
    cursor: 'MagicItemWhereUniqueInput'
    distinct: List['MagicItemScalarFieldKeys']
    include: 'MagicItemIncludeFromMagicItemRecursive3'


class FindManyMagicItemArgsFromRaceRecursive3(TypedDict, total=False):
    """Arguments for Race"""
    take: int
    skip: int
    order_by: Union['MagicItemOrderByInput', List['MagicItemOrderByInput']]
    where: 'MagicItemWhereInput'
    cursor: 'MagicItemWhereUniqueInput'
    distinct: List['MagicItemScalarFieldKeys']
    include: 'MagicItemIncludeFromMagicItemRecursive4'


class FindManyMagicItemArgsFromRaceRecursive4(TypedDict, total=False):
    """Arguments for Race"""
    take: int
    skip: int
    order_by: Union['MagicItemOrderByInput', List['MagicItemOrderByInput']]
    where: 'MagicItemWhereInput'
    cursor: 'MagicItemWhereUniqueInput'
    distinct: List['MagicItemScalarFieldKeys']
    
    

class GeneralEquipmentIncludeFromRace(TypedDict, total=False):
    """Relational arguments for Race"""


class GeneralEquipmentIncludeFromRaceRecursive1(TypedDict, total=False):
    """Relational arguments for Race"""


class GeneralEquipmentIncludeFromRaceRecursive2(TypedDict, total=False):
    """Relational arguments for Race"""


class GeneralEquipmentIncludeFromRaceRecursive3(TypedDict, total=False):
    """Relational arguments for Race"""


class GeneralEquipmentIncludeFromRaceRecursive4(TypedDict, total=False):
    """Relational arguments for Race"""

    

class GeneralEquipmentArgsFromRace(TypedDict, total=False):
    """Arguments for Race"""
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive1'


class GeneralEquipmentArgsFromRaceRecursive1(TypedDict, total=False):
    """Arguments for Race"""
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive2'


class GeneralEquipmentArgsFromRaceRecursive2(TypedDict, total=False):
    """Arguments for Race"""
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive3'


class GeneralEquipmentArgsFromRaceRecursive3(TypedDict, total=False):
    """Arguments for Race"""
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive4'


class GeneralEquipmentArgsFromRaceRecursive4(TypedDict, total=False):
    """Arguments for Race"""
    
    

class FindManyGeneralEquipmentArgsFromRace(TypedDict, total=False):
    """Arguments for Race"""
    take: int
    skip: int
    order_by: Union['GeneralEquipmentOrderByInput', List['GeneralEquipmentOrderByInput']]
    where: 'GeneralEquipmentWhereInput'
    cursor: 'GeneralEquipmentWhereUniqueInput'
    distinct: List['GeneralEquipmentScalarFieldKeys']
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive1'


class FindManyGeneralEquipmentArgsFromRaceRecursive1(TypedDict, total=False):
    """Arguments for Race"""
    take: int
    skip: int
    order_by: Union['GeneralEquipmentOrderByInput', List['GeneralEquipmentOrderByInput']]
    where: 'GeneralEquipmentWhereInput'
    cursor: 'GeneralEquipmentWhereUniqueInput'
    distinct: List['GeneralEquipmentScalarFieldKeys']
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive2'


class FindManyGeneralEquipmentArgsFromRaceRecursive2(TypedDict, total=False):
    """Arguments for Race"""
    take: int
    skip: int
    order_by: Union['GeneralEquipmentOrderByInput', List['GeneralEquipmentOrderByInput']]
    where: 'GeneralEquipmentWhereInput'
    cursor: 'GeneralEquipmentWhereUniqueInput'
    distinct: List['GeneralEquipmentScalarFieldKeys']
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive3'


class FindManyGeneralEquipmentArgsFromRaceRecursive3(TypedDict, total=False):
    """Arguments for Race"""
    take: int
    skip: int
    order_by: Union['GeneralEquipmentOrderByInput', List['GeneralEquipmentOrderByInput']]
    where: 'GeneralEquipmentWhereInput'
    cursor: 'GeneralEquipmentWhereUniqueInput'
    distinct: List['GeneralEquipmentScalarFieldKeys']
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive4'


class FindManyGeneralEquipmentArgsFromRaceRecursive4(TypedDict, total=False):
    """Arguments for Race"""
    take: int
    skip: int
    order_by: Union['GeneralEquipmentOrderByInput', List['GeneralEquipmentOrderByInput']]
    where: 'GeneralEquipmentWhereInput'
    cursor: 'GeneralEquipmentWhereUniqueInput'
    distinct: List['GeneralEquipmentScalarFieldKeys']
    


FindManyRaceArgs = FindManyRaceArgsFromRace
FindFirstRaceArgs = FindManyRaceArgsFromRace


    

class RaceWhereInput(TypedDict, total=False):
    """Race arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    race: Union[_str, 'types.StringFilter']
    str: Union[None, _str, 'types.StringFilter']
    dex: Union[None, _str, 'types.StringFilter']
    con: Union[None, _str, 'types.StringFilter']
    int: Union[None, _str, 'types.StringFilter']
    wis: Union[None, _str, 'types.StringFilter']
    cha: Union[None, _str, 'types.StringFilter']
    special: Union[None, _str, 'types.StringFilter']
    source: Union[_str, 'types.StringFilter']
    notes: Union[None, _str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['RaceWhereInputRecursive1', List['RaceWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['RaceWhereInputRecursive1']
    OR: List['RaceWhereInputRecursive1']
    NOT: List['RaceWhereInputRecursive1']


class RaceWhereInputRecursive1(TypedDict, total=False):
    """Race arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    race: Union[_str, 'types.StringFilter']
    str: Union[None, _str, 'types.StringFilter']
    dex: Union[None, _str, 'types.StringFilter']
    con: Union[None, _str, 'types.StringFilter']
    int: Union[None, _str, 'types.StringFilter']
    wis: Union[None, _str, 'types.StringFilter']
    cha: Union[None, _str, 'types.StringFilter']
    special: Union[None, _str, 'types.StringFilter']
    source: Union[_str, 'types.StringFilter']
    notes: Union[None, _str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['RaceWhereInputRecursive2', List['RaceWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['RaceWhereInputRecursive2']
    OR: List['RaceWhereInputRecursive2']
    NOT: List['RaceWhereInputRecursive2']


class RaceWhereInputRecursive2(TypedDict, total=False):
    """Race arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    race: Union[_str, 'types.StringFilter']
    str: Union[None, _str, 'types.StringFilter']
    dex: Union[None, _str, 'types.StringFilter']
    con: Union[None, _str, 'types.StringFilter']
    int: Union[None, _str, 'types.StringFilter']
    wis: Union[None, _str, 'types.StringFilter']
    cha: Union[None, _str, 'types.StringFilter']
    special: Union[None, _str, 'types.StringFilter']
    source: Union[_str, 'types.StringFilter']
    notes: Union[None, _str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['RaceWhereInputRecursive3', List['RaceWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['RaceWhereInputRecursive3']
    OR: List['RaceWhereInputRecursive3']
    NOT: List['RaceWhereInputRecursive3']


class RaceWhereInputRecursive3(TypedDict, total=False):
    """Race arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    race: Union[_str, 'types.StringFilter']
    str: Union[None, _str, 'types.StringFilter']
    dex: Union[None, _str, 'types.StringFilter']
    con: Union[None, _str, 'types.StringFilter']
    int: Union[None, _str, 'types.StringFilter']
    wis: Union[None, _str, 'types.StringFilter']
    cha: Union[None, _str, 'types.StringFilter']
    special: Union[None, _str, 'types.StringFilter']
    source: Union[_str, 'types.StringFilter']
    notes: Union[None, _str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['RaceWhereInputRecursive4', List['RaceWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['RaceWhereInputRecursive4']
    OR: List['RaceWhereInputRecursive4']
    NOT: List['RaceWhereInputRecursive4']


class RaceWhereInputRecursive4(TypedDict, total=False):
    """Race arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    race: Union[_str, 'types.StringFilter']
    str: Union[None, _str, 'types.StringFilter']
    dex: Union[None, _str, 'types.StringFilter']
    con: Union[None, _str, 'types.StringFilter']
    int: Union[None, _str, 'types.StringFilter']
    wis: Union[None, _str, 'types.StringFilter']
    cha: Union[None, _str, 'types.StringFilter']
    special: Union[None, _str, 'types.StringFilter']
    source: Union[_str, 'types.StringFilter']
    notes: Union[None, _str, 'types.StringFilter']



# aggregate Race types


    

class RaceScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Race arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    race: Union[_str, 'types.StringWithAggregatesFilter']
    str: Union[_str, 'types.StringWithAggregatesFilter']
    dex: Union[_str, 'types.StringWithAggregatesFilter']
    con: Union[_str, 'types.StringWithAggregatesFilter']
    int: Union[_str, 'types.StringWithAggregatesFilter']
    wis: Union[_str, 'types.StringWithAggregatesFilter']
    cha: Union[_str, 'types.StringWithAggregatesFilter']
    special: Union[_str, 'types.StringWithAggregatesFilter']
    source: Union[_str, 'types.StringWithAggregatesFilter']
    notes: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['RaceScalarWhereWithAggregatesInputRecursive1']
    OR: List['RaceScalarWhereWithAggregatesInputRecursive1']
    NOT: List['RaceScalarWhereWithAggregatesInputRecursive1']


class RaceScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Race arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    race: Union[_str, 'types.StringWithAggregatesFilter']
    str: Union[_str, 'types.StringWithAggregatesFilter']
    dex: Union[_str, 'types.StringWithAggregatesFilter']
    con: Union[_str, 'types.StringWithAggregatesFilter']
    int: Union[_str, 'types.StringWithAggregatesFilter']
    wis: Union[_str, 'types.StringWithAggregatesFilter']
    cha: Union[_str, 'types.StringWithAggregatesFilter']
    special: Union[_str, 'types.StringWithAggregatesFilter']
    source: Union[_str, 'types.StringWithAggregatesFilter']
    notes: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['RaceScalarWhereWithAggregatesInputRecursive2']
    OR: List['RaceScalarWhereWithAggregatesInputRecursive2']
    NOT: List['RaceScalarWhereWithAggregatesInputRecursive2']


class RaceScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Race arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    race: Union[_str, 'types.StringWithAggregatesFilter']
    str: Union[_str, 'types.StringWithAggregatesFilter']
    dex: Union[_str, 'types.StringWithAggregatesFilter']
    con: Union[_str, 'types.StringWithAggregatesFilter']
    int: Union[_str, 'types.StringWithAggregatesFilter']
    wis: Union[_str, 'types.StringWithAggregatesFilter']
    cha: Union[_str, 'types.StringWithAggregatesFilter']
    special: Union[_str, 'types.StringWithAggregatesFilter']
    source: Union[_str, 'types.StringWithAggregatesFilter']
    notes: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['RaceScalarWhereWithAggregatesInputRecursive3']
    OR: List['RaceScalarWhereWithAggregatesInputRecursive3']
    NOT: List['RaceScalarWhereWithAggregatesInputRecursive3']


class RaceScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Race arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    race: Union[_str, 'types.StringWithAggregatesFilter']
    str: Union[_str, 'types.StringWithAggregatesFilter']
    dex: Union[_str, 'types.StringWithAggregatesFilter']
    con: Union[_str, 'types.StringWithAggregatesFilter']
    int: Union[_str, 'types.StringWithAggregatesFilter']
    wis: Union[_str, 'types.StringWithAggregatesFilter']
    cha: Union[_str, 'types.StringWithAggregatesFilter']
    special: Union[_str, 'types.StringWithAggregatesFilter']
    source: Union[_str, 'types.StringWithAggregatesFilter']
    notes: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['RaceScalarWhereWithAggregatesInputRecursive4']
    OR: List['RaceScalarWhereWithAggregatesInputRecursive4']
    NOT: List['RaceScalarWhereWithAggregatesInputRecursive4']


class RaceScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Race arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    race: Union[_str, 'types.StringWithAggregatesFilter']
    str: Union[_str, 'types.StringWithAggregatesFilter']
    dex: Union[_str, 'types.StringWithAggregatesFilter']
    con: Union[_str, 'types.StringWithAggregatesFilter']
    int: Union[_str, 'types.StringWithAggregatesFilter']
    wis: Union[_str, 'types.StringWithAggregatesFilter']
    cha: Union[_str, 'types.StringWithAggregatesFilter']
    special: Union[_str, 'types.StringWithAggregatesFilter']
    source: Union[_str, 'types.StringWithAggregatesFilter']
    notes: Union[_str, 'types.StringWithAggregatesFilter']



class RaceGroupByOutput(TypedDict, total=False):
    id: _int
    race: _str
    str: _str
    dex: _str
    con: _str
    int: _str
    wis: _str
    cha: _str
    special: _str
    source: _str
    notes: _str
    _sum: 'RaceSumAggregateOutput'
    _avg: 'RaceAvgAggregateOutput'
    _min: 'RaceMinAggregateOutput'
    _max: 'RaceMaxAggregateOutput'
    _count: 'RaceCountAggregateOutput'


class RaceAvgAggregateOutput(TypedDict, total=False):
    """Race output for aggregating averages"""
    id: float


class RaceSumAggregateOutput(TypedDict, total=False):
    """Race output for aggregating sums"""
    id: _int


class RaceScalarAggregateOutput(TypedDict, total=False):
    """Race output including scalar fields"""
    id: _int
    race: _str
    str: _str
    dex: _str
    con: _str
    int: _str
    wis: _str
    cha: _str
    special: _str
    source: _str
    notes: _str


RaceMinAggregateOutput = RaceScalarAggregateOutput
RaceMaxAggregateOutput = RaceScalarAggregateOutput


class RaceMaxAggregateInput(TypedDict, total=False):
    """Race input for aggregating by max"""
    id: bool
    race: bool
    str: bool
    dex: bool
    con: bool
    int: bool
    wis: bool
    cha: bool
    special: bool
    source: bool
    notes: bool


class RaceMinAggregateInput(TypedDict, total=False):
    """Race input for aggregating by min"""
    id: bool
    race: bool
    str: bool
    dex: bool
    con: bool
    int: bool
    wis: bool
    cha: bool
    special: bool
    source: bool
    notes: bool


class RaceNumberAggregateInput(TypedDict, total=False):
    """Race input for aggregating numbers"""
    id: bool


RaceAvgAggregateInput = RaceNumberAggregateInput
RaceSumAggregateInput = RaceNumberAggregateInput


RaceCountAggregateInput = TypedDict(
    'RaceCountAggregateInput',
    {
        'id': bool,
        'race': bool,
        'str': bool,
        'dex': bool,
        'con': bool,
        'int': bool,
        'wis': bool,
        'cha': bool,
        'special': bool,
        'source': bool,
        'notes': bool,
        '_all': bool,
    },
    total=False,
)

RaceCountAggregateOutput = TypedDict(
    'RaceCountAggregateOutput',
    {
        'id': int,
        'race': int,
        'str': int,
        'dex': int,
        'con': int,
        'int': int,
        'wis': int,
        'cha': int,
        'special': int,
        'source': int,
        'notes': int,
        '_all': int,
    },
    total=False,
)


RaceKeys = Literal[
    'id',
    'race',
    'str',
    'dex',
    'con',
    'int',
    'wis',
    'cha',
    'special',
    'source',
    'notes',
]
RaceScalarFieldKeys = Literal[
    'id',
    'race',
    'str',
    'dex',
    'con',
    'int',
    'wis',
    'cha',
    'special',
    'source',
    'notes',
]
RaceScalarFieldKeysT = TypeVar('RaceScalarFieldKeysT', bound=RaceScalarFieldKeys)

RaceRelationalFieldKeys = _NoneType

# Spell types

class SpellOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Spell create method"""
    id: _int
    area: Optional[_str]
    attack: Optional[_str]
    save: Optional[_str]
    ritual: Optional[_str]
    concentration: Optional[_str]
    verbal: Optional[_str]
    somatic: Optional[_str]
    material: Optional[_str]
    materialDetails: Optional[_str]


class SpellCreateInput(SpellOptionalCreateInput):
    """Required arguments to the Spell create method"""
    name: _str
    level: _str
    school: _str
    castingTime: _str
    duration: _str
    range: _str
    damageEffect: _str
    source: _str
    details: _str
    link: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class SpellOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Spell create method, without relations"""
    id: _int
    area: Optional[_str]
    attack: Optional[_str]
    save: Optional[_str]
    ritual: Optional[_str]
    concentration: Optional[_str]
    verbal: Optional[_str]
    somatic: Optional[_str]
    material: Optional[_str]
    materialDetails: Optional[_str]


class SpellCreateWithoutRelationsInput(SpellOptionalCreateWithoutRelationsInput):
    """Required arguments to the Spell create method, without relations"""
    name: _str
    level: _str
    school: _str
    castingTime: _str
    duration: _str
    range: _str
    damageEffect: _str
    source: _str
    details: _str
    link: _str

class SpellConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'SpellCreateWithoutRelationsInput'
    where: 'SpellWhereUniqueInput'

class SpellCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'SpellCreateWithoutRelationsInput'
    connect: 'SpellWhereUniqueInput'
    connect_or_create: 'SpellConnectOrCreateWithoutRelationsInput'


class SpellCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['SpellCreateWithoutRelationsInput', List['SpellCreateWithoutRelationsInput']]
    connect: Union['SpellWhereUniqueInput', List['SpellWhereUniqueInput']]
    connect_or_create: Union['SpellConnectOrCreateWithoutRelationsInput', List['SpellConnectOrCreateWithoutRelationsInput']]

_SpellWhereUnique_id_Input = TypedDict(
    '_SpellWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

SpellWhereUniqueInput = _SpellWhereUnique_id_Input


class SpellUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    name: _str
    level: _str
    school: _str
    castingTime: _str
    duration: _str
    range: _str
    area: Optional[_str]
    attack: Optional[_str]
    save: Optional[_str]
    damageEffect: _str
    ritual: Optional[_str]
    concentration: Optional[_str]
    verbal: Optional[_str]
    somatic: Optional[_str]
    material: Optional[_str]
    materialDetails: Optional[_str]
    source: _str
    details: _str
    link: _str


class SpellUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    name: _str
    level: _str
    school: _str
    castingTime: _str
    duration: _str
    range: _str
    area: Optional[_str]
    attack: Optional[_str]
    save: Optional[_str]
    damageEffect: _str
    ritual: Optional[_str]
    concentration: Optional[_str]
    verbal: Optional[_str]
    somatic: Optional[_str]
    material: Optional[_str]
    materialDetails: Optional[_str]
    source: _str
    details: _str
    link: _str


class SpellUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['SpellCreateWithoutRelationsInput']
    connect: List['SpellWhereUniqueInput']
    connect_or_create: List['SpellConnectOrCreateWithoutRelationsInput']
    set: List['SpellWhereUniqueInput']
    disconnect: List['SpellWhereUniqueInput']
    delete: List['SpellWhereUniqueInput']

    # TODO
    # update: List['SpellUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['SpellUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['SpellScalarWhereInput']
    # upsert: List['SpellUpserteWithWhereUniqueWithoutRelationsInput']


class SpellUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'SpellCreateWithoutRelationsInput'
    connect: 'SpellWhereUniqueInput'
    connect_or_create: 'SpellConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'SpellUpdateInput'
    # upsert: 'SpellUpsertWithoutRelationsInput'


class SpellUpsertInput(TypedDict):
    create: 'SpellCreateInput'
    update: 'SpellUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Spell_id_OrderByInput = TypedDict(
    '_Spell_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Spell_name_OrderByInput = TypedDict(
    '_Spell_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Spell_level_OrderByInput = TypedDict(
    '_Spell_level_OrderByInput',
    {
        'level': 'SortOrder',
    },
    total=True
)

_Spell_school_OrderByInput = TypedDict(
    '_Spell_school_OrderByInput',
    {
        'school': 'SortOrder',
    },
    total=True
)

_Spell_castingTime_OrderByInput = TypedDict(
    '_Spell_castingTime_OrderByInput',
    {
        'castingTime': 'SortOrder',
    },
    total=True
)

_Spell_duration_OrderByInput = TypedDict(
    '_Spell_duration_OrderByInput',
    {
        'duration': 'SortOrder',
    },
    total=True
)

_Spell_range_OrderByInput = TypedDict(
    '_Spell_range_OrderByInput',
    {
        'range': 'SortOrder',
    },
    total=True
)

_Spell_area_OrderByInput = TypedDict(
    '_Spell_area_OrderByInput',
    {
        'area': 'SortOrder',
    },
    total=True
)

_Spell_attack_OrderByInput = TypedDict(
    '_Spell_attack_OrderByInput',
    {
        'attack': 'SortOrder',
    },
    total=True
)

_Spell_save_OrderByInput = TypedDict(
    '_Spell_save_OrderByInput',
    {
        'save': 'SortOrder',
    },
    total=True
)

_Spell_damageEffect_OrderByInput = TypedDict(
    '_Spell_damageEffect_OrderByInput',
    {
        'damageEffect': 'SortOrder',
    },
    total=True
)

_Spell_ritual_OrderByInput = TypedDict(
    '_Spell_ritual_OrderByInput',
    {
        'ritual': 'SortOrder',
    },
    total=True
)

_Spell_concentration_OrderByInput = TypedDict(
    '_Spell_concentration_OrderByInput',
    {
        'concentration': 'SortOrder',
    },
    total=True
)

_Spell_verbal_OrderByInput = TypedDict(
    '_Spell_verbal_OrderByInput',
    {
        'verbal': 'SortOrder',
    },
    total=True
)

_Spell_somatic_OrderByInput = TypedDict(
    '_Spell_somatic_OrderByInput',
    {
        'somatic': 'SortOrder',
    },
    total=True
)

_Spell_material_OrderByInput = TypedDict(
    '_Spell_material_OrderByInput',
    {
        'material': 'SortOrder',
    },
    total=True
)

_Spell_materialDetails_OrderByInput = TypedDict(
    '_Spell_materialDetails_OrderByInput',
    {
        'materialDetails': 'SortOrder',
    },
    total=True
)

_Spell_source_OrderByInput = TypedDict(
    '_Spell_source_OrderByInput',
    {
        'source': 'SortOrder',
    },
    total=True
)

_Spell_details_OrderByInput = TypedDict(
    '_Spell_details_OrderByInput',
    {
        'details': 'SortOrder',
    },
    total=True
)

_Spell_link_OrderByInput = TypedDict(
    '_Spell_link_OrderByInput',
    {
        'link': 'SortOrder',
    },
    total=True
)

_Spell_RelevanceInner = TypedDict(
    '_Spell_RelevanceInner',
    {
        'fields': 'List[SpellScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Spell_RelevanceOrderByInput = TypedDict(
    '_Spell_RelevanceOrderByInput',
    {
        '_relevance': '_Spell_RelevanceInner',
    },
    total=True
)

SpellOrderByInput = Union[
    '_Spell_id_OrderByInput',
    '_Spell_name_OrderByInput',
    '_Spell_level_OrderByInput',
    '_Spell_school_OrderByInput',
    '_Spell_castingTime_OrderByInput',
    '_Spell_duration_OrderByInput',
    '_Spell_range_OrderByInput',
    '_Spell_area_OrderByInput',
    '_Spell_attack_OrderByInput',
    '_Spell_save_OrderByInput',
    '_Spell_damageEffect_OrderByInput',
    '_Spell_ritual_OrderByInput',
    '_Spell_concentration_OrderByInput',
    '_Spell_verbal_OrderByInput',
    '_Spell_somatic_OrderByInput',
    '_Spell_material_OrderByInput',
    '_Spell_materialDetails_OrderByInput',
    '_Spell_source_OrderByInput',
    '_Spell_details_OrderByInput',
    '_Spell_link_OrderByInput',
    '_Spell_RelevanceOrderByInput',
]



# recursive Spell types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

SpellRelationFilter = TypedDict(
    'SpellRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class SpellListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class SpellInclude(TypedDict, total=False):
    """Spell relational arguments"""


    

class MonsterIncludeFromSpell(TypedDict, total=False):
    """Relational arguments for Spell"""


class MonsterIncludeFromSpellRecursive1(TypedDict, total=False):
    """Relational arguments for Spell"""


class MonsterIncludeFromSpellRecursive2(TypedDict, total=False):
    """Relational arguments for Spell"""


class MonsterIncludeFromSpellRecursive3(TypedDict, total=False):
    """Relational arguments for Spell"""


class MonsterIncludeFromSpellRecursive4(TypedDict, total=False):
    """Relational arguments for Spell"""

    

class MonsterArgsFromSpell(TypedDict, total=False):
    """Arguments for Spell"""
    include: 'MonsterIncludeFromMonsterRecursive1'


class MonsterArgsFromSpellRecursive1(TypedDict, total=False):
    """Arguments for Spell"""
    include: 'MonsterIncludeFromMonsterRecursive2'


class MonsterArgsFromSpellRecursive2(TypedDict, total=False):
    """Arguments for Spell"""
    include: 'MonsterIncludeFromMonsterRecursive3'


class MonsterArgsFromSpellRecursive3(TypedDict, total=False):
    """Arguments for Spell"""
    include: 'MonsterIncludeFromMonsterRecursive4'


class MonsterArgsFromSpellRecursive4(TypedDict, total=False):
    """Arguments for Spell"""
    
    

class FindManyMonsterArgsFromSpell(TypedDict, total=False):
    """Arguments for Spell"""
    take: int
    skip: int
    order_by: Union['MonsterOrderByInput', List['MonsterOrderByInput']]
    where: 'MonsterWhereInput'
    cursor: 'MonsterWhereUniqueInput'
    distinct: List['MonsterScalarFieldKeys']
    include: 'MonsterIncludeFromMonsterRecursive1'


class FindManyMonsterArgsFromSpellRecursive1(TypedDict, total=False):
    """Arguments for Spell"""
    take: int
    skip: int
    order_by: Union['MonsterOrderByInput', List['MonsterOrderByInput']]
    where: 'MonsterWhereInput'
    cursor: 'MonsterWhereUniqueInput'
    distinct: List['MonsterScalarFieldKeys']
    include: 'MonsterIncludeFromMonsterRecursive2'


class FindManyMonsterArgsFromSpellRecursive2(TypedDict, total=False):
    """Arguments for Spell"""
    take: int
    skip: int
    order_by: Union['MonsterOrderByInput', List['MonsterOrderByInput']]
    where: 'MonsterWhereInput'
    cursor: 'MonsterWhereUniqueInput'
    distinct: List['MonsterScalarFieldKeys']
    include: 'MonsterIncludeFromMonsterRecursive3'


class FindManyMonsterArgsFromSpellRecursive3(TypedDict, total=False):
    """Arguments for Spell"""
    take: int
    skip: int
    order_by: Union['MonsterOrderByInput', List['MonsterOrderByInput']]
    where: 'MonsterWhereInput'
    cursor: 'MonsterWhereUniqueInput'
    distinct: List['MonsterScalarFieldKeys']
    include: 'MonsterIncludeFromMonsterRecursive4'


class FindManyMonsterArgsFromSpellRecursive4(TypedDict, total=False):
    """Arguments for Spell"""
    take: int
    skip: int
    order_by: Union['MonsterOrderByInput', List['MonsterOrderByInput']]
    where: 'MonsterWhereInput'
    cursor: 'MonsterWhereUniqueInput'
    distinct: List['MonsterScalarFieldKeys']
    
    

class RaceIncludeFromSpell(TypedDict, total=False):
    """Relational arguments for Spell"""


class RaceIncludeFromSpellRecursive1(TypedDict, total=False):
    """Relational arguments for Spell"""


class RaceIncludeFromSpellRecursive2(TypedDict, total=False):
    """Relational arguments for Spell"""


class RaceIncludeFromSpellRecursive3(TypedDict, total=False):
    """Relational arguments for Spell"""


class RaceIncludeFromSpellRecursive4(TypedDict, total=False):
    """Relational arguments for Spell"""

    

class RaceArgsFromSpell(TypedDict, total=False):
    """Arguments for Spell"""
    include: 'RaceIncludeFromRaceRecursive1'


class RaceArgsFromSpellRecursive1(TypedDict, total=False):
    """Arguments for Spell"""
    include: 'RaceIncludeFromRaceRecursive2'


class RaceArgsFromSpellRecursive2(TypedDict, total=False):
    """Arguments for Spell"""
    include: 'RaceIncludeFromRaceRecursive3'


class RaceArgsFromSpellRecursive3(TypedDict, total=False):
    """Arguments for Spell"""
    include: 'RaceIncludeFromRaceRecursive4'


class RaceArgsFromSpellRecursive4(TypedDict, total=False):
    """Arguments for Spell"""
    
    

class FindManyRaceArgsFromSpell(TypedDict, total=False):
    """Arguments for Spell"""
    take: int
    skip: int
    order_by: Union['RaceOrderByInput', List['RaceOrderByInput']]
    where: 'RaceWhereInput'
    cursor: 'RaceWhereUniqueInput'
    distinct: List['RaceScalarFieldKeys']
    include: 'RaceIncludeFromRaceRecursive1'


class FindManyRaceArgsFromSpellRecursive1(TypedDict, total=False):
    """Arguments for Spell"""
    take: int
    skip: int
    order_by: Union['RaceOrderByInput', List['RaceOrderByInput']]
    where: 'RaceWhereInput'
    cursor: 'RaceWhereUniqueInput'
    distinct: List['RaceScalarFieldKeys']
    include: 'RaceIncludeFromRaceRecursive2'


class FindManyRaceArgsFromSpellRecursive2(TypedDict, total=False):
    """Arguments for Spell"""
    take: int
    skip: int
    order_by: Union['RaceOrderByInput', List['RaceOrderByInput']]
    where: 'RaceWhereInput'
    cursor: 'RaceWhereUniqueInput'
    distinct: List['RaceScalarFieldKeys']
    include: 'RaceIncludeFromRaceRecursive3'


class FindManyRaceArgsFromSpellRecursive3(TypedDict, total=False):
    """Arguments for Spell"""
    take: int
    skip: int
    order_by: Union['RaceOrderByInput', List['RaceOrderByInput']]
    where: 'RaceWhereInput'
    cursor: 'RaceWhereUniqueInput'
    distinct: List['RaceScalarFieldKeys']
    include: 'RaceIncludeFromRaceRecursive4'


class FindManyRaceArgsFromSpellRecursive4(TypedDict, total=False):
    """Arguments for Spell"""
    take: int
    skip: int
    order_by: Union['RaceOrderByInput', List['RaceOrderByInput']]
    where: 'RaceWhereInput'
    cursor: 'RaceWhereUniqueInput'
    distinct: List['RaceScalarFieldKeys']
    
    

class SpellIncludeFromSpell(TypedDict, total=False):
    """Relational arguments for Spell"""


class SpellIncludeFromSpellRecursive1(TypedDict, total=False):
    """Relational arguments for Spell"""


class SpellIncludeFromSpellRecursive2(TypedDict, total=False):
    """Relational arguments for Spell"""


class SpellIncludeFromSpellRecursive3(TypedDict, total=False):
    """Relational arguments for Spell"""


class SpellIncludeFromSpellRecursive4(TypedDict, total=False):
    """Relational arguments for Spell"""

    

class SpellArgsFromSpell(TypedDict, total=False):
    """Arguments for Spell"""
    include: 'SpellIncludeFromSpellRecursive1'


class SpellArgsFromSpellRecursive1(TypedDict, total=False):
    """Arguments for Spell"""
    include: 'SpellIncludeFromSpellRecursive2'


class SpellArgsFromSpellRecursive2(TypedDict, total=False):
    """Arguments for Spell"""
    include: 'SpellIncludeFromSpellRecursive3'


class SpellArgsFromSpellRecursive3(TypedDict, total=False):
    """Arguments for Spell"""
    include: 'SpellIncludeFromSpellRecursive4'


class SpellArgsFromSpellRecursive4(TypedDict, total=False):
    """Arguments for Spell"""
    
    

class FindManySpellArgsFromSpell(TypedDict, total=False):
    """Arguments for Spell"""
    take: int
    skip: int
    order_by: Union['SpellOrderByInput', List['SpellOrderByInput']]
    where: 'SpellWhereInput'
    cursor: 'SpellWhereUniqueInput'
    distinct: List['SpellScalarFieldKeys']
    include: 'SpellIncludeFromSpellRecursive1'


class FindManySpellArgsFromSpellRecursive1(TypedDict, total=False):
    """Arguments for Spell"""
    take: int
    skip: int
    order_by: Union['SpellOrderByInput', List['SpellOrderByInput']]
    where: 'SpellWhereInput'
    cursor: 'SpellWhereUniqueInput'
    distinct: List['SpellScalarFieldKeys']
    include: 'SpellIncludeFromSpellRecursive2'


class FindManySpellArgsFromSpellRecursive2(TypedDict, total=False):
    """Arguments for Spell"""
    take: int
    skip: int
    order_by: Union['SpellOrderByInput', List['SpellOrderByInput']]
    where: 'SpellWhereInput'
    cursor: 'SpellWhereUniqueInput'
    distinct: List['SpellScalarFieldKeys']
    include: 'SpellIncludeFromSpellRecursive3'


class FindManySpellArgsFromSpellRecursive3(TypedDict, total=False):
    """Arguments for Spell"""
    take: int
    skip: int
    order_by: Union['SpellOrderByInput', List['SpellOrderByInput']]
    where: 'SpellWhereInput'
    cursor: 'SpellWhereUniqueInput'
    distinct: List['SpellScalarFieldKeys']
    include: 'SpellIncludeFromSpellRecursive4'


class FindManySpellArgsFromSpellRecursive4(TypedDict, total=False):
    """Arguments for Spell"""
    take: int
    skip: int
    order_by: Union['SpellOrderByInput', List['SpellOrderByInput']]
    where: 'SpellWhereInput'
    cursor: 'SpellWhereUniqueInput'
    distinct: List['SpellScalarFieldKeys']
    
    

class PlayerClassIncludeFromSpell(TypedDict, total=False):
    """Relational arguments for Spell"""


class PlayerClassIncludeFromSpellRecursive1(TypedDict, total=False):
    """Relational arguments for Spell"""


class PlayerClassIncludeFromSpellRecursive2(TypedDict, total=False):
    """Relational arguments for Spell"""


class PlayerClassIncludeFromSpellRecursive3(TypedDict, total=False):
    """Relational arguments for Spell"""


class PlayerClassIncludeFromSpellRecursive4(TypedDict, total=False):
    """Relational arguments for Spell"""

    

class PlayerClassArgsFromSpell(TypedDict, total=False):
    """Arguments for Spell"""
    include: 'PlayerClassIncludeFromPlayerClassRecursive1'


class PlayerClassArgsFromSpellRecursive1(TypedDict, total=False):
    """Arguments for Spell"""
    include: 'PlayerClassIncludeFromPlayerClassRecursive2'


class PlayerClassArgsFromSpellRecursive2(TypedDict, total=False):
    """Arguments for Spell"""
    include: 'PlayerClassIncludeFromPlayerClassRecursive3'


class PlayerClassArgsFromSpellRecursive3(TypedDict, total=False):
    """Arguments for Spell"""
    include: 'PlayerClassIncludeFromPlayerClassRecursive4'


class PlayerClassArgsFromSpellRecursive4(TypedDict, total=False):
    """Arguments for Spell"""
    
    

class FindManyPlayerClassArgsFromSpell(TypedDict, total=False):
    """Arguments for Spell"""
    take: int
    skip: int
    order_by: Union['PlayerClassOrderByInput', List['PlayerClassOrderByInput']]
    where: 'PlayerClassWhereInput'
    cursor: 'PlayerClassWhereUniqueInput'
    distinct: List['PlayerClassScalarFieldKeys']
    include: 'PlayerClassIncludeFromPlayerClassRecursive1'


class FindManyPlayerClassArgsFromSpellRecursive1(TypedDict, total=False):
    """Arguments for Spell"""
    take: int
    skip: int
    order_by: Union['PlayerClassOrderByInput', List['PlayerClassOrderByInput']]
    where: 'PlayerClassWhereInput'
    cursor: 'PlayerClassWhereUniqueInput'
    distinct: List['PlayerClassScalarFieldKeys']
    include: 'PlayerClassIncludeFromPlayerClassRecursive2'


class FindManyPlayerClassArgsFromSpellRecursive2(TypedDict, total=False):
    """Arguments for Spell"""
    take: int
    skip: int
    order_by: Union['PlayerClassOrderByInput', List['PlayerClassOrderByInput']]
    where: 'PlayerClassWhereInput'
    cursor: 'PlayerClassWhereUniqueInput'
    distinct: List['PlayerClassScalarFieldKeys']
    include: 'PlayerClassIncludeFromPlayerClassRecursive3'


class FindManyPlayerClassArgsFromSpellRecursive3(TypedDict, total=False):
    """Arguments for Spell"""
    take: int
    skip: int
    order_by: Union['PlayerClassOrderByInput', List['PlayerClassOrderByInput']]
    where: 'PlayerClassWhereInput'
    cursor: 'PlayerClassWhereUniqueInput'
    distinct: List['PlayerClassScalarFieldKeys']
    include: 'PlayerClassIncludeFromPlayerClassRecursive4'


class FindManyPlayerClassArgsFromSpellRecursive4(TypedDict, total=False):
    """Arguments for Spell"""
    take: int
    skip: int
    order_by: Union['PlayerClassOrderByInput', List['PlayerClassOrderByInput']]
    where: 'PlayerClassWhereInput'
    cursor: 'PlayerClassWhereUniqueInput'
    distinct: List['PlayerClassScalarFieldKeys']
    
    

class MagicItemIncludeFromSpell(TypedDict, total=False):
    """Relational arguments for Spell"""


class MagicItemIncludeFromSpellRecursive1(TypedDict, total=False):
    """Relational arguments for Spell"""


class MagicItemIncludeFromSpellRecursive2(TypedDict, total=False):
    """Relational arguments for Spell"""


class MagicItemIncludeFromSpellRecursive3(TypedDict, total=False):
    """Relational arguments for Spell"""


class MagicItemIncludeFromSpellRecursive4(TypedDict, total=False):
    """Relational arguments for Spell"""

    

class MagicItemArgsFromSpell(TypedDict, total=False):
    """Arguments for Spell"""
    include: 'MagicItemIncludeFromMagicItemRecursive1'


class MagicItemArgsFromSpellRecursive1(TypedDict, total=False):
    """Arguments for Spell"""
    include: 'MagicItemIncludeFromMagicItemRecursive2'


class MagicItemArgsFromSpellRecursive2(TypedDict, total=False):
    """Arguments for Spell"""
    include: 'MagicItemIncludeFromMagicItemRecursive3'


class MagicItemArgsFromSpellRecursive3(TypedDict, total=False):
    """Arguments for Spell"""
    include: 'MagicItemIncludeFromMagicItemRecursive4'


class MagicItemArgsFromSpellRecursive4(TypedDict, total=False):
    """Arguments for Spell"""
    
    

class FindManyMagicItemArgsFromSpell(TypedDict, total=False):
    """Arguments for Spell"""
    take: int
    skip: int
    order_by: Union['MagicItemOrderByInput', List['MagicItemOrderByInput']]
    where: 'MagicItemWhereInput'
    cursor: 'MagicItemWhereUniqueInput'
    distinct: List['MagicItemScalarFieldKeys']
    include: 'MagicItemIncludeFromMagicItemRecursive1'


class FindManyMagicItemArgsFromSpellRecursive1(TypedDict, total=False):
    """Arguments for Spell"""
    take: int
    skip: int
    order_by: Union['MagicItemOrderByInput', List['MagicItemOrderByInput']]
    where: 'MagicItemWhereInput'
    cursor: 'MagicItemWhereUniqueInput'
    distinct: List['MagicItemScalarFieldKeys']
    include: 'MagicItemIncludeFromMagicItemRecursive2'


class FindManyMagicItemArgsFromSpellRecursive2(TypedDict, total=False):
    """Arguments for Spell"""
    take: int
    skip: int
    order_by: Union['MagicItemOrderByInput', List['MagicItemOrderByInput']]
    where: 'MagicItemWhereInput'
    cursor: 'MagicItemWhereUniqueInput'
    distinct: List['MagicItemScalarFieldKeys']
    include: 'MagicItemIncludeFromMagicItemRecursive3'


class FindManyMagicItemArgsFromSpellRecursive3(TypedDict, total=False):
    """Arguments for Spell"""
    take: int
    skip: int
    order_by: Union['MagicItemOrderByInput', List['MagicItemOrderByInput']]
    where: 'MagicItemWhereInput'
    cursor: 'MagicItemWhereUniqueInput'
    distinct: List['MagicItemScalarFieldKeys']
    include: 'MagicItemIncludeFromMagicItemRecursive4'


class FindManyMagicItemArgsFromSpellRecursive4(TypedDict, total=False):
    """Arguments for Spell"""
    take: int
    skip: int
    order_by: Union['MagicItemOrderByInput', List['MagicItemOrderByInput']]
    where: 'MagicItemWhereInput'
    cursor: 'MagicItemWhereUniqueInput'
    distinct: List['MagicItemScalarFieldKeys']
    
    

class GeneralEquipmentIncludeFromSpell(TypedDict, total=False):
    """Relational arguments for Spell"""


class GeneralEquipmentIncludeFromSpellRecursive1(TypedDict, total=False):
    """Relational arguments for Spell"""


class GeneralEquipmentIncludeFromSpellRecursive2(TypedDict, total=False):
    """Relational arguments for Spell"""


class GeneralEquipmentIncludeFromSpellRecursive3(TypedDict, total=False):
    """Relational arguments for Spell"""


class GeneralEquipmentIncludeFromSpellRecursive4(TypedDict, total=False):
    """Relational arguments for Spell"""

    

class GeneralEquipmentArgsFromSpell(TypedDict, total=False):
    """Arguments for Spell"""
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive1'


class GeneralEquipmentArgsFromSpellRecursive1(TypedDict, total=False):
    """Arguments for Spell"""
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive2'


class GeneralEquipmentArgsFromSpellRecursive2(TypedDict, total=False):
    """Arguments for Spell"""
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive3'


class GeneralEquipmentArgsFromSpellRecursive3(TypedDict, total=False):
    """Arguments for Spell"""
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive4'


class GeneralEquipmentArgsFromSpellRecursive4(TypedDict, total=False):
    """Arguments for Spell"""
    
    

class FindManyGeneralEquipmentArgsFromSpell(TypedDict, total=False):
    """Arguments for Spell"""
    take: int
    skip: int
    order_by: Union['GeneralEquipmentOrderByInput', List['GeneralEquipmentOrderByInput']]
    where: 'GeneralEquipmentWhereInput'
    cursor: 'GeneralEquipmentWhereUniqueInput'
    distinct: List['GeneralEquipmentScalarFieldKeys']
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive1'


class FindManyGeneralEquipmentArgsFromSpellRecursive1(TypedDict, total=False):
    """Arguments for Spell"""
    take: int
    skip: int
    order_by: Union['GeneralEquipmentOrderByInput', List['GeneralEquipmentOrderByInput']]
    where: 'GeneralEquipmentWhereInput'
    cursor: 'GeneralEquipmentWhereUniqueInput'
    distinct: List['GeneralEquipmentScalarFieldKeys']
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive2'


class FindManyGeneralEquipmentArgsFromSpellRecursive2(TypedDict, total=False):
    """Arguments for Spell"""
    take: int
    skip: int
    order_by: Union['GeneralEquipmentOrderByInput', List['GeneralEquipmentOrderByInput']]
    where: 'GeneralEquipmentWhereInput'
    cursor: 'GeneralEquipmentWhereUniqueInput'
    distinct: List['GeneralEquipmentScalarFieldKeys']
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive3'


class FindManyGeneralEquipmentArgsFromSpellRecursive3(TypedDict, total=False):
    """Arguments for Spell"""
    take: int
    skip: int
    order_by: Union['GeneralEquipmentOrderByInput', List['GeneralEquipmentOrderByInput']]
    where: 'GeneralEquipmentWhereInput'
    cursor: 'GeneralEquipmentWhereUniqueInput'
    distinct: List['GeneralEquipmentScalarFieldKeys']
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive4'


class FindManyGeneralEquipmentArgsFromSpellRecursive4(TypedDict, total=False):
    """Arguments for Spell"""
    take: int
    skip: int
    order_by: Union['GeneralEquipmentOrderByInput', List['GeneralEquipmentOrderByInput']]
    where: 'GeneralEquipmentWhereInput'
    cursor: 'GeneralEquipmentWhereUniqueInput'
    distinct: List['GeneralEquipmentScalarFieldKeys']
    


FindManySpellArgs = FindManySpellArgsFromSpell
FindFirstSpellArgs = FindManySpellArgsFromSpell


    

class SpellWhereInput(TypedDict, total=False):
    """Spell arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    level: Union[_str, 'types.StringFilter']
    school: Union[_str, 'types.StringFilter']
    castingTime: Union[_str, 'types.StringFilter']
    duration: Union[_str, 'types.StringFilter']
    range: Union[_str, 'types.StringFilter']
    area: Union[None, _str, 'types.StringFilter']
    attack: Union[None, _str, 'types.StringFilter']
    save: Union[None, _str, 'types.StringFilter']
    damageEffect: Union[_str, 'types.StringFilter']
    ritual: Union[None, _str, 'types.StringFilter']
    concentration: Union[None, _str, 'types.StringFilter']
    verbal: Union[None, _str, 'types.StringFilter']
    somatic: Union[None, _str, 'types.StringFilter']
    material: Union[None, _str, 'types.StringFilter']
    materialDetails: Union[None, _str, 'types.StringFilter']
    source: Union[_str, 'types.StringFilter']
    details: Union[_str, 'types.StringFilter']
    link: Union[_str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['SpellWhereInputRecursive1', List['SpellWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['SpellWhereInputRecursive1']
    OR: List['SpellWhereInputRecursive1']
    NOT: List['SpellWhereInputRecursive1']


class SpellWhereInputRecursive1(TypedDict, total=False):
    """Spell arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    level: Union[_str, 'types.StringFilter']
    school: Union[_str, 'types.StringFilter']
    castingTime: Union[_str, 'types.StringFilter']
    duration: Union[_str, 'types.StringFilter']
    range: Union[_str, 'types.StringFilter']
    area: Union[None, _str, 'types.StringFilter']
    attack: Union[None, _str, 'types.StringFilter']
    save: Union[None, _str, 'types.StringFilter']
    damageEffect: Union[_str, 'types.StringFilter']
    ritual: Union[None, _str, 'types.StringFilter']
    concentration: Union[None, _str, 'types.StringFilter']
    verbal: Union[None, _str, 'types.StringFilter']
    somatic: Union[None, _str, 'types.StringFilter']
    material: Union[None, _str, 'types.StringFilter']
    materialDetails: Union[None, _str, 'types.StringFilter']
    source: Union[_str, 'types.StringFilter']
    details: Union[_str, 'types.StringFilter']
    link: Union[_str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['SpellWhereInputRecursive2', List['SpellWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['SpellWhereInputRecursive2']
    OR: List['SpellWhereInputRecursive2']
    NOT: List['SpellWhereInputRecursive2']


class SpellWhereInputRecursive2(TypedDict, total=False):
    """Spell arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    level: Union[_str, 'types.StringFilter']
    school: Union[_str, 'types.StringFilter']
    castingTime: Union[_str, 'types.StringFilter']
    duration: Union[_str, 'types.StringFilter']
    range: Union[_str, 'types.StringFilter']
    area: Union[None, _str, 'types.StringFilter']
    attack: Union[None, _str, 'types.StringFilter']
    save: Union[None, _str, 'types.StringFilter']
    damageEffect: Union[_str, 'types.StringFilter']
    ritual: Union[None, _str, 'types.StringFilter']
    concentration: Union[None, _str, 'types.StringFilter']
    verbal: Union[None, _str, 'types.StringFilter']
    somatic: Union[None, _str, 'types.StringFilter']
    material: Union[None, _str, 'types.StringFilter']
    materialDetails: Union[None, _str, 'types.StringFilter']
    source: Union[_str, 'types.StringFilter']
    details: Union[_str, 'types.StringFilter']
    link: Union[_str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['SpellWhereInputRecursive3', List['SpellWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['SpellWhereInputRecursive3']
    OR: List['SpellWhereInputRecursive3']
    NOT: List['SpellWhereInputRecursive3']


class SpellWhereInputRecursive3(TypedDict, total=False):
    """Spell arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    level: Union[_str, 'types.StringFilter']
    school: Union[_str, 'types.StringFilter']
    castingTime: Union[_str, 'types.StringFilter']
    duration: Union[_str, 'types.StringFilter']
    range: Union[_str, 'types.StringFilter']
    area: Union[None, _str, 'types.StringFilter']
    attack: Union[None, _str, 'types.StringFilter']
    save: Union[None, _str, 'types.StringFilter']
    damageEffect: Union[_str, 'types.StringFilter']
    ritual: Union[None, _str, 'types.StringFilter']
    concentration: Union[None, _str, 'types.StringFilter']
    verbal: Union[None, _str, 'types.StringFilter']
    somatic: Union[None, _str, 'types.StringFilter']
    material: Union[None, _str, 'types.StringFilter']
    materialDetails: Union[None, _str, 'types.StringFilter']
    source: Union[_str, 'types.StringFilter']
    details: Union[_str, 'types.StringFilter']
    link: Union[_str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['SpellWhereInputRecursive4', List['SpellWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['SpellWhereInputRecursive4']
    OR: List['SpellWhereInputRecursive4']
    NOT: List['SpellWhereInputRecursive4']


class SpellWhereInputRecursive4(TypedDict, total=False):
    """Spell arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    level: Union[_str, 'types.StringFilter']
    school: Union[_str, 'types.StringFilter']
    castingTime: Union[_str, 'types.StringFilter']
    duration: Union[_str, 'types.StringFilter']
    range: Union[_str, 'types.StringFilter']
    area: Union[None, _str, 'types.StringFilter']
    attack: Union[None, _str, 'types.StringFilter']
    save: Union[None, _str, 'types.StringFilter']
    damageEffect: Union[_str, 'types.StringFilter']
    ritual: Union[None, _str, 'types.StringFilter']
    concentration: Union[None, _str, 'types.StringFilter']
    verbal: Union[None, _str, 'types.StringFilter']
    somatic: Union[None, _str, 'types.StringFilter']
    material: Union[None, _str, 'types.StringFilter']
    materialDetails: Union[None, _str, 'types.StringFilter']
    source: Union[_str, 'types.StringFilter']
    details: Union[_str, 'types.StringFilter']
    link: Union[_str, 'types.StringFilter']



# aggregate Spell types


    

class SpellScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Spell arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    level: Union[_str, 'types.StringWithAggregatesFilter']
    school: Union[_str, 'types.StringWithAggregatesFilter']
    castingTime: Union[_str, 'types.StringWithAggregatesFilter']
    duration: Union[_str, 'types.StringWithAggregatesFilter']
    range: Union[_str, 'types.StringWithAggregatesFilter']
    area: Union[_str, 'types.StringWithAggregatesFilter']
    attack: Union[_str, 'types.StringWithAggregatesFilter']
    save: Union[_str, 'types.StringWithAggregatesFilter']
    damageEffect: Union[_str, 'types.StringWithAggregatesFilter']
    ritual: Union[_str, 'types.StringWithAggregatesFilter']
    concentration: Union[_str, 'types.StringWithAggregatesFilter']
    verbal: Union[_str, 'types.StringWithAggregatesFilter']
    somatic: Union[_str, 'types.StringWithAggregatesFilter']
    material: Union[_str, 'types.StringWithAggregatesFilter']
    materialDetails: Union[_str, 'types.StringWithAggregatesFilter']
    source: Union[_str, 'types.StringWithAggregatesFilter']
    details: Union[_str, 'types.StringWithAggregatesFilter']
    link: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['SpellScalarWhereWithAggregatesInputRecursive1']
    OR: List['SpellScalarWhereWithAggregatesInputRecursive1']
    NOT: List['SpellScalarWhereWithAggregatesInputRecursive1']


class SpellScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Spell arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    level: Union[_str, 'types.StringWithAggregatesFilter']
    school: Union[_str, 'types.StringWithAggregatesFilter']
    castingTime: Union[_str, 'types.StringWithAggregatesFilter']
    duration: Union[_str, 'types.StringWithAggregatesFilter']
    range: Union[_str, 'types.StringWithAggregatesFilter']
    area: Union[_str, 'types.StringWithAggregatesFilter']
    attack: Union[_str, 'types.StringWithAggregatesFilter']
    save: Union[_str, 'types.StringWithAggregatesFilter']
    damageEffect: Union[_str, 'types.StringWithAggregatesFilter']
    ritual: Union[_str, 'types.StringWithAggregatesFilter']
    concentration: Union[_str, 'types.StringWithAggregatesFilter']
    verbal: Union[_str, 'types.StringWithAggregatesFilter']
    somatic: Union[_str, 'types.StringWithAggregatesFilter']
    material: Union[_str, 'types.StringWithAggregatesFilter']
    materialDetails: Union[_str, 'types.StringWithAggregatesFilter']
    source: Union[_str, 'types.StringWithAggregatesFilter']
    details: Union[_str, 'types.StringWithAggregatesFilter']
    link: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['SpellScalarWhereWithAggregatesInputRecursive2']
    OR: List['SpellScalarWhereWithAggregatesInputRecursive2']
    NOT: List['SpellScalarWhereWithAggregatesInputRecursive2']


class SpellScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Spell arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    level: Union[_str, 'types.StringWithAggregatesFilter']
    school: Union[_str, 'types.StringWithAggregatesFilter']
    castingTime: Union[_str, 'types.StringWithAggregatesFilter']
    duration: Union[_str, 'types.StringWithAggregatesFilter']
    range: Union[_str, 'types.StringWithAggregatesFilter']
    area: Union[_str, 'types.StringWithAggregatesFilter']
    attack: Union[_str, 'types.StringWithAggregatesFilter']
    save: Union[_str, 'types.StringWithAggregatesFilter']
    damageEffect: Union[_str, 'types.StringWithAggregatesFilter']
    ritual: Union[_str, 'types.StringWithAggregatesFilter']
    concentration: Union[_str, 'types.StringWithAggregatesFilter']
    verbal: Union[_str, 'types.StringWithAggregatesFilter']
    somatic: Union[_str, 'types.StringWithAggregatesFilter']
    material: Union[_str, 'types.StringWithAggregatesFilter']
    materialDetails: Union[_str, 'types.StringWithAggregatesFilter']
    source: Union[_str, 'types.StringWithAggregatesFilter']
    details: Union[_str, 'types.StringWithAggregatesFilter']
    link: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['SpellScalarWhereWithAggregatesInputRecursive3']
    OR: List['SpellScalarWhereWithAggregatesInputRecursive3']
    NOT: List['SpellScalarWhereWithAggregatesInputRecursive3']


class SpellScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Spell arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    level: Union[_str, 'types.StringWithAggregatesFilter']
    school: Union[_str, 'types.StringWithAggregatesFilter']
    castingTime: Union[_str, 'types.StringWithAggregatesFilter']
    duration: Union[_str, 'types.StringWithAggregatesFilter']
    range: Union[_str, 'types.StringWithAggregatesFilter']
    area: Union[_str, 'types.StringWithAggregatesFilter']
    attack: Union[_str, 'types.StringWithAggregatesFilter']
    save: Union[_str, 'types.StringWithAggregatesFilter']
    damageEffect: Union[_str, 'types.StringWithAggregatesFilter']
    ritual: Union[_str, 'types.StringWithAggregatesFilter']
    concentration: Union[_str, 'types.StringWithAggregatesFilter']
    verbal: Union[_str, 'types.StringWithAggregatesFilter']
    somatic: Union[_str, 'types.StringWithAggregatesFilter']
    material: Union[_str, 'types.StringWithAggregatesFilter']
    materialDetails: Union[_str, 'types.StringWithAggregatesFilter']
    source: Union[_str, 'types.StringWithAggregatesFilter']
    details: Union[_str, 'types.StringWithAggregatesFilter']
    link: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['SpellScalarWhereWithAggregatesInputRecursive4']
    OR: List['SpellScalarWhereWithAggregatesInputRecursive4']
    NOT: List['SpellScalarWhereWithAggregatesInputRecursive4']


class SpellScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Spell arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    level: Union[_str, 'types.StringWithAggregatesFilter']
    school: Union[_str, 'types.StringWithAggregatesFilter']
    castingTime: Union[_str, 'types.StringWithAggregatesFilter']
    duration: Union[_str, 'types.StringWithAggregatesFilter']
    range: Union[_str, 'types.StringWithAggregatesFilter']
    area: Union[_str, 'types.StringWithAggregatesFilter']
    attack: Union[_str, 'types.StringWithAggregatesFilter']
    save: Union[_str, 'types.StringWithAggregatesFilter']
    damageEffect: Union[_str, 'types.StringWithAggregatesFilter']
    ritual: Union[_str, 'types.StringWithAggregatesFilter']
    concentration: Union[_str, 'types.StringWithAggregatesFilter']
    verbal: Union[_str, 'types.StringWithAggregatesFilter']
    somatic: Union[_str, 'types.StringWithAggregatesFilter']
    material: Union[_str, 'types.StringWithAggregatesFilter']
    materialDetails: Union[_str, 'types.StringWithAggregatesFilter']
    source: Union[_str, 'types.StringWithAggregatesFilter']
    details: Union[_str, 'types.StringWithAggregatesFilter']
    link: Union[_str, 'types.StringWithAggregatesFilter']



class SpellGroupByOutput(TypedDict, total=False):
    id: _int
    name: _str
    level: _str
    school: _str
    castingTime: _str
    duration: _str
    range: _str
    area: _str
    attack: _str
    save: _str
    damageEffect: _str
    ritual: _str
    concentration: _str
    verbal: _str
    somatic: _str
    material: _str
    materialDetails: _str
    source: _str
    details: _str
    link: _str
    _sum: 'SpellSumAggregateOutput'
    _avg: 'SpellAvgAggregateOutput'
    _min: 'SpellMinAggregateOutput'
    _max: 'SpellMaxAggregateOutput'
    _count: 'SpellCountAggregateOutput'


class SpellAvgAggregateOutput(TypedDict, total=False):
    """Spell output for aggregating averages"""
    id: float


class SpellSumAggregateOutput(TypedDict, total=False):
    """Spell output for aggregating sums"""
    id: _int


class SpellScalarAggregateOutput(TypedDict, total=False):
    """Spell output including scalar fields"""
    id: _int
    name: _str
    level: _str
    school: _str
    castingTime: _str
    duration: _str
    range: _str
    area: _str
    attack: _str
    save: _str
    damageEffect: _str
    ritual: _str
    concentration: _str
    verbal: _str
    somatic: _str
    material: _str
    materialDetails: _str
    source: _str
    details: _str
    link: _str


SpellMinAggregateOutput = SpellScalarAggregateOutput
SpellMaxAggregateOutput = SpellScalarAggregateOutput


class SpellMaxAggregateInput(TypedDict, total=False):
    """Spell input for aggregating by max"""
    id: bool
    name: bool
    level: bool
    school: bool
    castingTime: bool
    duration: bool
    range: bool
    area: bool
    attack: bool
    save: bool
    damageEffect: bool
    ritual: bool
    concentration: bool
    verbal: bool
    somatic: bool
    material: bool
    materialDetails: bool
    source: bool
    details: bool
    link: bool


class SpellMinAggregateInput(TypedDict, total=False):
    """Spell input for aggregating by min"""
    id: bool
    name: bool
    level: bool
    school: bool
    castingTime: bool
    duration: bool
    range: bool
    area: bool
    attack: bool
    save: bool
    damageEffect: bool
    ritual: bool
    concentration: bool
    verbal: bool
    somatic: bool
    material: bool
    materialDetails: bool
    source: bool
    details: bool
    link: bool


class SpellNumberAggregateInput(TypedDict, total=False):
    """Spell input for aggregating numbers"""
    id: bool


SpellAvgAggregateInput = SpellNumberAggregateInput
SpellSumAggregateInput = SpellNumberAggregateInput


SpellCountAggregateInput = TypedDict(
    'SpellCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'level': bool,
        'school': bool,
        'castingTime': bool,
        'duration': bool,
        'range': bool,
        'area': bool,
        'attack': bool,
        'save': bool,
        'damageEffect': bool,
        'ritual': bool,
        'concentration': bool,
        'verbal': bool,
        'somatic': bool,
        'material': bool,
        'materialDetails': bool,
        'source': bool,
        'details': bool,
        'link': bool,
        '_all': bool,
    },
    total=False,
)

SpellCountAggregateOutput = TypedDict(
    'SpellCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'level': int,
        'school': int,
        'castingTime': int,
        'duration': int,
        'range': int,
        'area': int,
        'attack': int,
        'save': int,
        'damageEffect': int,
        'ritual': int,
        'concentration': int,
        'verbal': int,
        'somatic': int,
        'material': int,
        'materialDetails': int,
        'source': int,
        'details': int,
        'link': int,
        '_all': int,
    },
    total=False,
)


SpellKeys = Literal[
    'id',
    'name',
    'level',
    'school',
    'castingTime',
    'duration',
    'range',
    'area',
    'attack',
    'save',
    'damageEffect',
    'ritual',
    'concentration',
    'verbal',
    'somatic',
    'material',
    'materialDetails',
    'source',
    'details',
    'link',
]
SpellScalarFieldKeys = Literal[
    'id',
    'name',
    'level',
    'school',
    'castingTime',
    'duration',
    'range',
    'area',
    'attack',
    'save',
    'damageEffect',
    'ritual',
    'concentration',
    'verbal',
    'somatic',
    'material',
    'materialDetails',
    'source',
    'details',
    'link',
]
SpellScalarFieldKeysT = TypeVar('SpellScalarFieldKeysT', bound=SpellScalarFieldKeys)

SpellRelationalFieldKeys = _NoneType

# PlayerClass types

class PlayerClassOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the PlayerClass create method"""
    id: _int
    source: Optional[_str]
    notes: Optional[_str]
    features: Optional[_str]
    level: Optional[_str]
    description: Optional[_str]


class PlayerClassCreateInput(PlayerClassOptionalCreateInput):
    """Required arguments to the PlayerClass create method"""
    Playerclass: _str
    subclass: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class PlayerClassOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the PlayerClass create method, without relations"""
    id: _int
    source: Optional[_str]
    notes: Optional[_str]
    features: Optional[_str]
    level: Optional[_str]
    description: Optional[_str]


class PlayerClassCreateWithoutRelationsInput(PlayerClassOptionalCreateWithoutRelationsInput):
    """Required arguments to the PlayerClass create method, without relations"""
    Playerclass: _str
    subclass: _str

class PlayerClassConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'PlayerClassCreateWithoutRelationsInput'
    where: 'PlayerClassWhereUniqueInput'

class PlayerClassCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'PlayerClassCreateWithoutRelationsInput'
    connect: 'PlayerClassWhereUniqueInput'
    connect_or_create: 'PlayerClassConnectOrCreateWithoutRelationsInput'


class PlayerClassCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['PlayerClassCreateWithoutRelationsInput', List['PlayerClassCreateWithoutRelationsInput']]
    connect: Union['PlayerClassWhereUniqueInput', List['PlayerClassWhereUniqueInput']]
    connect_or_create: Union['PlayerClassConnectOrCreateWithoutRelationsInput', List['PlayerClassConnectOrCreateWithoutRelationsInput']]

_PlayerClassWhereUnique_id_Input = TypedDict(
    '_PlayerClassWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

PlayerClassWhereUniqueInput = _PlayerClassWhereUnique_id_Input


class PlayerClassUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    Playerclass: _str
    subclass: _str
    source: Optional[_str]
    notes: Optional[_str]
    features: Optional[_str]
    level: Optional[_str]
    description: Optional[_str]


class PlayerClassUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    Playerclass: _str
    subclass: _str
    source: Optional[_str]
    notes: Optional[_str]
    features: Optional[_str]
    level: Optional[_str]
    description: Optional[_str]


class PlayerClassUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['PlayerClassCreateWithoutRelationsInput']
    connect: List['PlayerClassWhereUniqueInput']
    connect_or_create: List['PlayerClassConnectOrCreateWithoutRelationsInput']
    set: List['PlayerClassWhereUniqueInput']
    disconnect: List['PlayerClassWhereUniqueInput']
    delete: List['PlayerClassWhereUniqueInput']

    # TODO
    # update: List['PlayerClassUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['PlayerClassUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['PlayerClassScalarWhereInput']
    # upsert: List['PlayerClassUpserteWithWhereUniqueWithoutRelationsInput']


class PlayerClassUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'PlayerClassCreateWithoutRelationsInput'
    connect: 'PlayerClassWhereUniqueInput'
    connect_or_create: 'PlayerClassConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'PlayerClassUpdateInput'
    # upsert: 'PlayerClassUpsertWithoutRelationsInput'


class PlayerClassUpsertInput(TypedDict):
    create: 'PlayerClassCreateInput'
    update: 'PlayerClassUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_PlayerClass_id_OrderByInput = TypedDict(
    '_PlayerClass_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_PlayerClass_Playerclass_OrderByInput = TypedDict(
    '_PlayerClass_Playerclass_OrderByInput',
    {
        'Playerclass': 'SortOrder',
    },
    total=True
)

_PlayerClass_subclass_OrderByInput = TypedDict(
    '_PlayerClass_subclass_OrderByInput',
    {
        'subclass': 'SortOrder',
    },
    total=True
)

_PlayerClass_source_OrderByInput = TypedDict(
    '_PlayerClass_source_OrderByInput',
    {
        'source': 'SortOrder',
    },
    total=True
)

_PlayerClass_notes_OrderByInput = TypedDict(
    '_PlayerClass_notes_OrderByInput',
    {
        'notes': 'SortOrder',
    },
    total=True
)

_PlayerClass_features_OrderByInput = TypedDict(
    '_PlayerClass_features_OrderByInput',
    {
        'features': 'SortOrder',
    },
    total=True
)

_PlayerClass_level_OrderByInput = TypedDict(
    '_PlayerClass_level_OrderByInput',
    {
        'level': 'SortOrder',
    },
    total=True
)

_PlayerClass_description_OrderByInput = TypedDict(
    '_PlayerClass_description_OrderByInput',
    {
        'description': 'SortOrder',
    },
    total=True
)

_PlayerClass_RelevanceInner = TypedDict(
    '_PlayerClass_RelevanceInner',
    {
        'fields': 'List[PlayerClassScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_PlayerClass_RelevanceOrderByInput = TypedDict(
    '_PlayerClass_RelevanceOrderByInput',
    {
        '_relevance': '_PlayerClass_RelevanceInner',
    },
    total=True
)

PlayerClassOrderByInput = Union[
    '_PlayerClass_id_OrderByInput',
    '_PlayerClass_Playerclass_OrderByInput',
    '_PlayerClass_subclass_OrderByInput',
    '_PlayerClass_source_OrderByInput',
    '_PlayerClass_notes_OrderByInput',
    '_PlayerClass_features_OrderByInput',
    '_PlayerClass_level_OrderByInput',
    '_PlayerClass_description_OrderByInput',
    '_PlayerClass_RelevanceOrderByInput',
]



# recursive PlayerClass types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

PlayerClassRelationFilter = TypedDict(
    'PlayerClassRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class PlayerClassListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class PlayerClassInclude(TypedDict, total=False):
    """PlayerClass relational arguments"""


    

class MonsterIncludeFromPlayerClass(TypedDict, total=False):
    """Relational arguments for PlayerClass"""


class MonsterIncludeFromPlayerClassRecursive1(TypedDict, total=False):
    """Relational arguments for PlayerClass"""


class MonsterIncludeFromPlayerClassRecursive2(TypedDict, total=False):
    """Relational arguments for PlayerClass"""


class MonsterIncludeFromPlayerClassRecursive3(TypedDict, total=False):
    """Relational arguments for PlayerClass"""


class MonsterIncludeFromPlayerClassRecursive4(TypedDict, total=False):
    """Relational arguments for PlayerClass"""

    

class MonsterArgsFromPlayerClass(TypedDict, total=False):
    """Arguments for PlayerClass"""
    include: 'MonsterIncludeFromMonsterRecursive1'


class MonsterArgsFromPlayerClassRecursive1(TypedDict, total=False):
    """Arguments for PlayerClass"""
    include: 'MonsterIncludeFromMonsterRecursive2'


class MonsterArgsFromPlayerClassRecursive2(TypedDict, total=False):
    """Arguments for PlayerClass"""
    include: 'MonsterIncludeFromMonsterRecursive3'


class MonsterArgsFromPlayerClassRecursive3(TypedDict, total=False):
    """Arguments for PlayerClass"""
    include: 'MonsterIncludeFromMonsterRecursive4'


class MonsterArgsFromPlayerClassRecursive4(TypedDict, total=False):
    """Arguments for PlayerClass"""
    
    

class FindManyMonsterArgsFromPlayerClass(TypedDict, total=False):
    """Arguments for PlayerClass"""
    take: int
    skip: int
    order_by: Union['MonsterOrderByInput', List['MonsterOrderByInput']]
    where: 'MonsterWhereInput'
    cursor: 'MonsterWhereUniqueInput'
    distinct: List['MonsterScalarFieldKeys']
    include: 'MonsterIncludeFromMonsterRecursive1'


class FindManyMonsterArgsFromPlayerClassRecursive1(TypedDict, total=False):
    """Arguments for PlayerClass"""
    take: int
    skip: int
    order_by: Union['MonsterOrderByInput', List['MonsterOrderByInput']]
    where: 'MonsterWhereInput'
    cursor: 'MonsterWhereUniqueInput'
    distinct: List['MonsterScalarFieldKeys']
    include: 'MonsterIncludeFromMonsterRecursive2'


class FindManyMonsterArgsFromPlayerClassRecursive2(TypedDict, total=False):
    """Arguments for PlayerClass"""
    take: int
    skip: int
    order_by: Union['MonsterOrderByInput', List['MonsterOrderByInput']]
    where: 'MonsterWhereInput'
    cursor: 'MonsterWhereUniqueInput'
    distinct: List['MonsterScalarFieldKeys']
    include: 'MonsterIncludeFromMonsterRecursive3'


class FindManyMonsterArgsFromPlayerClassRecursive3(TypedDict, total=False):
    """Arguments for PlayerClass"""
    take: int
    skip: int
    order_by: Union['MonsterOrderByInput', List['MonsterOrderByInput']]
    where: 'MonsterWhereInput'
    cursor: 'MonsterWhereUniqueInput'
    distinct: List['MonsterScalarFieldKeys']
    include: 'MonsterIncludeFromMonsterRecursive4'


class FindManyMonsterArgsFromPlayerClassRecursive4(TypedDict, total=False):
    """Arguments for PlayerClass"""
    take: int
    skip: int
    order_by: Union['MonsterOrderByInput', List['MonsterOrderByInput']]
    where: 'MonsterWhereInput'
    cursor: 'MonsterWhereUniqueInput'
    distinct: List['MonsterScalarFieldKeys']
    
    

class RaceIncludeFromPlayerClass(TypedDict, total=False):
    """Relational arguments for PlayerClass"""


class RaceIncludeFromPlayerClassRecursive1(TypedDict, total=False):
    """Relational arguments for PlayerClass"""


class RaceIncludeFromPlayerClassRecursive2(TypedDict, total=False):
    """Relational arguments for PlayerClass"""


class RaceIncludeFromPlayerClassRecursive3(TypedDict, total=False):
    """Relational arguments for PlayerClass"""


class RaceIncludeFromPlayerClassRecursive4(TypedDict, total=False):
    """Relational arguments for PlayerClass"""

    

class RaceArgsFromPlayerClass(TypedDict, total=False):
    """Arguments for PlayerClass"""
    include: 'RaceIncludeFromRaceRecursive1'


class RaceArgsFromPlayerClassRecursive1(TypedDict, total=False):
    """Arguments for PlayerClass"""
    include: 'RaceIncludeFromRaceRecursive2'


class RaceArgsFromPlayerClassRecursive2(TypedDict, total=False):
    """Arguments for PlayerClass"""
    include: 'RaceIncludeFromRaceRecursive3'


class RaceArgsFromPlayerClassRecursive3(TypedDict, total=False):
    """Arguments for PlayerClass"""
    include: 'RaceIncludeFromRaceRecursive4'


class RaceArgsFromPlayerClassRecursive4(TypedDict, total=False):
    """Arguments for PlayerClass"""
    
    

class FindManyRaceArgsFromPlayerClass(TypedDict, total=False):
    """Arguments for PlayerClass"""
    take: int
    skip: int
    order_by: Union['RaceOrderByInput', List['RaceOrderByInput']]
    where: 'RaceWhereInput'
    cursor: 'RaceWhereUniqueInput'
    distinct: List['RaceScalarFieldKeys']
    include: 'RaceIncludeFromRaceRecursive1'


class FindManyRaceArgsFromPlayerClassRecursive1(TypedDict, total=False):
    """Arguments for PlayerClass"""
    take: int
    skip: int
    order_by: Union['RaceOrderByInput', List['RaceOrderByInput']]
    where: 'RaceWhereInput'
    cursor: 'RaceWhereUniqueInput'
    distinct: List['RaceScalarFieldKeys']
    include: 'RaceIncludeFromRaceRecursive2'


class FindManyRaceArgsFromPlayerClassRecursive2(TypedDict, total=False):
    """Arguments for PlayerClass"""
    take: int
    skip: int
    order_by: Union['RaceOrderByInput', List['RaceOrderByInput']]
    where: 'RaceWhereInput'
    cursor: 'RaceWhereUniqueInput'
    distinct: List['RaceScalarFieldKeys']
    include: 'RaceIncludeFromRaceRecursive3'


class FindManyRaceArgsFromPlayerClassRecursive3(TypedDict, total=False):
    """Arguments for PlayerClass"""
    take: int
    skip: int
    order_by: Union['RaceOrderByInput', List['RaceOrderByInput']]
    where: 'RaceWhereInput'
    cursor: 'RaceWhereUniqueInput'
    distinct: List['RaceScalarFieldKeys']
    include: 'RaceIncludeFromRaceRecursive4'


class FindManyRaceArgsFromPlayerClassRecursive4(TypedDict, total=False):
    """Arguments for PlayerClass"""
    take: int
    skip: int
    order_by: Union['RaceOrderByInput', List['RaceOrderByInput']]
    where: 'RaceWhereInput'
    cursor: 'RaceWhereUniqueInput'
    distinct: List['RaceScalarFieldKeys']
    
    

class SpellIncludeFromPlayerClass(TypedDict, total=False):
    """Relational arguments for PlayerClass"""


class SpellIncludeFromPlayerClassRecursive1(TypedDict, total=False):
    """Relational arguments for PlayerClass"""


class SpellIncludeFromPlayerClassRecursive2(TypedDict, total=False):
    """Relational arguments for PlayerClass"""


class SpellIncludeFromPlayerClassRecursive3(TypedDict, total=False):
    """Relational arguments for PlayerClass"""


class SpellIncludeFromPlayerClassRecursive4(TypedDict, total=False):
    """Relational arguments for PlayerClass"""

    

class SpellArgsFromPlayerClass(TypedDict, total=False):
    """Arguments for PlayerClass"""
    include: 'SpellIncludeFromSpellRecursive1'


class SpellArgsFromPlayerClassRecursive1(TypedDict, total=False):
    """Arguments for PlayerClass"""
    include: 'SpellIncludeFromSpellRecursive2'


class SpellArgsFromPlayerClassRecursive2(TypedDict, total=False):
    """Arguments for PlayerClass"""
    include: 'SpellIncludeFromSpellRecursive3'


class SpellArgsFromPlayerClassRecursive3(TypedDict, total=False):
    """Arguments for PlayerClass"""
    include: 'SpellIncludeFromSpellRecursive4'


class SpellArgsFromPlayerClassRecursive4(TypedDict, total=False):
    """Arguments for PlayerClass"""
    
    

class FindManySpellArgsFromPlayerClass(TypedDict, total=False):
    """Arguments for PlayerClass"""
    take: int
    skip: int
    order_by: Union['SpellOrderByInput', List['SpellOrderByInput']]
    where: 'SpellWhereInput'
    cursor: 'SpellWhereUniqueInput'
    distinct: List['SpellScalarFieldKeys']
    include: 'SpellIncludeFromSpellRecursive1'


class FindManySpellArgsFromPlayerClassRecursive1(TypedDict, total=False):
    """Arguments for PlayerClass"""
    take: int
    skip: int
    order_by: Union['SpellOrderByInput', List['SpellOrderByInput']]
    where: 'SpellWhereInput'
    cursor: 'SpellWhereUniqueInput'
    distinct: List['SpellScalarFieldKeys']
    include: 'SpellIncludeFromSpellRecursive2'


class FindManySpellArgsFromPlayerClassRecursive2(TypedDict, total=False):
    """Arguments for PlayerClass"""
    take: int
    skip: int
    order_by: Union['SpellOrderByInput', List['SpellOrderByInput']]
    where: 'SpellWhereInput'
    cursor: 'SpellWhereUniqueInput'
    distinct: List['SpellScalarFieldKeys']
    include: 'SpellIncludeFromSpellRecursive3'


class FindManySpellArgsFromPlayerClassRecursive3(TypedDict, total=False):
    """Arguments for PlayerClass"""
    take: int
    skip: int
    order_by: Union['SpellOrderByInput', List['SpellOrderByInput']]
    where: 'SpellWhereInput'
    cursor: 'SpellWhereUniqueInput'
    distinct: List['SpellScalarFieldKeys']
    include: 'SpellIncludeFromSpellRecursive4'


class FindManySpellArgsFromPlayerClassRecursive4(TypedDict, total=False):
    """Arguments for PlayerClass"""
    take: int
    skip: int
    order_by: Union['SpellOrderByInput', List['SpellOrderByInput']]
    where: 'SpellWhereInput'
    cursor: 'SpellWhereUniqueInput'
    distinct: List['SpellScalarFieldKeys']
    
    

class PlayerClassIncludeFromPlayerClass(TypedDict, total=False):
    """Relational arguments for PlayerClass"""


class PlayerClassIncludeFromPlayerClassRecursive1(TypedDict, total=False):
    """Relational arguments for PlayerClass"""


class PlayerClassIncludeFromPlayerClassRecursive2(TypedDict, total=False):
    """Relational arguments for PlayerClass"""


class PlayerClassIncludeFromPlayerClassRecursive3(TypedDict, total=False):
    """Relational arguments for PlayerClass"""


class PlayerClassIncludeFromPlayerClassRecursive4(TypedDict, total=False):
    """Relational arguments for PlayerClass"""

    

class PlayerClassArgsFromPlayerClass(TypedDict, total=False):
    """Arguments for PlayerClass"""
    include: 'PlayerClassIncludeFromPlayerClassRecursive1'


class PlayerClassArgsFromPlayerClassRecursive1(TypedDict, total=False):
    """Arguments for PlayerClass"""
    include: 'PlayerClassIncludeFromPlayerClassRecursive2'


class PlayerClassArgsFromPlayerClassRecursive2(TypedDict, total=False):
    """Arguments for PlayerClass"""
    include: 'PlayerClassIncludeFromPlayerClassRecursive3'


class PlayerClassArgsFromPlayerClassRecursive3(TypedDict, total=False):
    """Arguments for PlayerClass"""
    include: 'PlayerClassIncludeFromPlayerClassRecursive4'


class PlayerClassArgsFromPlayerClassRecursive4(TypedDict, total=False):
    """Arguments for PlayerClass"""
    
    

class FindManyPlayerClassArgsFromPlayerClass(TypedDict, total=False):
    """Arguments for PlayerClass"""
    take: int
    skip: int
    order_by: Union['PlayerClassOrderByInput', List['PlayerClassOrderByInput']]
    where: 'PlayerClassWhereInput'
    cursor: 'PlayerClassWhereUniqueInput'
    distinct: List['PlayerClassScalarFieldKeys']
    include: 'PlayerClassIncludeFromPlayerClassRecursive1'


class FindManyPlayerClassArgsFromPlayerClassRecursive1(TypedDict, total=False):
    """Arguments for PlayerClass"""
    take: int
    skip: int
    order_by: Union['PlayerClassOrderByInput', List['PlayerClassOrderByInput']]
    where: 'PlayerClassWhereInput'
    cursor: 'PlayerClassWhereUniqueInput'
    distinct: List['PlayerClassScalarFieldKeys']
    include: 'PlayerClassIncludeFromPlayerClassRecursive2'


class FindManyPlayerClassArgsFromPlayerClassRecursive2(TypedDict, total=False):
    """Arguments for PlayerClass"""
    take: int
    skip: int
    order_by: Union['PlayerClassOrderByInput', List['PlayerClassOrderByInput']]
    where: 'PlayerClassWhereInput'
    cursor: 'PlayerClassWhereUniqueInput'
    distinct: List['PlayerClassScalarFieldKeys']
    include: 'PlayerClassIncludeFromPlayerClassRecursive3'


class FindManyPlayerClassArgsFromPlayerClassRecursive3(TypedDict, total=False):
    """Arguments for PlayerClass"""
    take: int
    skip: int
    order_by: Union['PlayerClassOrderByInput', List['PlayerClassOrderByInput']]
    where: 'PlayerClassWhereInput'
    cursor: 'PlayerClassWhereUniqueInput'
    distinct: List['PlayerClassScalarFieldKeys']
    include: 'PlayerClassIncludeFromPlayerClassRecursive4'


class FindManyPlayerClassArgsFromPlayerClassRecursive4(TypedDict, total=False):
    """Arguments for PlayerClass"""
    take: int
    skip: int
    order_by: Union['PlayerClassOrderByInput', List['PlayerClassOrderByInput']]
    where: 'PlayerClassWhereInput'
    cursor: 'PlayerClassWhereUniqueInput'
    distinct: List['PlayerClassScalarFieldKeys']
    
    

class MagicItemIncludeFromPlayerClass(TypedDict, total=False):
    """Relational arguments for PlayerClass"""


class MagicItemIncludeFromPlayerClassRecursive1(TypedDict, total=False):
    """Relational arguments for PlayerClass"""


class MagicItemIncludeFromPlayerClassRecursive2(TypedDict, total=False):
    """Relational arguments for PlayerClass"""


class MagicItemIncludeFromPlayerClassRecursive3(TypedDict, total=False):
    """Relational arguments for PlayerClass"""


class MagicItemIncludeFromPlayerClassRecursive4(TypedDict, total=False):
    """Relational arguments for PlayerClass"""

    

class MagicItemArgsFromPlayerClass(TypedDict, total=False):
    """Arguments for PlayerClass"""
    include: 'MagicItemIncludeFromMagicItemRecursive1'


class MagicItemArgsFromPlayerClassRecursive1(TypedDict, total=False):
    """Arguments for PlayerClass"""
    include: 'MagicItemIncludeFromMagicItemRecursive2'


class MagicItemArgsFromPlayerClassRecursive2(TypedDict, total=False):
    """Arguments for PlayerClass"""
    include: 'MagicItemIncludeFromMagicItemRecursive3'


class MagicItemArgsFromPlayerClassRecursive3(TypedDict, total=False):
    """Arguments for PlayerClass"""
    include: 'MagicItemIncludeFromMagicItemRecursive4'


class MagicItemArgsFromPlayerClassRecursive4(TypedDict, total=False):
    """Arguments for PlayerClass"""
    
    

class FindManyMagicItemArgsFromPlayerClass(TypedDict, total=False):
    """Arguments for PlayerClass"""
    take: int
    skip: int
    order_by: Union['MagicItemOrderByInput', List['MagicItemOrderByInput']]
    where: 'MagicItemWhereInput'
    cursor: 'MagicItemWhereUniqueInput'
    distinct: List['MagicItemScalarFieldKeys']
    include: 'MagicItemIncludeFromMagicItemRecursive1'


class FindManyMagicItemArgsFromPlayerClassRecursive1(TypedDict, total=False):
    """Arguments for PlayerClass"""
    take: int
    skip: int
    order_by: Union['MagicItemOrderByInput', List['MagicItemOrderByInput']]
    where: 'MagicItemWhereInput'
    cursor: 'MagicItemWhereUniqueInput'
    distinct: List['MagicItemScalarFieldKeys']
    include: 'MagicItemIncludeFromMagicItemRecursive2'


class FindManyMagicItemArgsFromPlayerClassRecursive2(TypedDict, total=False):
    """Arguments for PlayerClass"""
    take: int
    skip: int
    order_by: Union['MagicItemOrderByInput', List['MagicItemOrderByInput']]
    where: 'MagicItemWhereInput'
    cursor: 'MagicItemWhereUniqueInput'
    distinct: List['MagicItemScalarFieldKeys']
    include: 'MagicItemIncludeFromMagicItemRecursive3'


class FindManyMagicItemArgsFromPlayerClassRecursive3(TypedDict, total=False):
    """Arguments for PlayerClass"""
    take: int
    skip: int
    order_by: Union['MagicItemOrderByInput', List['MagicItemOrderByInput']]
    where: 'MagicItemWhereInput'
    cursor: 'MagicItemWhereUniqueInput'
    distinct: List['MagicItemScalarFieldKeys']
    include: 'MagicItemIncludeFromMagicItemRecursive4'


class FindManyMagicItemArgsFromPlayerClassRecursive4(TypedDict, total=False):
    """Arguments for PlayerClass"""
    take: int
    skip: int
    order_by: Union['MagicItemOrderByInput', List['MagicItemOrderByInput']]
    where: 'MagicItemWhereInput'
    cursor: 'MagicItemWhereUniqueInput'
    distinct: List['MagicItemScalarFieldKeys']
    
    

class GeneralEquipmentIncludeFromPlayerClass(TypedDict, total=False):
    """Relational arguments for PlayerClass"""


class GeneralEquipmentIncludeFromPlayerClassRecursive1(TypedDict, total=False):
    """Relational arguments for PlayerClass"""


class GeneralEquipmentIncludeFromPlayerClassRecursive2(TypedDict, total=False):
    """Relational arguments for PlayerClass"""


class GeneralEquipmentIncludeFromPlayerClassRecursive3(TypedDict, total=False):
    """Relational arguments for PlayerClass"""


class GeneralEquipmentIncludeFromPlayerClassRecursive4(TypedDict, total=False):
    """Relational arguments for PlayerClass"""

    

class GeneralEquipmentArgsFromPlayerClass(TypedDict, total=False):
    """Arguments for PlayerClass"""
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive1'


class GeneralEquipmentArgsFromPlayerClassRecursive1(TypedDict, total=False):
    """Arguments for PlayerClass"""
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive2'


class GeneralEquipmentArgsFromPlayerClassRecursive2(TypedDict, total=False):
    """Arguments for PlayerClass"""
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive3'


class GeneralEquipmentArgsFromPlayerClassRecursive3(TypedDict, total=False):
    """Arguments for PlayerClass"""
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive4'


class GeneralEquipmentArgsFromPlayerClassRecursive4(TypedDict, total=False):
    """Arguments for PlayerClass"""
    
    

class FindManyGeneralEquipmentArgsFromPlayerClass(TypedDict, total=False):
    """Arguments for PlayerClass"""
    take: int
    skip: int
    order_by: Union['GeneralEquipmentOrderByInput', List['GeneralEquipmentOrderByInput']]
    where: 'GeneralEquipmentWhereInput'
    cursor: 'GeneralEquipmentWhereUniqueInput'
    distinct: List['GeneralEquipmentScalarFieldKeys']
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive1'


class FindManyGeneralEquipmentArgsFromPlayerClassRecursive1(TypedDict, total=False):
    """Arguments for PlayerClass"""
    take: int
    skip: int
    order_by: Union['GeneralEquipmentOrderByInput', List['GeneralEquipmentOrderByInput']]
    where: 'GeneralEquipmentWhereInput'
    cursor: 'GeneralEquipmentWhereUniqueInput'
    distinct: List['GeneralEquipmentScalarFieldKeys']
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive2'


class FindManyGeneralEquipmentArgsFromPlayerClassRecursive2(TypedDict, total=False):
    """Arguments for PlayerClass"""
    take: int
    skip: int
    order_by: Union['GeneralEquipmentOrderByInput', List['GeneralEquipmentOrderByInput']]
    where: 'GeneralEquipmentWhereInput'
    cursor: 'GeneralEquipmentWhereUniqueInput'
    distinct: List['GeneralEquipmentScalarFieldKeys']
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive3'


class FindManyGeneralEquipmentArgsFromPlayerClassRecursive3(TypedDict, total=False):
    """Arguments for PlayerClass"""
    take: int
    skip: int
    order_by: Union['GeneralEquipmentOrderByInput', List['GeneralEquipmentOrderByInput']]
    where: 'GeneralEquipmentWhereInput'
    cursor: 'GeneralEquipmentWhereUniqueInput'
    distinct: List['GeneralEquipmentScalarFieldKeys']
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive4'


class FindManyGeneralEquipmentArgsFromPlayerClassRecursive4(TypedDict, total=False):
    """Arguments for PlayerClass"""
    take: int
    skip: int
    order_by: Union['GeneralEquipmentOrderByInput', List['GeneralEquipmentOrderByInput']]
    where: 'GeneralEquipmentWhereInput'
    cursor: 'GeneralEquipmentWhereUniqueInput'
    distinct: List['GeneralEquipmentScalarFieldKeys']
    


FindManyPlayerClassArgs = FindManyPlayerClassArgsFromPlayerClass
FindFirstPlayerClassArgs = FindManyPlayerClassArgsFromPlayerClass


    

class PlayerClassWhereInput(TypedDict, total=False):
    """PlayerClass arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    Playerclass: Union[_str, 'types.StringFilter']
    subclass: Union[_str, 'types.StringFilter']
    source: Union[None, _str, 'types.StringFilter']
    notes: Union[None, _str, 'types.StringFilter']
    features: Union[None, _str, 'types.StringFilter']
    level: Union[None, _str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['PlayerClassWhereInputRecursive1', List['PlayerClassWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['PlayerClassWhereInputRecursive1']
    OR: List['PlayerClassWhereInputRecursive1']
    NOT: List['PlayerClassWhereInputRecursive1']


class PlayerClassWhereInputRecursive1(TypedDict, total=False):
    """PlayerClass arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    Playerclass: Union[_str, 'types.StringFilter']
    subclass: Union[_str, 'types.StringFilter']
    source: Union[None, _str, 'types.StringFilter']
    notes: Union[None, _str, 'types.StringFilter']
    features: Union[None, _str, 'types.StringFilter']
    level: Union[None, _str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['PlayerClassWhereInputRecursive2', List['PlayerClassWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['PlayerClassWhereInputRecursive2']
    OR: List['PlayerClassWhereInputRecursive2']
    NOT: List['PlayerClassWhereInputRecursive2']


class PlayerClassWhereInputRecursive2(TypedDict, total=False):
    """PlayerClass arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    Playerclass: Union[_str, 'types.StringFilter']
    subclass: Union[_str, 'types.StringFilter']
    source: Union[None, _str, 'types.StringFilter']
    notes: Union[None, _str, 'types.StringFilter']
    features: Union[None, _str, 'types.StringFilter']
    level: Union[None, _str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['PlayerClassWhereInputRecursive3', List['PlayerClassWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['PlayerClassWhereInputRecursive3']
    OR: List['PlayerClassWhereInputRecursive3']
    NOT: List['PlayerClassWhereInputRecursive3']


class PlayerClassWhereInputRecursive3(TypedDict, total=False):
    """PlayerClass arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    Playerclass: Union[_str, 'types.StringFilter']
    subclass: Union[_str, 'types.StringFilter']
    source: Union[None, _str, 'types.StringFilter']
    notes: Union[None, _str, 'types.StringFilter']
    features: Union[None, _str, 'types.StringFilter']
    level: Union[None, _str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['PlayerClassWhereInputRecursive4', List['PlayerClassWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['PlayerClassWhereInputRecursive4']
    OR: List['PlayerClassWhereInputRecursive4']
    NOT: List['PlayerClassWhereInputRecursive4']


class PlayerClassWhereInputRecursive4(TypedDict, total=False):
    """PlayerClass arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    Playerclass: Union[_str, 'types.StringFilter']
    subclass: Union[_str, 'types.StringFilter']
    source: Union[None, _str, 'types.StringFilter']
    notes: Union[None, _str, 'types.StringFilter']
    features: Union[None, _str, 'types.StringFilter']
    level: Union[None, _str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']



# aggregate PlayerClass types


    

class PlayerClassScalarWhereWithAggregatesInput(TypedDict, total=False):
    """PlayerClass arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    Playerclass: Union[_str, 'types.StringWithAggregatesFilter']
    subclass: Union[_str, 'types.StringWithAggregatesFilter']
    source: Union[_str, 'types.StringWithAggregatesFilter']
    notes: Union[_str, 'types.StringWithAggregatesFilter']
    features: Union[_str, 'types.StringWithAggregatesFilter']
    level: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['PlayerClassScalarWhereWithAggregatesInputRecursive1']
    OR: List['PlayerClassScalarWhereWithAggregatesInputRecursive1']
    NOT: List['PlayerClassScalarWhereWithAggregatesInputRecursive1']


class PlayerClassScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """PlayerClass arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    Playerclass: Union[_str, 'types.StringWithAggregatesFilter']
    subclass: Union[_str, 'types.StringWithAggregatesFilter']
    source: Union[_str, 'types.StringWithAggregatesFilter']
    notes: Union[_str, 'types.StringWithAggregatesFilter']
    features: Union[_str, 'types.StringWithAggregatesFilter']
    level: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['PlayerClassScalarWhereWithAggregatesInputRecursive2']
    OR: List['PlayerClassScalarWhereWithAggregatesInputRecursive2']
    NOT: List['PlayerClassScalarWhereWithAggregatesInputRecursive2']


class PlayerClassScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """PlayerClass arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    Playerclass: Union[_str, 'types.StringWithAggregatesFilter']
    subclass: Union[_str, 'types.StringWithAggregatesFilter']
    source: Union[_str, 'types.StringWithAggregatesFilter']
    notes: Union[_str, 'types.StringWithAggregatesFilter']
    features: Union[_str, 'types.StringWithAggregatesFilter']
    level: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['PlayerClassScalarWhereWithAggregatesInputRecursive3']
    OR: List['PlayerClassScalarWhereWithAggregatesInputRecursive3']
    NOT: List['PlayerClassScalarWhereWithAggregatesInputRecursive3']


class PlayerClassScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """PlayerClass arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    Playerclass: Union[_str, 'types.StringWithAggregatesFilter']
    subclass: Union[_str, 'types.StringWithAggregatesFilter']
    source: Union[_str, 'types.StringWithAggregatesFilter']
    notes: Union[_str, 'types.StringWithAggregatesFilter']
    features: Union[_str, 'types.StringWithAggregatesFilter']
    level: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['PlayerClassScalarWhereWithAggregatesInputRecursive4']
    OR: List['PlayerClassScalarWhereWithAggregatesInputRecursive4']
    NOT: List['PlayerClassScalarWhereWithAggregatesInputRecursive4']


class PlayerClassScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """PlayerClass arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    Playerclass: Union[_str, 'types.StringWithAggregatesFilter']
    subclass: Union[_str, 'types.StringWithAggregatesFilter']
    source: Union[_str, 'types.StringWithAggregatesFilter']
    notes: Union[_str, 'types.StringWithAggregatesFilter']
    features: Union[_str, 'types.StringWithAggregatesFilter']
    level: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']



class PlayerClassGroupByOutput(TypedDict, total=False):
    id: _int
    Playerclass: _str
    subclass: _str
    source: _str
    notes: _str
    features: _str
    level: _str
    description: _str
    _sum: 'PlayerClassSumAggregateOutput'
    _avg: 'PlayerClassAvgAggregateOutput'
    _min: 'PlayerClassMinAggregateOutput'
    _max: 'PlayerClassMaxAggregateOutput'
    _count: 'PlayerClassCountAggregateOutput'


class PlayerClassAvgAggregateOutput(TypedDict, total=False):
    """PlayerClass output for aggregating averages"""
    id: float


class PlayerClassSumAggregateOutput(TypedDict, total=False):
    """PlayerClass output for aggregating sums"""
    id: _int


class PlayerClassScalarAggregateOutput(TypedDict, total=False):
    """PlayerClass output including scalar fields"""
    id: _int
    Playerclass: _str
    subclass: _str
    source: _str
    notes: _str
    features: _str
    level: _str
    description: _str


PlayerClassMinAggregateOutput = PlayerClassScalarAggregateOutput
PlayerClassMaxAggregateOutput = PlayerClassScalarAggregateOutput


class PlayerClassMaxAggregateInput(TypedDict, total=False):
    """PlayerClass input for aggregating by max"""
    id: bool
    Playerclass: bool
    subclass: bool
    source: bool
    notes: bool
    features: bool
    level: bool
    description: bool


class PlayerClassMinAggregateInput(TypedDict, total=False):
    """PlayerClass input for aggregating by min"""
    id: bool
    Playerclass: bool
    subclass: bool
    source: bool
    notes: bool
    features: bool
    level: bool
    description: bool


class PlayerClassNumberAggregateInput(TypedDict, total=False):
    """PlayerClass input for aggregating numbers"""
    id: bool


PlayerClassAvgAggregateInput = PlayerClassNumberAggregateInput
PlayerClassSumAggregateInput = PlayerClassNumberAggregateInput


PlayerClassCountAggregateInput = TypedDict(
    'PlayerClassCountAggregateInput',
    {
        'id': bool,
        'Playerclass': bool,
        'subclass': bool,
        'source': bool,
        'notes': bool,
        'features': bool,
        'level': bool,
        'description': bool,
        '_all': bool,
    },
    total=False,
)

PlayerClassCountAggregateOutput = TypedDict(
    'PlayerClassCountAggregateOutput',
    {
        'id': int,
        'Playerclass': int,
        'subclass': int,
        'source': int,
        'notes': int,
        'features': int,
        'level': int,
        'description': int,
        '_all': int,
    },
    total=False,
)


PlayerClassKeys = Literal[
    'id',
    'Playerclass',
    'subclass',
    'source',
    'notes',
    'features',
    'level',
    'description',
]
PlayerClassScalarFieldKeys = Literal[
    'id',
    'Playerclass',
    'subclass',
    'source',
    'notes',
    'features',
    'level',
    'description',
]
PlayerClassScalarFieldKeysT = TypeVar('PlayerClassScalarFieldKeysT', bound=PlayerClassScalarFieldKeys)

PlayerClassRelationalFieldKeys = _NoneType

# MagicItem types

class MagicItemOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the MagicItem create method"""
    id: _int
    rarity: Optional[_str]
    attunement: Optional[_str]
    costGp: Optional[_int]
    note: Optional[_str]
    armorCost: Optional[_int]
    rareMaterial: Optional[_str]
    acBonus: Optional[_int]
    saveBonus: Optional[_int]
    setScoreModifier: Optional[_int]
    plusTwoBonusToScore: Optional[_str]
    weaponBonus: Optional[_int]
    spellLevel: Optional[_int]
    unlimitedCharges: Optional[_str]
    chargesPerDay: Optional[_int]
    chargesPerItem: Optional[_int]
    spellsShareCharges: Optional[_int]
    condition: Optional[_str]
    consumableDamageAvg: Optional[_int]
    consumableSave: Optional[_str]
    semiPermanentDamageAvg: Optional[_int]
    semiPermSave: Optional[_str]
    durationMinutes: Optional[_int]
    permanentDamageAvg: Optional[_int]
    permSave: Optional[_str]
    specificSituations: Optional[_str]
    restoreHpAvg: Optional[_int]
    miscCosts: Optional[_int]
    secondSpellLevel: Optional[_int]
    secondUnlimitedCharges: Optional[_str]
    secondChargesPerDay: Optional[_int]
    thirdSpellLevel: Optional[_int]
    thirdUnlimitedCharges: Optional[_str]
    thirdChargesPerDay: Optional[_int]
    matCost: Optional[_int]
    acCost: Optional[_int]
    saveCost: Optional[_int]
    setScoreCost: Optional[_int]
    bonusScoreCost: Optional[_int]
    weaponCost: Optional[_int]
    consumSpellCost: Optional[_int]
    permChargesCost: Optional[_int]
    chargesDestroyed: Optional[_int]
    spellShareChargesCost: Optional[_int]
    conditionCost: Optional[_int]
    consDMGCost: Optional[_int]
    smPrDMGCost: Optional[_int]
    perDMGCost: Optional[_int]
    avgHPCost: Optional[_int]
    miscCost: Optional[_int]
    secondConsumSpellCost: Optional[_int]
    secondPermChargesCost: Optional[_int]
    thirdConsumSpellCost: Optional[_int]
    thirdPermChargesCost: Optional[_int]


class MagicItemCreateInput(MagicItemOptionalCreateInput):
    """Required arguments to the MagicItem create method"""
    name: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class MagicItemOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the MagicItem create method, without relations"""
    id: _int
    rarity: Optional[_str]
    attunement: Optional[_str]
    costGp: Optional[_int]
    note: Optional[_str]
    armorCost: Optional[_int]
    rareMaterial: Optional[_str]
    acBonus: Optional[_int]
    saveBonus: Optional[_int]
    setScoreModifier: Optional[_int]
    plusTwoBonusToScore: Optional[_str]
    weaponBonus: Optional[_int]
    spellLevel: Optional[_int]
    unlimitedCharges: Optional[_str]
    chargesPerDay: Optional[_int]
    chargesPerItem: Optional[_int]
    spellsShareCharges: Optional[_int]
    condition: Optional[_str]
    consumableDamageAvg: Optional[_int]
    consumableSave: Optional[_str]
    semiPermanentDamageAvg: Optional[_int]
    semiPermSave: Optional[_str]
    durationMinutes: Optional[_int]
    permanentDamageAvg: Optional[_int]
    permSave: Optional[_str]
    specificSituations: Optional[_str]
    restoreHpAvg: Optional[_int]
    miscCosts: Optional[_int]
    secondSpellLevel: Optional[_int]
    secondUnlimitedCharges: Optional[_str]
    secondChargesPerDay: Optional[_int]
    thirdSpellLevel: Optional[_int]
    thirdUnlimitedCharges: Optional[_str]
    thirdChargesPerDay: Optional[_int]
    matCost: Optional[_int]
    acCost: Optional[_int]
    saveCost: Optional[_int]
    setScoreCost: Optional[_int]
    bonusScoreCost: Optional[_int]
    weaponCost: Optional[_int]
    consumSpellCost: Optional[_int]
    permChargesCost: Optional[_int]
    chargesDestroyed: Optional[_int]
    spellShareChargesCost: Optional[_int]
    conditionCost: Optional[_int]
    consDMGCost: Optional[_int]
    smPrDMGCost: Optional[_int]
    perDMGCost: Optional[_int]
    avgHPCost: Optional[_int]
    miscCost: Optional[_int]
    secondConsumSpellCost: Optional[_int]
    secondPermChargesCost: Optional[_int]
    thirdConsumSpellCost: Optional[_int]
    thirdPermChargesCost: Optional[_int]


class MagicItemCreateWithoutRelationsInput(MagicItemOptionalCreateWithoutRelationsInput):
    """Required arguments to the MagicItem create method, without relations"""
    name: _str

class MagicItemConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'MagicItemCreateWithoutRelationsInput'
    where: 'MagicItemWhereUniqueInput'

class MagicItemCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'MagicItemCreateWithoutRelationsInput'
    connect: 'MagicItemWhereUniqueInput'
    connect_or_create: 'MagicItemConnectOrCreateWithoutRelationsInput'


class MagicItemCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['MagicItemCreateWithoutRelationsInput', List['MagicItemCreateWithoutRelationsInput']]
    connect: Union['MagicItemWhereUniqueInput', List['MagicItemWhereUniqueInput']]
    connect_or_create: Union['MagicItemConnectOrCreateWithoutRelationsInput', List['MagicItemConnectOrCreateWithoutRelationsInput']]

_MagicItemWhereUnique_id_Input = TypedDict(
    '_MagicItemWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

MagicItemWhereUniqueInput = _MagicItemWhereUnique_id_Input


class MagicItemUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    name: _str
    rarity: Optional[_str]
    attunement: Optional[_str]
    costGp: Optional[Union[AtomicIntInput, _int]]
    note: Optional[_str]
    armorCost: Optional[Union[AtomicIntInput, _int]]
    rareMaterial: Optional[_str]
    acBonus: Optional[Union[AtomicIntInput, _int]]
    saveBonus: Optional[Union[AtomicIntInput, _int]]
    setScoreModifier: Optional[Union[AtomicIntInput, _int]]
    plusTwoBonusToScore: Optional[_str]
    weaponBonus: Optional[Union[AtomicIntInput, _int]]
    spellLevel: Optional[Union[AtomicIntInput, _int]]
    unlimitedCharges: Optional[_str]
    chargesPerDay: Optional[Union[AtomicIntInput, _int]]
    chargesPerItem: Optional[Union[AtomicIntInput, _int]]
    spellsShareCharges: Optional[Union[AtomicIntInput, _int]]
    condition: Optional[_str]
    consumableDamageAvg: Optional[Union[AtomicIntInput, _int]]
    consumableSave: Optional[_str]
    semiPermanentDamageAvg: Optional[Union[AtomicIntInput, _int]]
    semiPermSave: Optional[_str]
    durationMinutes: Optional[Union[AtomicIntInput, _int]]
    permanentDamageAvg: Optional[Union[AtomicIntInput, _int]]
    permSave: Optional[_str]
    specificSituations: Optional[_str]
    restoreHpAvg: Optional[Union[AtomicIntInput, _int]]
    miscCosts: Optional[Union[AtomicIntInput, _int]]
    secondSpellLevel: Optional[Union[AtomicIntInput, _int]]
    secondUnlimitedCharges: Optional[_str]
    secondChargesPerDay: Optional[Union[AtomicIntInput, _int]]
    thirdSpellLevel: Optional[Union[AtomicIntInput, _int]]
    thirdUnlimitedCharges: Optional[_str]
    thirdChargesPerDay: Optional[Union[AtomicIntInput, _int]]
    matCost: Optional[Union[AtomicIntInput, _int]]
    acCost: Optional[Union[AtomicIntInput, _int]]
    saveCost: Optional[Union[AtomicIntInput, _int]]
    setScoreCost: Optional[Union[AtomicIntInput, _int]]
    bonusScoreCost: Optional[Union[AtomicIntInput, _int]]
    weaponCost: Optional[Union[AtomicIntInput, _int]]
    consumSpellCost: Optional[Union[AtomicIntInput, _int]]
    permChargesCost: Optional[Union[AtomicIntInput, _int]]
    chargesDestroyed: Optional[Union[AtomicIntInput, _int]]
    spellShareChargesCost: Optional[Union[AtomicIntInput, _int]]
    conditionCost: Optional[Union[AtomicIntInput, _int]]
    consDMGCost: Optional[Union[AtomicIntInput, _int]]
    smPrDMGCost: Optional[Union[AtomicIntInput, _int]]
    perDMGCost: Optional[Union[AtomicIntInput, _int]]
    avgHPCost: Optional[Union[AtomicIntInput, _int]]
    miscCost: Optional[Union[AtomicIntInput, _int]]
    secondConsumSpellCost: Optional[Union[AtomicIntInput, _int]]
    secondPermChargesCost: Optional[Union[AtomicIntInput, _int]]
    thirdConsumSpellCost: Optional[Union[AtomicIntInput, _int]]
    thirdPermChargesCost: Optional[Union[AtomicIntInput, _int]]


class MagicItemUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    name: _str
    rarity: Optional[_str]
    attunement: Optional[_str]
    costGp: Optional[Union[AtomicIntInput, _int]]
    note: Optional[_str]
    armorCost: Optional[Union[AtomicIntInput, _int]]
    rareMaterial: Optional[_str]
    acBonus: Optional[Union[AtomicIntInput, _int]]
    saveBonus: Optional[Union[AtomicIntInput, _int]]
    setScoreModifier: Optional[Union[AtomicIntInput, _int]]
    plusTwoBonusToScore: Optional[_str]
    weaponBonus: Optional[Union[AtomicIntInput, _int]]
    spellLevel: Optional[Union[AtomicIntInput, _int]]
    unlimitedCharges: Optional[_str]
    chargesPerDay: Optional[Union[AtomicIntInput, _int]]
    chargesPerItem: Optional[Union[AtomicIntInput, _int]]
    spellsShareCharges: Optional[Union[AtomicIntInput, _int]]
    condition: Optional[_str]
    consumableDamageAvg: Optional[Union[AtomicIntInput, _int]]
    consumableSave: Optional[_str]
    semiPermanentDamageAvg: Optional[Union[AtomicIntInput, _int]]
    semiPermSave: Optional[_str]
    durationMinutes: Optional[Union[AtomicIntInput, _int]]
    permanentDamageAvg: Optional[Union[AtomicIntInput, _int]]
    permSave: Optional[_str]
    specificSituations: Optional[_str]
    restoreHpAvg: Optional[Union[AtomicIntInput, _int]]
    miscCosts: Optional[Union[AtomicIntInput, _int]]
    secondSpellLevel: Optional[Union[AtomicIntInput, _int]]
    secondUnlimitedCharges: Optional[_str]
    secondChargesPerDay: Optional[Union[AtomicIntInput, _int]]
    thirdSpellLevel: Optional[Union[AtomicIntInput, _int]]
    thirdUnlimitedCharges: Optional[_str]
    thirdChargesPerDay: Optional[Union[AtomicIntInput, _int]]
    matCost: Optional[Union[AtomicIntInput, _int]]
    acCost: Optional[Union[AtomicIntInput, _int]]
    saveCost: Optional[Union[AtomicIntInput, _int]]
    setScoreCost: Optional[Union[AtomicIntInput, _int]]
    bonusScoreCost: Optional[Union[AtomicIntInput, _int]]
    weaponCost: Optional[Union[AtomicIntInput, _int]]
    consumSpellCost: Optional[Union[AtomicIntInput, _int]]
    permChargesCost: Optional[Union[AtomicIntInput, _int]]
    chargesDestroyed: Optional[Union[AtomicIntInput, _int]]
    spellShareChargesCost: Optional[Union[AtomicIntInput, _int]]
    conditionCost: Optional[Union[AtomicIntInput, _int]]
    consDMGCost: Optional[Union[AtomicIntInput, _int]]
    smPrDMGCost: Optional[Union[AtomicIntInput, _int]]
    perDMGCost: Optional[Union[AtomicIntInput, _int]]
    avgHPCost: Optional[Union[AtomicIntInput, _int]]
    miscCost: Optional[Union[AtomicIntInput, _int]]
    secondConsumSpellCost: Optional[Union[AtomicIntInput, _int]]
    secondPermChargesCost: Optional[Union[AtomicIntInput, _int]]
    thirdConsumSpellCost: Optional[Union[AtomicIntInput, _int]]
    thirdPermChargesCost: Optional[Union[AtomicIntInput, _int]]


class MagicItemUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['MagicItemCreateWithoutRelationsInput']
    connect: List['MagicItemWhereUniqueInput']
    connect_or_create: List['MagicItemConnectOrCreateWithoutRelationsInput']
    set: List['MagicItemWhereUniqueInput']
    disconnect: List['MagicItemWhereUniqueInput']
    delete: List['MagicItemWhereUniqueInput']

    # TODO
    # update: List['MagicItemUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['MagicItemUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['MagicItemScalarWhereInput']
    # upsert: List['MagicItemUpserteWithWhereUniqueWithoutRelationsInput']


class MagicItemUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'MagicItemCreateWithoutRelationsInput'
    connect: 'MagicItemWhereUniqueInput'
    connect_or_create: 'MagicItemConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'MagicItemUpdateInput'
    # upsert: 'MagicItemUpsertWithoutRelationsInput'


class MagicItemUpsertInput(TypedDict):
    create: 'MagicItemCreateInput'
    update: 'MagicItemUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_MagicItem_id_OrderByInput = TypedDict(
    '_MagicItem_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_MagicItem_name_OrderByInput = TypedDict(
    '_MagicItem_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_MagicItem_rarity_OrderByInput = TypedDict(
    '_MagicItem_rarity_OrderByInput',
    {
        'rarity': 'SortOrder',
    },
    total=True
)

_MagicItem_attunement_OrderByInput = TypedDict(
    '_MagicItem_attunement_OrderByInput',
    {
        'attunement': 'SortOrder',
    },
    total=True
)

_MagicItem_costGp_OrderByInput = TypedDict(
    '_MagicItem_costGp_OrderByInput',
    {
        'costGp': 'SortOrder',
    },
    total=True
)

_MagicItem_note_OrderByInput = TypedDict(
    '_MagicItem_note_OrderByInput',
    {
        'note': 'SortOrder',
    },
    total=True
)

_MagicItem_armorCost_OrderByInput = TypedDict(
    '_MagicItem_armorCost_OrderByInput',
    {
        'armorCost': 'SortOrder',
    },
    total=True
)

_MagicItem_rareMaterial_OrderByInput = TypedDict(
    '_MagicItem_rareMaterial_OrderByInput',
    {
        'rareMaterial': 'SortOrder',
    },
    total=True
)

_MagicItem_acBonus_OrderByInput = TypedDict(
    '_MagicItem_acBonus_OrderByInput',
    {
        'acBonus': 'SortOrder',
    },
    total=True
)

_MagicItem_saveBonus_OrderByInput = TypedDict(
    '_MagicItem_saveBonus_OrderByInput',
    {
        'saveBonus': 'SortOrder',
    },
    total=True
)

_MagicItem_setScoreModifier_OrderByInput = TypedDict(
    '_MagicItem_setScoreModifier_OrderByInput',
    {
        'setScoreModifier': 'SortOrder',
    },
    total=True
)

_MagicItem_plusTwoBonusToScore_OrderByInput = TypedDict(
    '_MagicItem_plusTwoBonusToScore_OrderByInput',
    {
        'plusTwoBonusToScore': 'SortOrder',
    },
    total=True
)

_MagicItem_weaponBonus_OrderByInput = TypedDict(
    '_MagicItem_weaponBonus_OrderByInput',
    {
        'weaponBonus': 'SortOrder',
    },
    total=True
)

_MagicItem_spellLevel_OrderByInput = TypedDict(
    '_MagicItem_spellLevel_OrderByInput',
    {
        'spellLevel': 'SortOrder',
    },
    total=True
)

_MagicItem_unlimitedCharges_OrderByInput = TypedDict(
    '_MagicItem_unlimitedCharges_OrderByInput',
    {
        'unlimitedCharges': 'SortOrder',
    },
    total=True
)

_MagicItem_chargesPerDay_OrderByInput = TypedDict(
    '_MagicItem_chargesPerDay_OrderByInput',
    {
        'chargesPerDay': 'SortOrder',
    },
    total=True
)

_MagicItem_chargesPerItem_OrderByInput = TypedDict(
    '_MagicItem_chargesPerItem_OrderByInput',
    {
        'chargesPerItem': 'SortOrder',
    },
    total=True
)

_MagicItem_spellsShareCharges_OrderByInput = TypedDict(
    '_MagicItem_spellsShareCharges_OrderByInput',
    {
        'spellsShareCharges': 'SortOrder',
    },
    total=True
)

_MagicItem_condition_OrderByInput = TypedDict(
    '_MagicItem_condition_OrderByInput',
    {
        'condition': 'SortOrder',
    },
    total=True
)

_MagicItem_consumableDamageAvg_OrderByInput = TypedDict(
    '_MagicItem_consumableDamageAvg_OrderByInput',
    {
        'consumableDamageAvg': 'SortOrder',
    },
    total=True
)

_MagicItem_consumableSave_OrderByInput = TypedDict(
    '_MagicItem_consumableSave_OrderByInput',
    {
        'consumableSave': 'SortOrder',
    },
    total=True
)

_MagicItem_semiPermanentDamageAvg_OrderByInput = TypedDict(
    '_MagicItem_semiPermanentDamageAvg_OrderByInput',
    {
        'semiPermanentDamageAvg': 'SortOrder',
    },
    total=True
)

_MagicItem_semiPermSave_OrderByInput = TypedDict(
    '_MagicItem_semiPermSave_OrderByInput',
    {
        'semiPermSave': 'SortOrder',
    },
    total=True
)

_MagicItem_durationMinutes_OrderByInput = TypedDict(
    '_MagicItem_durationMinutes_OrderByInput',
    {
        'durationMinutes': 'SortOrder',
    },
    total=True
)

_MagicItem_permanentDamageAvg_OrderByInput = TypedDict(
    '_MagicItem_permanentDamageAvg_OrderByInput',
    {
        'permanentDamageAvg': 'SortOrder',
    },
    total=True
)

_MagicItem_permSave_OrderByInput = TypedDict(
    '_MagicItem_permSave_OrderByInput',
    {
        'permSave': 'SortOrder',
    },
    total=True
)

_MagicItem_specificSituations_OrderByInput = TypedDict(
    '_MagicItem_specificSituations_OrderByInput',
    {
        'specificSituations': 'SortOrder',
    },
    total=True
)

_MagicItem_restoreHpAvg_OrderByInput = TypedDict(
    '_MagicItem_restoreHpAvg_OrderByInput',
    {
        'restoreHpAvg': 'SortOrder',
    },
    total=True
)

_MagicItem_miscCosts_OrderByInput = TypedDict(
    '_MagicItem_miscCosts_OrderByInput',
    {
        'miscCosts': 'SortOrder',
    },
    total=True
)

_MagicItem_secondSpellLevel_OrderByInput = TypedDict(
    '_MagicItem_secondSpellLevel_OrderByInput',
    {
        'secondSpellLevel': 'SortOrder',
    },
    total=True
)

_MagicItem_secondUnlimitedCharges_OrderByInput = TypedDict(
    '_MagicItem_secondUnlimitedCharges_OrderByInput',
    {
        'secondUnlimitedCharges': 'SortOrder',
    },
    total=True
)

_MagicItem_secondChargesPerDay_OrderByInput = TypedDict(
    '_MagicItem_secondChargesPerDay_OrderByInput',
    {
        'secondChargesPerDay': 'SortOrder',
    },
    total=True
)

_MagicItem_thirdSpellLevel_OrderByInput = TypedDict(
    '_MagicItem_thirdSpellLevel_OrderByInput',
    {
        'thirdSpellLevel': 'SortOrder',
    },
    total=True
)

_MagicItem_thirdUnlimitedCharges_OrderByInput = TypedDict(
    '_MagicItem_thirdUnlimitedCharges_OrderByInput',
    {
        'thirdUnlimitedCharges': 'SortOrder',
    },
    total=True
)

_MagicItem_thirdChargesPerDay_OrderByInput = TypedDict(
    '_MagicItem_thirdChargesPerDay_OrderByInput',
    {
        'thirdChargesPerDay': 'SortOrder',
    },
    total=True
)

_MagicItem_matCost_OrderByInput = TypedDict(
    '_MagicItem_matCost_OrderByInput',
    {
        'matCost': 'SortOrder',
    },
    total=True
)

_MagicItem_acCost_OrderByInput = TypedDict(
    '_MagicItem_acCost_OrderByInput',
    {
        'acCost': 'SortOrder',
    },
    total=True
)

_MagicItem_saveCost_OrderByInput = TypedDict(
    '_MagicItem_saveCost_OrderByInput',
    {
        'saveCost': 'SortOrder',
    },
    total=True
)

_MagicItem_setScoreCost_OrderByInput = TypedDict(
    '_MagicItem_setScoreCost_OrderByInput',
    {
        'setScoreCost': 'SortOrder',
    },
    total=True
)

_MagicItem_bonusScoreCost_OrderByInput = TypedDict(
    '_MagicItem_bonusScoreCost_OrderByInput',
    {
        'bonusScoreCost': 'SortOrder',
    },
    total=True
)

_MagicItem_weaponCost_OrderByInput = TypedDict(
    '_MagicItem_weaponCost_OrderByInput',
    {
        'weaponCost': 'SortOrder',
    },
    total=True
)

_MagicItem_consumSpellCost_OrderByInput = TypedDict(
    '_MagicItem_consumSpellCost_OrderByInput',
    {
        'consumSpellCost': 'SortOrder',
    },
    total=True
)

_MagicItem_permChargesCost_OrderByInput = TypedDict(
    '_MagicItem_permChargesCost_OrderByInput',
    {
        'permChargesCost': 'SortOrder',
    },
    total=True
)

_MagicItem_chargesDestroyed_OrderByInput = TypedDict(
    '_MagicItem_chargesDestroyed_OrderByInput',
    {
        'chargesDestroyed': 'SortOrder',
    },
    total=True
)

_MagicItem_spellShareChargesCost_OrderByInput = TypedDict(
    '_MagicItem_spellShareChargesCost_OrderByInput',
    {
        'spellShareChargesCost': 'SortOrder',
    },
    total=True
)

_MagicItem_conditionCost_OrderByInput = TypedDict(
    '_MagicItem_conditionCost_OrderByInput',
    {
        'conditionCost': 'SortOrder',
    },
    total=True
)

_MagicItem_consDMGCost_OrderByInput = TypedDict(
    '_MagicItem_consDMGCost_OrderByInput',
    {
        'consDMGCost': 'SortOrder',
    },
    total=True
)

_MagicItem_smPrDMGCost_OrderByInput = TypedDict(
    '_MagicItem_smPrDMGCost_OrderByInput',
    {
        'smPrDMGCost': 'SortOrder',
    },
    total=True
)

_MagicItem_perDMGCost_OrderByInput = TypedDict(
    '_MagicItem_perDMGCost_OrderByInput',
    {
        'perDMGCost': 'SortOrder',
    },
    total=True
)

_MagicItem_avgHPCost_OrderByInput = TypedDict(
    '_MagicItem_avgHPCost_OrderByInput',
    {
        'avgHPCost': 'SortOrder',
    },
    total=True
)

_MagicItem_miscCost_OrderByInput = TypedDict(
    '_MagicItem_miscCost_OrderByInput',
    {
        'miscCost': 'SortOrder',
    },
    total=True
)

_MagicItem_secondConsumSpellCost_OrderByInput = TypedDict(
    '_MagicItem_secondConsumSpellCost_OrderByInput',
    {
        'secondConsumSpellCost': 'SortOrder',
    },
    total=True
)

_MagicItem_secondPermChargesCost_OrderByInput = TypedDict(
    '_MagicItem_secondPermChargesCost_OrderByInput',
    {
        'secondPermChargesCost': 'SortOrder',
    },
    total=True
)

_MagicItem_thirdConsumSpellCost_OrderByInput = TypedDict(
    '_MagicItem_thirdConsumSpellCost_OrderByInput',
    {
        'thirdConsumSpellCost': 'SortOrder',
    },
    total=True
)

_MagicItem_thirdPermChargesCost_OrderByInput = TypedDict(
    '_MagicItem_thirdPermChargesCost_OrderByInput',
    {
        'thirdPermChargesCost': 'SortOrder',
    },
    total=True
)

_MagicItem_RelevanceInner = TypedDict(
    '_MagicItem_RelevanceInner',
    {
        'fields': 'List[MagicItemScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_MagicItem_RelevanceOrderByInput = TypedDict(
    '_MagicItem_RelevanceOrderByInput',
    {
        '_relevance': '_MagicItem_RelevanceInner',
    },
    total=True
)

MagicItemOrderByInput = Union[
    '_MagicItem_id_OrderByInput',
    '_MagicItem_name_OrderByInput',
    '_MagicItem_rarity_OrderByInput',
    '_MagicItem_attunement_OrderByInput',
    '_MagicItem_costGp_OrderByInput',
    '_MagicItem_note_OrderByInput',
    '_MagicItem_armorCost_OrderByInput',
    '_MagicItem_rareMaterial_OrderByInput',
    '_MagicItem_acBonus_OrderByInput',
    '_MagicItem_saveBonus_OrderByInput',
    '_MagicItem_setScoreModifier_OrderByInput',
    '_MagicItem_plusTwoBonusToScore_OrderByInput',
    '_MagicItem_weaponBonus_OrderByInput',
    '_MagicItem_spellLevel_OrderByInput',
    '_MagicItem_unlimitedCharges_OrderByInput',
    '_MagicItem_chargesPerDay_OrderByInput',
    '_MagicItem_chargesPerItem_OrderByInput',
    '_MagicItem_spellsShareCharges_OrderByInput',
    '_MagicItem_condition_OrderByInput',
    '_MagicItem_consumableDamageAvg_OrderByInput',
    '_MagicItem_consumableSave_OrderByInput',
    '_MagicItem_semiPermanentDamageAvg_OrderByInput',
    '_MagicItem_semiPermSave_OrderByInput',
    '_MagicItem_durationMinutes_OrderByInput',
    '_MagicItem_permanentDamageAvg_OrderByInput',
    '_MagicItem_permSave_OrderByInput',
    '_MagicItem_specificSituations_OrderByInput',
    '_MagicItem_restoreHpAvg_OrderByInput',
    '_MagicItem_miscCosts_OrderByInput',
    '_MagicItem_secondSpellLevel_OrderByInput',
    '_MagicItem_secondUnlimitedCharges_OrderByInput',
    '_MagicItem_secondChargesPerDay_OrderByInput',
    '_MagicItem_thirdSpellLevel_OrderByInput',
    '_MagicItem_thirdUnlimitedCharges_OrderByInput',
    '_MagicItem_thirdChargesPerDay_OrderByInput',
    '_MagicItem_matCost_OrderByInput',
    '_MagicItem_acCost_OrderByInput',
    '_MagicItem_saveCost_OrderByInput',
    '_MagicItem_setScoreCost_OrderByInput',
    '_MagicItem_bonusScoreCost_OrderByInput',
    '_MagicItem_weaponCost_OrderByInput',
    '_MagicItem_consumSpellCost_OrderByInput',
    '_MagicItem_permChargesCost_OrderByInput',
    '_MagicItem_chargesDestroyed_OrderByInput',
    '_MagicItem_spellShareChargesCost_OrderByInput',
    '_MagicItem_conditionCost_OrderByInput',
    '_MagicItem_consDMGCost_OrderByInput',
    '_MagicItem_smPrDMGCost_OrderByInput',
    '_MagicItem_perDMGCost_OrderByInput',
    '_MagicItem_avgHPCost_OrderByInput',
    '_MagicItem_miscCost_OrderByInput',
    '_MagicItem_secondConsumSpellCost_OrderByInput',
    '_MagicItem_secondPermChargesCost_OrderByInput',
    '_MagicItem_thirdConsumSpellCost_OrderByInput',
    '_MagicItem_thirdPermChargesCost_OrderByInput',
    '_MagicItem_RelevanceOrderByInput',
]



# recursive MagicItem types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

MagicItemRelationFilter = TypedDict(
    'MagicItemRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class MagicItemListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class MagicItemInclude(TypedDict, total=False):
    """MagicItem relational arguments"""


    

class MonsterIncludeFromMagicItem(TypedDict, total=False):
    """Relational arguments for MagicItem"""


class MonsterIncludeFromMagicItemRecursive1(TypedDict, total=False):
    """Relational arguments for MagicItem"""


class MonsterIncludeFromMagicItemRecursive2(TypedDict, total=False):
    """Relational arguments for MagicItem"""


class MonsterIncludeFromMagicItemRecursive3(TypedDict, total=False):
    """Relational arguments for MagicItem"""


class MonsterIncludeFromMagicItemRecursive4(TypedDict, total=False):
    """Relational arguments for MagicItem"""

    

class MonsterArgsFromMagicItem(TypedDict, total=False):
    """Arguments for MagicItem"""
    include: 'MonsterIncludeFromMonsterRecursive1'


class MonsterArgsFromMagicItemRecursive1(TypedDict, total=False):
    """Arguments for MagicItem"""
    include: 'MonsterIncludeFromMonsterRecursive2'


class MonsterArgsFromMagicItemRecursive2(TypedDict, total=False):
    """Arguments for MagicItem"""
    include: 'MonsterIncludeFromMonsterRecursive3'


class MonsterArgsFromMagicItemRecursive3(TypedDict, total=False):
    """Arguments for MagicItem"""
    include: 'MonsterIncludeFromMonsterRecursive4'


class MonsterArgsFromMagicItemRecursive4(TypedDict, total=False):
    """Arguments for MagicItem"""
    
    

class FindManyMonsterArgsFromMagicItem(TypedDict, total=False):
    """Arguments for MagicItem"""
    take: int
    skip: int
    order_by: Union['MonsterOrderByInput', List['MonsterOrderByInput']]
    where: 'MonsterWhereInput'
    cursor: 'MonsterWhereUniqueInput'
    distinct: List['MonsterScalarFieldKeys']
    include: 'MonsterIncludeFromMonsterRecursive1'


class FindManyMonsterArgsFromMagicItemRecursive1(TypedDict, total=False):
    """Arguments for MagicItem"""
    take: int
    skip: int
    order_by: Union['MonsterOrderByInput', List['MonsterOrderByInput']]
    where: 'MonsterWhereInput'
    cursor: 'MonsterWhereUniqueInput'
    distinct: List['MonsterScalarFieldKeys']
    include: 'MonsterIncludeFromMonsterRecursive2'


class FindManyMonsterArgsFromMagicItemRecursive2(TypedDict, total=False):
    """Arguments for MagicItem"""
    take: int
    skip: int
    order_by: Union['MonsterOrderByInput', List['MonsterOrderByInput']]
    where: 'MonsterWhereInput'
    cursor: 'MonsterWhereUniqueInput'
    distinct: List['MonsterScalarFieldKeys']
    include: 'MonsterIncludeFromMonsterRecursive3'


class FindManyMonsterArgsFromMagicItemRecursive3(TypedDict, total=False):
    """Arguments for MagicItem"""
    take: int
    skip: int
    order_by: Union['MonsterOrderByInput', List['MonsterOrderByInput']]
    where: 'MonsterWhereInput'
    cursor: 'MonsterWhereUniqueInput'
    distinct: List['MonsterScalarFieldKeys']
    include: 'MonsterIncludeFromMonsterRecursive4'


class FindManyMonsterArgsFromMagicItemRecursive4(TypedDict, total=False):
    """Arguments for MagicItem"""
    take: int
    skip: int
    order_by: Union['MonsterOrderByInput', List['MonsterOrderByInput']]
    where: 'MonsterWhereInput'
    cursor: 'MonsterWhereUniqueInput'
    distinct: List['MonsterScalarFieldKeys']
    
    

class RaceIncludeFromMagicItem(TypedDict, total=False):
    """Relational arguments for MagicItem"""


class RaceIncludeFromMagicItemRecursive1(TypedDict, total=False):
    """Relational arguments for MagicItem"""


class RaceIncludeFromMagicItemRecursive2(TypedDict, total=False):
    """Relational arguments for MagicItem"""


class RaceIncludeFromMagicItemRecursive3(TypedDict, total=False):
    """Relational arguments for MagicItem"""


class RaceIncludeFromMagicItemRecursive4(TypedDict, total=False):
    """Relational arguments for MagicItem"""

    

class RaceArgsFromMagicItem(TypedDict, total=False):
    """Arguments for MagicItem"""
    include: 'RaceIncludeFromRaceRecursive1'


class RaceArgsFromMagicItemRecursive1(TypedDict, total=False):
    """Arguments for MagicItem"""
    include: 'RaceIncludeFromRaceRecursive2'


class RaceArgsFromMagicItemRecursive2(TypedDict, total=False):
    """Arguments for MagicItem"""
    include: 'RaceIncludeFromRaceRecursive3'


class RaceArgsFromMagicItemRecursive3(TypedDict, total=False):
    """Arguments for MagicItem"""
    include: 'RaceIncludeFromRaceRecursive4'


class RaceArgsFromMagicItemRecursive4(TypedDict, total=False):
    """Arguments for MagicItem"""
    
    

class FindManyRaceArgsFromMagicItem(TypedDict, total=False):
    """Arguments for MagicItem"""
    take: int
    skip: int
    order_by: Union['RaceOrderByInput', List['RaceOrderByInput']]
    where: 'RaceWhereInput'
    cursor: 'RaceWhereUniqueInput'
    distinct: List['RaceScalarFieldKeys']
    include: 'RaceIncludeFromRaceRecursive1'


class FindManyRaceArgsFromMagicItemRecursive1(TypedDict, total=False):
    """Arguments for MagicItem"""
    take: int
    skip: int
    order_by: Union['RaceOrderByInput', List['RaceOrderByInput']]
    where: 'RaceWhereInput'
    cursor: 'RaceWhereUniqueInput'
    distinct: List['RaceScalarFieldKeys']
    include: 'RaceIncludeFromRaceRecursive2'


class FindManyRaceArgsFromMagicItemRecursive2(TypedDict, total=False):
    """Arguments for MagicItem"""
    take: int
    skip: int
    order_by: Union['RaceOrderByInput', List['RaceOrderByInput']]
    where: 'RaceWhereInput'
    cursor: 'RaceWhereUniqueInput'
    distinct: List['RaceScalarFieldKeys']
    include: 'RaceIncludeFromRaceRecursive3'


class FindManyRaceArgsFromMagicItemRecursive3(TypedDict, total=False):
    """Arguments for MagicItem"""
    take: int
    skip: int
    order_by: Union['RaceOrderByInput', List['RaceOrderByInput']]
    where: 'RaceWhereInput'
    cursor: 'RaceWhereUniqueInput'
    distinct: List['RaceScalarFieldKeys']
    include: 'RaceIncludeFromRaceRecursive4'


class FindManyRaceArgsFromMagicItemRecursive4(TypedDict, total=False):
    """Arguments for MagicItem"""
    take: int
    skip: int
    order_by: Union['RaceOrderByInput', List['RaceOrderByInput']]
    where: 'RaceWhereInput'
    cursor: 'RaceWhereUniqueInput'
    distinct: List['RaceScalarFieldKeys']
    
    

class SpellIncludeFromMagicItem(TypedDict, total=False):
    """Relational arguments for MagicItem"""


class SpellIncludeFromMagicItemRecursive1(TypedDict, total=False):
    """Relational arguments for MagicItem"""


class SpellIncludeFromMagicItemRecursive2(TypedDict, total=False):
    """Relational arguments for MagicItem"""


class SpellIncludeFromMagicItemRecursive3(TypedDict, total=False):
    """Relational arguments for MagicItem"""


class SpellIncludeFromMagicItemRecursive4(TypedDict, total=False):
    """Relational arguments for MagicItem"""

    

class SpellArgsFromMagicItem(TypedDict, total=False):
    """Arguments for MagicItem"""
    include: 'SpellIncludeFromSpellRecursive1'


class SpellArgsFromMagicItemRecursive1(TypedDict, total=False):
    """Arguments for MagicItem"""
    include: 'SpellIncludeFromSpellRecursive2'


class SpellArgsFromMagicItemRecursive2(TypedDict, total=False):
    """Arguments for MagicItem"""
    include: 'SpellIncludeFromSpellRecursive3'


class SpellArgsFromMagicItemRecursive3(TypedDict, total=False):
    """Arguments for MagicItem"""
    include: 'SpellIncludeFromSpellRecursive4'


class SpellArgsFromMagicItemRecursive4(TypedDict, total=False):
    """Arguments for MagicItem"""
    
    

class FindManySpellArgsFromMagicItem(TypedDict, total=False):
    """Arguments for MagicItem"""
    take: int
    skip: int
    order_by: Union['SpellOrderByInput', List['SpellOrderByInput']]
    where: 'SpellWhereInput'
    cursor: 'SpellWhereUniqueInput'
    distinct: List['SpellScalarFieldKeys']
    include: 'SpellIncludeFromSpellRecursive1'


class FindManySpellArgsFromMagicItemRecursive1(TypedDict, total=False):
    """Arguments for MagicItem"""
    take: int
    skip: int
    order_by: Union['SpellOrderByInput', List['SpellOrderByInput']]
    where: 'SpellWhereInput'
    cursor: 'SpellWhereUniqueInput'
    distinct: List['SpellScalarFieldKeys']
    include: 'SpellIncludeFromSpellRecursive2'


class FindManySpellArgsFromMagicItemRecursive2(TypedDict, total=False):
    """Arguments for MagicItem"""
    take: int
    skip: int
    order_by: Union['SpellOrderByInput', List['SpellOrderByInput']]
    where: 'SpellWhereInput'
    cursor: 'SpellWhereUniqueInput'
    distinct: List['SpellScalarFieldKeys']
    include: 'SpellIncludeFromSpellRecursive3'


class FindManySpellArgsFromMagicItemRecursive3(TypedDict, total=False):
    """Arguments for MagicItem"""
    take: int
    skip: int
    order_by: Union['SpellOrderByInput', List['SpellOrderByInput']]
    where: 'SpellWhereInput'
    cursor: 'SpellWhereUniqueInput'
    distinct: List['SpellScalarFieldKeys']
    include: 'SpellIncludeFromSpellRecursive4'


class FindManySpellArgsFromMagicItemRecursive4(TypedDict, total=False):
    """Arguments for MagicItem"""
    take: int
    skip: int
    order_by: Union['SpellOrderByInput', List['SpellOrderByInput']]
    where: 'SpellWhereInput'
    cursor: 'SpellWhereUniqueInput'
    distinct: List['SpellScalarFieldKeys']
    
    

class PlayerClassIncludeFromMagicItem(TypedDict, total=False):
    """Relational arguments for MagicItem"""


class PlayerClassIncludeFromMagicItemRecursive1(TypedDict, total=False):
    """Relational arguments for MagicItem"""


class PlayerClassIncludeFromMagicItemRecursive2(TypedDict, total=False):
    """Relational arguments for MagicItem"""


class PlayerClassIncludeFromMagicItemRecursive3(TypedDict, total=False):
    """Relational arguments for MagicItem"""


class PlayerClassIncludeFromMagicItemRecursive4(TypedDict, total=False):
    """Relational arguments for MagicItem"""

    

class PlayerClassArgsFromMagicItem(TypedDict, total=False):
    """Arguments for MagicItem"""
    include: 'PlayerClassIncludeFromPlayerClassRecursive1'


class PlayerClassArgsFromMagicItemRecursive1(TypedDict, total=False):
    """Arguments for MagicItem"""
    include: 'PlayerClassIncludeFromPlayerClassRecursive2'


class PlayerClassArgsFromMagicItemRecursive2(TypedDict, total=False):
    """Arguments for MagicItem"""
    include: 'PlayerClassIncludeFromPlayerClassRecursive3'


class PlayerClassArgsFromMagicItemRecursive3(TypedDict, total=False):
    """Arguments for MagicItem"""
    include: 'PlayerClassIncludeFromPlayerClassRecursive4'


class PlayerClassArgsFromMagicItemRecursive4(TypedDict, total=False):
    """Arguments for MagicItem"""
    
    

class FindManyPlayerClassArgsFromMagicItem(TypedDict, total=False):
    """Arguments for MagicItem"""
    take: int
    skip: int
    order_by: Union['PlayerClassOrderByInput', List['PlayerClassOrderByInput']]
    where: 'PlayerClassWhereInput'
    cursor: 'PlayerClassWhereUniqueInput'
    distinct: List['PlayerClassScalarFieldKeys']
    include: 'PlayerClassIncludeFromPlayerClassRecursive1'


class FindManyPlayerClassArgsFromMagicItemRecursive1(TypedDict, total=False):
    """Arguments for MagicItem"""
    take: int
    skip: int
    order_by: Union['PlayerClassOrderByInput', List['PlayerClassOrderByInput']]
    where: 'PlayerClassWhereInput'
    cursor: 'PlayerClassWhereUniqueInput'
    distinct: List['PlayerClassScalarFieldKeys']
    include: 'PlayerClassIncludeFromPlayerClassRecursive2'


class FindManyPlayerClassArgsFromMagicItemRecursive2(TypedDict, total=False):
    """Arguments for MagicItem"""
    take: int
    skip: int
    order_by: Union['PlayerClassOrderByInput', List['PlayerClassOrderByInput']]
    where: 'PlayerClassWhereInput'
    cursor: 'PlayerClassWhereUniqueInput'
    distinct: List['PlayerClassScalarFieldKeys']
    include: 'PlayerClassIncludeFromPlayerClassRecursive3'


class FindManyPlayerClassArgsFromMagicItemRecursive3(TypedDict, total=False):
    """Arguments for MagicItem"""
    take: int
    skip: int
    order_by: Union['PlayerClassOrderByInput', List['PlayerClassOrderByInput']]
    where: 'PlayerClassWhereInput'
    cursor: 'PlayerClassWhereUniqueInput'
    distinct: List['PlayerClassScalarFieldKeys']
    include: 'PlayerClassIncludeFromPlayerClassRecursive4'


class FindManyPlayerClassArgsFromMagicItemRecursive4(TypedDict, total=False):
    """Arguments for MagicItem"""
    take: int
    skip: int
    order_by: Union['PlayerClassOrderByInput', List['PlayerClassOrderByInput']]
    where: 'PlayerClassWhereInput'
    cursor: 'PlayerClassWhereUniqueInput'
    distinct: List['PlayerClassScalarFieldKeys']
    
    

class MagicItemIncludeFromMagicItem(TypedDict, total=False):
    """Relational arguments for MagicItem"""


class MagicItemIncludeFromMagicItemRecursive1(TypedDict, total=False):
    """Relational arguments for MagicItem"""


class MagicItemIncludeFromMagicItemRecursive2(TypedDict, total=False):
    """Relational arguments for MagicItem"""


class MagicItemIncludeFromMagicItemRecursive3(TypedDict, total=False):
    """Relational arguments for MagicItem"""


class MagicItemIncludeFromMagicItemRecursive4(TypedDict, total=False):
    """Relational arguments for MagicItem"""

    

class MagicItemArgsFromMagicItem(TypedDict, total=False):
    """Arguments for MagicItem"""
    include: 'MagicItemIncludeFromMagicItemRecursive1'


class MagicItemArgsFromMagicItemRecursive1(TypedDict, total=False):
    """Arguments for MagicItem"""
    include: 'MagicItemIncludeFromMagicItemRecursive2'


class MagicItemArgsFromMagicItemRecursive2(TypedDict, total=False):
    """Arguments for MagicItem"""
    include: 'MagicItemIncludeFromMagicItemRecursive3'


class MagicItemArgsFromMagicItemRecursive3(TypedDict, total=False):
    """Arguments for MagicItem"""
    include: 'MagicItemIncludeFromMagicItemRecursive4'


class MagicItemArgsFromMagicItemRecursive4(TypedDict, total=False):
    """Arguments for MagicItem"""
    
    

class FindManyMagicItemArgsFromMagicItem(TypedDict, total=False):
    """Arguments for MagicItem"""
    take: int
    skip: int
    order_by: Union['MagicItemOrderByInput', List['MagicItemOrderByInput']]
    where: 'MagicItemWhereInput'
    cursor: 'MagicItemWhereUniqueInput'
    distinct: List['MagicItemScalarFieldKeys']
    include: 'MagicItemIncludeFromMagicItemRecursive1'


class FindManyMagicItemArgsFromMagicItemRecursive1(TypedDict, total=False):
    """Arguments for MagicItem"""
    take: int
    skip: int
    order_by: Union['MagicItemOrderByInput', List['MagicItemOrderByInput']]
    where: 'MagicItemWhereInput'
    cursor: 'MagicItemWhereUniqueInput'
    distinct: List['MagicItemScalarFieldKeys']
    include: 'MagicItemIncludeFromMagicItemRecursive2'


class FindManyMagicItemArgsFromMagicItemRecursive2(TypedDict, total=False):
    """Arguments for MagicItem"""
    take: int
    skip: int
    order_by: Union['MagicItemOrderByInput', List['MagicItemOrderByInput']]
    where: 'MagicItemWhereInput'
    cursor: 'MagicItemWhereUniqueInput'
    distinct: List['MagicItemScalarFieldKeys']
    include: 'MagicItemIncludeFromMagicItemRecursive3'


class FindManyMagicItemArgsFromMagicItemRecursive3(TypedDict, total=False):
    """Arguments for MagicItem"""
    take: int
    skip: int
    order_by: Union['MagicItemOrderByInput', List['MagicItemOrderByInput']]
    where: 'MagicItemWhereInput'
    cursor: 'MagicItemWhereUniqueInput'
    distinct: List['MagicItemScalarFieldKeys']
    include: 'MagicItemIncludeFromMagicItemRecursive4'


class FindManyMagicItemArgsFromMagicItemRecursive4(TypedDict, total=False):
    """Arguments for MagicItem"""
    take: int
    skip: int
    order_by: Union['MagicItemOrderByInput', List['MagicItemOrderByInput']]
    where: 'MagicItemWhereInput'
    cursor: 'MagicItemWhereUniqueInput'
    distinct: List['MagicItemScalarFieldKeys']
    
    

class GeneralEquipmentIncludeFromMagicItem(TypedDict, total=False):
    """Relational arguments for MagicItem"""


class GeneralEquipmentIncludeFromMagicItemRecursive1(TypedDict, total=False):
    """Relational arguments for MagicItem"""


class GeneralEquipmentIncludeFromMagicItemRecursive2(TypedDict, total=False):
    """Relational arguments for MagicItem"""


class GeneralEquipmentIncludeFromMagicItemRecursive3(TypedDict, total=False):
    """Relational arguments for MagicItem"""


class GeneralEquipmentIncludeFromMagicItemRecursive4(TypedDict, total=False):
    """Relational arguments for MagicItem"""

    

class GeneralEquipmentArgsFromMagicItem(TypedDict, total=False):
    """Arguments for MagicItem"""
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive1'


class GeneralEquipmentArgsFromMagicItemRecursive1(TypedDict, total=False):
    """Arguments for MagicItem"""
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive2'


class GeneralEquipmentArgsFromMagicItemRecursive2(TypedDict, total=False):
    """Arguments for MagicItem"""
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive3'


class GeneralEquipmentArgsFromMagicItemRecursive3(TypedDict, total=False):
    """Arguments for MagicItem"""
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive4'


class GeneralEquipmentArgsFromMagicItemRecursive4(TypedDict, total=False):
    """Arguments for MagicItem"""
    
    

class FindManyGeneralEquipmentArgsFromMagicItem(TypedDict, total=False):
    """Arguments for MagicItem"""
    take: int
    skip: int
    order_by: Union['GeneralEquipmentOrderByInput', List['GeneralEquipmentOrderByInput']]
    where: 'GeneralEquipmentWhereInput'
    cursor: 'GeneralEquipmentWhereUniqueInput'
    distinct: List['GeneralEquipmentScalarFieldKeys']
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive1'


class FindManyGeneralEquipmentArgsFromMagicItemRecursive1(TypedDict, total=False):
    """Arguments for MagicItem"""
    take: int
    skip: int
    order_by: Union['GeneralEquipmentOrderByInput', List['GeneralEquipmentOrderByInput']]
    where: 'GeneralEquipmentWhereInput'
    cursor: 'GeneralEquipmentWhereUniqueInput'
    distinct: List['GeneralEquipmentScalarFieldKeys']
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive2'


class FindManyGeneralEquipmentArgsFromMagicItemRecursive2(TypedDict, total=False):
    """Arguments for MagicItem"""
    take: int
    skip: int
    order_by: Union['GeneralEquipmentOrderByInput', List['GeneralEquipmentOrderByInput']]
    where: 'GeneralEquipmentWhereInput'
    cursor: 'GeneralEquipmentWhereUniqueInput'
    distinct: List['GeneralEquipmentScalarFieldKeys']
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive3'


class FindManyGeneralEquipmentArgsFromMagicItemRecursive3(TypedDict, total=False):
    """Arguments for MagicItem"""
    take: int
    skip: int
    order_by: Union['GeneralEquipmentOrderByInput', List['GeneralEquipmentOrderByInput']]
    where: 'GeneralEquipmentWhereInput'
    cursor: 'GeneralEquipmentWhereUniqueInput'
    distinct: List['GeneralEquipmentScalarFieldKeys']
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive4'


class FindManyGeneralEquipmentArgsFromMagicItemRecursive4(TypedDict, total=False):
    """Arguments for MagicItem"""
    take: int
    skip: int
    order_by: Union['GeneralEquipmentOrderByInput', List['GeneralEquipmentOrderByInput']]
    where: 'GeneralEquipmentWhereInput'
    cursor: 'GeneralEquipmentWhereUniqueInput'
    distinct: List['GeneralEquipmentScalarFieldKeys']
    


FindManyMagicItemArgs = FindManyMagicItemArgsFromMagicItem
FindFirstMagicItemArgs = FindManyMagicItemArgsFromMagicItem


    

class MagicItemWhereInput(TypedDict, total=False):
    """MagicItem arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    rarity: Union[None, _str, 'types.StringFilter']
    attunement: Union[None, _str, 'types.StringFilter']
    costGp: Union[None, _int, 'types.IntFilter']
    note: Union[None, _str, 'types.StringFilter']
    armorCost: Union[None, _int, 'types.IntFilter']
    rareMaterial: Union[None, _str, 'types.StringFilter']
    acBonus: Union[None, _int, 'types.IntFilter']
    saveBonus: Union[None, _int, 'types.IntFilter']
    setScoreModifier: Union[None, _int, 'types.IntFilter']
    plusTwoBonusToScore: Union[None, _str, 'types.StringFilter']
    weaponBonus: Union[None, _int, 'types.IntFilter']
    spellLevel: Union[None, _int, 'types.IntFilter']
    unlimitedCharges: Union[None, _str, 'types.StringFilter']
    chargesPerDay: Union[None, _int, 'types.IntFilter']
    chargesPerItem: Union[None, _int, 'types.IntFilter']
    spellsShareCharges: Union[None, _int, 'types.IntFilter']
    condition: Union[None, _str, 'types.StringFilter']
    consumableDamageAvg: Union[None, _int, 'types.IntFilter']
    consumableSave: Union[None, _str, 'types.StringFilter']
    semiPermanentDamageAvg: Union[None, _int, 'types.IntFilter']
    semiPermSave: Union[None, _str, 'types.StringFilter']
    durationMinutes: Union[None, _int, 'types.IntFilter']
    permanentDamageAvg: Union[None, _int, 'types.IntFilter']
    permSave: Union[None, _str, 'types.StringFilter']
    specificSituations: Union[None, _str, 'types.StringFilter']
    restoreHpAvg: Union[None, _int, 'types.IntFilter']
    miscCosts: Union[None, _int, 'types.IntFilter']
    secondSpellLevel: Union[None, _int, 'types.IntFilter']
    secondUnlimitedCharges: Union[None, _str, 'types.StringFilter']
    secondChargesPerDay: Union[None, _int, 'types.IntFilter']
    thirdSpellLevel: Union[None, _int, 'types.IntFilter']
    thirdUnlimitedCharges: Union[None, _str, 'types.StringFilter']
    thirdChargesPerDay: Union[None, _int, 'types.IntFilter']
    matCost: Union[None, _int, 'types.IntFilter']
    acCost: Union[None, _int, 'types.IntFilter']
    saveCost: Union[None, _int, 'types.IntFilter']
    setScoreCost: Union[None, _int, 'types.IntFilter']
    bonusScoreCost: Union[None, _int, 'types.IntFilter']
    weaponCost: Union[None, _int, 'types.IntFilter']
    consumSpellCost: Union[None, _int, 'types.IntFilter']
    permChargesCost: Union[None, _int, 'types.IntFilter']
    chargesDestroyed: Union[None, _int, 'types.IntFilter']
    spellShareChargesCost: Union[None, _int, 'types.IntFilter']
    conditionCost: Union[None, _int, 'types.IntFilter']
    consDMGCost: Union[None, _int, 'types.IntFilter']
    smPrDMGCost: Union[None, _int, 'types.IntFilter']
    perDMGCost: Union[None, _int, 'types.IntFilter']
    avgHPCost: Union[None, _int, 'types.IntFilter']
    miscCost: Union[None, _int, 'types.IntFilter']
    secondConsumSpellCost: Union[None, _int, 'types.IntFilter']
    secondPermChargesCost: Union[None, _int, 'types.IntFilter']
    thirdConsumSpellCost: Union[None, _int, 'types.IntFilter']
    thirdPermChargesCost: Union[None, _int, 'types.IntFilter']

    # should be noted that AND and NOT should be Union['MagicItemWhereInputRecursive1', List['MagicItemWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['MagicItemWhereInputRecursive1']
    OR: List['MagicItemWhereInputRecursive1']
    NOT: List['MagicItemWhereInputRecursive1']


class MagicItemWhereInputRecursive1(TypedDict, total=False):
    """MagicItem arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    rarity: Union[None, _str, 'types.StringFilter']
    attunement: Union[None, _str, 'types.StringFilter']
    costGp: Union[None, _int, 'types.IntFilter']
    note: Union[None, _str, 'types.StringFilter']
    armorCost: Union[None, _int, 'types.IntFilter']
    rareMaterial: Union[None, _str, 'types.StringFilter']
    acBonus: Union[None, _int, 'types.IntFilter']
    saveBonus: Union[None, _int, 'types.IntFilter']
    setScoreModifier: Union[None, _int, 'types.IntFilter']
    plusTwoBonusToScore: Union[None, _str, 'types.StringFilter']
    weaponBonus: Union[None, _int, 'types.IntFilter']
    spellLevel: Union[None, _int, 'types.IntFilter']
    unlimitedCharges: Union[None, _str, 'types.StringFilter']
    chargesPerDay: Union[None, _int, 'types.IntFilter']
    chargesPerItem: Union[None, _int, 'types.IntFilter']
    spellsShareCharges: Union[None, _int, 'types.IntFilter']
    condition: Union[None, _str, 'types.StringFilter']
    consumableDamageAvg: Union[None, _int, 'types.IntFilter']
    consumableSave: Union[None, _str, 'types.StringFilter']
    semiPermanentDamageAvg: Union[None, _int, 'types.IntFilter']
    semiPermSave: Union[None, _str, 'types.StringFilter']
    durationMinutes: Union[None, _int, 'types.IntFilter']
    permanentDamageAvg: Union[None, _int, 'types.IntFilter']
    permSave: Union[None, _str, 'types.StringFilter']
    specificSituations: Union[None, _str, 'types.StringFilter']
    restoreHpAvg: Union[None, _int, 'types.IntFilter']
    miscCosts: Union[None, _int, 'types.IntFilter']
    secondSpellLevel: Union[None, _int, 'types.IntFilter']
    secondUnlimitedCharges: Union[None, _str, 'types.StringFilter']
    secondChargesPerDay: Union[None, _int, 'types.IntFilter']
    thirdSpellLevel: Union[None, _int, 'types.IntFilter']
    thirdUnlimitedCharges: Union[None, _str, 'types.StringFilter']
    thirdChargesPerDay: Union[None, _int, 'types.IntFilter']
    matCost: Union[None, _int, 'types.IntFilter']
    acCost: Union[None, _int, 'types.IntFilter']
    saveCost: Union[None, _int, 'types.IntFilter']
    setScoreCost: Union[None, _int, 'types.IntFilter']
    bonusScoreCost: Union[None, _int, 'types.IntFilter']
    weaponCost: Union[None, _int, 'types.IntFilter']
    consumSpellCost: Union[None, _int, 'types.IntFilter']
    permChargesCost: Union[None, _int, 'types.IntFilter']
    chargesDestroyed: Union[None, _int, 'types.IntFilter']
    spellShareChargesCost: Union[None, _int, 'types.IntFilter']
    conditionCost: Union[None, _int, 'types.IntFilter']
    consDMGCost: Union[None, _int, 'types.IntFilter']
    smPrDMGCost: Union[None, _int, 'types.IntFilter']
    perDMGCost: Union[None, _int, 'types.IntFilter']
    avgHPCost: Union[None, _int, 'types.IntFilter']
    miscCost: Union[None, _int, 'types.IntFilter']
    secondConsumSpellCost: Union[None, _int, 'types.IntFilter']
    secondPermChargesCost: Union[None, _int, 'types.IntFilter']
    thirdConsumSpellCost: Union[None, _int, 'types.IntFilter']
    thirdPermChargesCost: Union[None, _int, 'types.IntFilter']

    # should be noted that AND and NOT should be Union['MagicItemWhereInputRecursive2', List['MagicItemWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['MagicItemWhereInputRecursive2']
    OR: List['MagicItemWhereInputRecursive2']
    NOT: List['MagicItemWhereInputRecursive2']


class MagicItemWhereInputRecursive2(TypedDict, total=False):
    """MagicItem arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    rarity: Union[None, _str, 'types.StringFilter']
    attunement: Union[None, _str, 'types.StringFilter']
    costGp: Union[None, _int, 'types.IntFilter']
    note: Union[None, _str, 'types.StringFilter']
    armorCost: Union[None, _int, 'types.IntFilter']
    rareMaterial: Union[None, _str, 'types.StringFilter']
    acBonus: Union[None, _int, 'types.IntFilter']
    saveBonus: Union[None, _int, 'types.IntFilter']
    setScoreModifier: Union[None, _int, 'types.IntFilter']
    plusTwoBonusToScore: Union[None, _str, 'types.StringFilter']
    weaponBonus: Union[None, _int, 'types.IntFilter']
    spellLevel: Union[None, _int, 'types.IntFilter']
    unlimitedCharges: Union[None, _str, 'types.StringFilter']
    chargesPerDay: Union[None, _int, 'types.IntFilter']
    chargesPerItem: Union[None, _int, 'types.IntFilter']
    spellsShareCharges: Union[None, _int, 'types.IntFilter']
    condition: Union[None, _str, 'types.StringFilter']
    consumableDamageAvg: Union[None, _int, 'types.IntFilter']
    consumableSave: Union[None, _str, 'types.StringFilter']
    semiPermanentDamageAvg: Union[None, _int, 'types.IntFilter']
    semiPermSave: Union[None, _str, 'types.StringFilter']
    durationMinutes: Union[None, _int, 'types.IntFilter']
    permanentDamageAvg: Union[None, _int, 'types.IntFilter']
    permSave: Union[None, _str, 'types.StringFilter']
    specificSituations: Union[None, _str, 'types.StringFilter']
    restoreHpAvg: Union[None, _int, 'types.IntFilter']
    miscCosts: Union[None, _int, 'types.IntFilter']
    secondSpellLevel: Union[None, _int, 'types.IntFilter']
    secondUnlimitedCharges: Union[None, _str, 'types.StringFilter']
    secondChargesPerDay: Union[None, _int, 'types.IntFilter']
    thirdSpellLevel: Union[None, _int, 'types.IntFilter']
    thirdUnlimitedCharges: Union[None, _str, 'types.StringFilter']
    thirdChargesPerDay: Union[None, _int, 'types.IntFilter']
    matCost: Union[None, _int, 'types.IntFilter']
    acCost: Union[None, _int, 'types.IntFilter']
    saveCost: Union[None, _int, 'types.IntFilter']
    setScoreCost: Union[None, _int, 'types.IntFilter']
    bonusScoreCost: Union[None, _int, 'types.IntFilter']
    weaponCost: Union[None, _int, 'types.IntFilter']
    consumSpellCost: Union[None, _int, 'types.IntFilter']
    permChargesCost: Union[None, _int, 'types.IntFilter']
    chargesDestroyed: Union[None, _int, 'types.IntFilter']
    spellShareChargesCost: Union[None, _int, 'types.IntFilter']
    conditionCost: Union[None, _int, 'types.IntFilter']
    consDMGCost: Union[None, _int, 'types.IntFilter']
    smPrDMGCost: Union[None, _int, 'types.IntFilter']
    perDMGCost: Union[None, _int, 'types.IntFilter']
    avgHPCost: Union[None, _int, 'types.IntFilter']
    miscCost: Union[None, _int, 'types.IntFilter']
    secondConsumSpellCost: Union[None, _int, 'types.IntFilter']
    secondPermChargesCost: Union[None, _int, 'types.IntFilter']
    thirdConsumSpellCost: Union[None, _int, 'types.IntFilter']
    thirdPermChargesCost: Union[None, _int, 'types.IntFilter']

    # should be noted that AND and NOT should be Union['MagicItemWhereInputRecursive3', List['MagicItemWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['MagicItemWhereInputRecursive3']
    OR: List['MagicItemWhereInputRecursive3']
    NOT: List['MagicItemWhereInputRecursive3']


class MagicItemWhereInputRecursive3(TypedDict, total=False):
    """MagicItem arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    rarity: Union[None, _str, 'types.StringFilter']
    attunement: Union[None, _str, 'types.StringFilter']
    costGp: Union[None, _int, 'types.IntFilter']
    note: Union[None, _str, 'types.StringFilter']
    armorCost: Union[None, _int, 'types.IntFilter']
    rareMaterial: Union[None, _str, 'types.StringFilter']
    acBonus: Union[None, _int, 'types.IntFilter']
    saveBonus: Union[None, _int, 'types.IntFilter']
    setScoreModifier: Union[None, _int, 'types.IntFilter']
    plusTwoBonusToScore: Union[None, _str, 'types.StringFilter']
    weaponBonus: Union[None, _int, 'types.IntFilter']
    spellLevel: Union[None, _int, 'types.IntFilter']
    unlimitedCharges: Union[None, _str, 'types.StringFilter']
    chargesPerDay: Union[None, _int, 'types.IntFilter']
    chargesPerItem: Union[None, _int, 'types.IntFilter']
    spellsShareCharges: Union[None, _int, 'types.IntFilter']
    condition: Union[None, _str, 'types.StringFilter']
    consumableDamageAvg: Union[None, _int, 'types.IntFilter']
    consumableSave: Union[None, _str, 'types.StringFilter']
    semiPermanentDamageAvg: Union[None, _int, 'types.IntFilter']
    semiPermSave: Union[None, _str, 'types.StringFilter']
    durationMinutes: Union[None, _int, 'types.IntFilter']
    permanentDamageAvg: Union[None, _int, 'types.IntFilter']
    permSave: Union[None, _str, 'types.StringFilter']
    specificSituations: Union[None, _str, 'types.StringFilter']
    restoreHpAvg: Union[None, _int, 'types.IntFilter']
    miscCosts: Union[None, _int, 'types.IntFilter']
    secondSpellLevel: Union[None, _int, 'types.IntFilter']
    secondUnlimitedCharges: Union[None, _str, 'types.StringFilter']
    secondChargesPerDay: Union[None, _int, 'types.IntFilter']
    thirdSpellLevel: Union[None, _int, 'types.IntFilter']
    thirdUnlimitedCharges: Union[None, _str, 'types.StringFilter']
    thirdChargesPerDay: Union[None, _int, 'types.IntFilter']
    matCost: Union[None, _int, 'types.IntFilter']
    acCost: Union[None, _int, 'types.IntFilter']
    saveCost: Union[None, _int, 'types.IntFilter']
    setScoreCost: Union[None, _int, 'types.IntFilter']
    bonusScoreCost: Union[None, _int, 'types.IntFilter']
    weaponCost: Union[None, _int, 'types.IntFilter']
    consumSpellCost: Union[None, _int, 'types.IntFilter']
    permChargesCost: Union[None, _int, 'types.IntFilter']
    chargesDestroyed: Union[None, _int, 'types.IntFilter']
    spellShareChargesCost: Union[None, _int, 'types.IntFilter']
    conditionCost: Union[None, _int, 'types.IntFilter']
    consDMGCost: Union[None, _int, 'types.IntFilter']
    smPrDMGCost: Union[None, _int, 'types.IntFilter']
    perDMGCost: Union[None, _int, 'types.IntFilter']
    avgHPCost: Union[None, _int, 'types.IntFilter']
    miscCost: Union[None, _int, 'types.IntFilter']
    secondConsumSpellCost: Union[None, _int, 'types.IntFilter']
    secondPermChargesCost: Union[None, _int, 'types.IntFilter']
    thirdConsumSpellCost: Union[None, _int, 'types.IntFilter']
    thirdPermChargesCost: Union[None, _int, 'types.IntFilter']

    # should be noted that AND and NOT should be Union['MagicItemWhereInputRecursive4', List['MagicItemWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['MagicItemWhereInputRecursive4']
    OR: List['MagicItemWhereInputRecursive4']
    NOT: List['MagicItemWhereInputRecursive4']


class MagicItemWhereInputRecursive4(TypedDict, total=False):
    """MagicItem arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    rarity: Union[None, _str, 'types.StringFilter']
    attunement: Union[None, _str, 'types.StringFilter']
    costGp: Union[None, _int, 'types.IntFilter']
    note: Union[None, _str, 'types.StringFilter']
    armorCost: Union[None, _int, 'types.IntFilter']
    rareMaterial: Union[None, _str, 'types.StringFilter']
    acBonus: Union[None, _int, 'types.IntFilter']
    saveBonus: Union[None, _int, 'types.IntFilter']
    setScoreModifier: Union[None, _int, 'types.IntFilter']
    plusTwoBonusToScore: Union[None, _str, 'types.StringFilter']
    weaponBonus: Union[None, _int, 'types.IntFilter']
    spellLevel: Union[None, _int, 'types.IntFilter']
    unlimitedCharges: Union[None, _str, 'types.StringFilter']
    chargesPerDay: Union[None, _int, 'types.IntFilter']
    chargesPerItem: Union[None, _int, 'types.IntFilter']
    spellsShareCharges: Union[None, _int, 'types.IntFilter']
    condition: Union[None, _str, 'types.StringFilter']
    consumableDamageAvg: Union[None, _int, 'types.IntFilter']
    consumableSave: Union[None, _str, 'types.StringFilter']
    semiPermanentDamageAvg: Union[None, _int, 'types.IntFilter']
    semiPermSave: Union[None, _str, 'types.StringFilter']
    durationMinutes: Union[None, _int, 'types.IntFilter']
    permanentDamageAvg: Union[None, _int, 'types.IntFilter']
    permSave: Union[None, _str, 'types.StringFilter']
    specificSituations: Union[None, _str, 'types.StringFilter']
    restoreHpAvg: Union[None, _int, 'types.IntFilter']
    miscCosts: Union[None, _int, 'types.IntFilter']
    secondSpellLevel: Union[None, _int, 'types.IntFilter']
    secondUnlimitedCharges: Union[None, _str, 'types.StringFilter']
    secondChargesPerDay: Union[None, _int, 'types.IntFilter']
    thirdSpellLevel: Union[None, _int, 'types.IntFilter']
    thirdUnlimitedCharges: Union[None, _str, 'types.StringFilter']
    thirdChargesPerDay: Union[None, _int, 'types.IntFilter']
    matCost: Union[None, _int, 'types.IntFilter']
    acCost: Union[None, _int, 'types.IntFilter']
    saveCost: Union[None, _int, 'types.IntFilter']
    setScoreCost: Union[None, _int, 'types.IntFilter']
    bonusScoreCost: Union[None, _int, 'types.IntFilter']
    weaponCost: Union[None, _int, 'types.IntFilter']
    consumSpellCost: Union[None, _int, 'types.IntFilter']
    permChargesCost: Union[None, _int, 'types.IntFilter']
    chargesDestroyed: Union[None, _int, 'types.IntFilter']
    spellShareChargesCost: Union[None, _int, 'types.IntFilter']
    conditionCost: Union[None, _int, 'types.IntFilter']
    consDMGCost: Union[None, _int, 'types.IntFilter']
    smPrDMGCost: Union[None, _int, 'types.IntFilter']
    perDMGCost: Union[None, _int, 'types.IntFilter']
    avgHPCost: Union[None, _int, 'types.IntFilter']
    miscCost: Union[None, _int, 'types.IntFilter']
    secondConsumSpellCost: Union[None, _int, 'types.IntFilter']
    secondPermChargesCost: Union[None, _int, 'types.IntFilter']
    thirdConsumSpellCost: Union[None, _int, 'types.IntFilter']
    thirdPermChargesCost: Union[None, _int, 'types.IntFilter']



# aggregate MagicItem types


    

class MagicItemScalarWhereWithAggregatesInput(TypedDict, total=False):
    """MagicItem arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    rarity: Union[_str, 'types.StringWithAggregatesFilter']
    attunement: Union[_str, 'types.StringWithAggregatesFilter']
    costGp: Union[_int, 'types.IntWithAggregatesFilter']
    note: Union[_str, 'types.StringWithAggregatesFilter']
    armorCost: Union[_int, 'types.IntWithAggregatesFilter']
    rareMaterial: Union[_str, 'types.StringWithAggregatesFilter']
    acBonus: Union[_int, 'types.IntWithAggregatesFilter']
    saveBonus: Union[_int, 'types.IntWithAggregatesFilter']
    setScoreModifier: Union[_int, 'types.IntWithAggregatesFilter']
    plusTwoBonusToScore: Union[_str, 'types.StringWithAggregatesFilter']
    weaponBonus: Union[_int, 'types.IntWithAggregatesFilter']
    spellLevel: Union[_int, 'types.IntWithAggregatesFilter']
    unlimitedCharges: Union[_str, 'types.StringWithAggregatesFilter']
    chargesPerDay: Union[_int, 'types.IntWithAggregatesFilter']
    chargesPerItem: Union[_int, 'types.IntWithAggregatesFilter']
    spellsShareCharges: Union[_int, 'types.IntWithAggregatesFilter']
    condition: Union[_str, 'types.StringWithAggregatesFilter']
    consumableDamageAvg: Union[_int, 'types.IntWithAggregatesFilter']
    consumableSave: Union[_str, 'types.StringWithAggregatesFilter']
    semiPermanentDamageAvg: Union[_int, 'types.IntWithAggregatesFilter']
    semiPermSave: Union[_str, 'types.StringWithAggregatesFilter']
    durationMinutes: Union[_int, 'types.IntWithAggregatesFilter']
    permanentDamageAvg: Union[_int, 'types.IntWithAggregatesFilter']
    permSave: Union[_str, 'types.StringWithAggregatesFilter']
    specificSituations: Union[_str, 'types.StringWithAggregatesFilter']
    restoreHpAvg: Union[_int, 'types.IntWithAggregatesFilter']
    miscCosts: Union[_int, 'types.IntWithAggregatesFilter']
    secondSpellLevel: Union[_int, 'types.IntWithAggregatesFilter']
    secondUnlimitedCharges: Union[_str, 'types.StringWithAggregatesFilter']
    secondChargesPerDay: Union[_int, 'types.IntWithAggregatesFilter']
    thirdSpellLevel: Union[_int, 'types.IntWithAggregatesFilter']
    thirdUnlimitedCharges: Union[_str, 'types.StringWithAggregatesFilter']
    thirdChargesPerDay: Union[_int, 'types.IntWithAggregatesFilter']
    matCost: Union[_int, 'types.IntWithAggregatesFilter']
    acCost: Union[_int, 'types.IntWithAggregatesFilter']
    saveCost: Union[_int, 'types.IntWithAggregatesFilter']
    setScoreCost: Union[_int, 'types.IntWithAggregatesFilter']
    bonusScoreCost: Union[_int, 'types.IntWithAggregatesFilter']
    weaponCost: Union[_int, 'types.IntWithAggregatesFilter']
    consumSpellCost: Union[_int, 'types.IntWithAggregatesFilter']
    permChargesCost: Union[_int, 'types.IntWithAggregatesFilter']
    chargesDestroyed: Union[_int, 'types.IntWithAggregatesFilter']
    spellShareChargesCost: Union[_int, 'types.IntWithAggregatesFilter']
    conditionCost: Union[_int, 'types.IntWithAggregatesFilter']
    consDMGCost: Union[_int, 'types.IntWithAggregatesFilter']
    smPrDMGCost: Union[_int, 'types.IntWithAggregatesFilter']
    perDMGCost: Union[_int, 'types.IntWithAggregatesFilter']
    avgHPCost: Union[_int, 'types.IntWithAggregatesFilter']
    miscCost: Union[_int, 'types.IntWithAggregatesFilter']
    secondConsumSpellCost: Union[_int, 'types.IntWithAggregatesFilter']
    secondPermChargesCost: Union[_int, 'types.IntWithAggregatesFilter']
    thirdConsumSpellCost: Union[_int, 'types.IntWithAggregatesFilter']
    thirdPermChargesCost: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['MagicItemScalarWhereWithAggregatesInputRecursive1']
    OR: List['MagicItemScalarWhereWithAggregatesInputRecursive1']
    NOT: List['MagicItemScalarWhereWithAggregatesInputRecursive1']


class MagicItemScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """MagicItem arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    rarity: Union[_str, 'types.StringWithAggregatesFilter']
    attunement: Union[_str, 'types.StringWithAggregatesFilter']
    costGp: Union[_int, 'types.IntWithAggregatesFilter']
    note: Union[_str, 'types.StringWithAggregatesFilter']
    armorCost: Union[_int, 'types.IntWithAggregatesFilter']
    rareMaterial: Union[_str, 'types.StringWithAggregatesFilter']
    acBonus: Union[_int, 'types.IntWithAggregatesFilter']
    saveBonus: Union[_int, 'types.IntWithAggregatesFilter']
    setScoreModifier: Union[_int, 'types.IntWithAggregatesFilter']
    plusTwoBonusToScore: Union[_str, 'types.StringWithAggregatesFilter']
    weaponBonus: Union[_int, 'types.IntWithAggregatesFilter']
    spellLevel: Union[_int, 'types.IntWithAggregatesFilter']
    unlimitedCharges: Union[_str, 'types.StringWithAggregatesFilter']
    chargesPerDay: Union[_int, 'types.IntWithAggregatesFilter']
    chargesPerItem: Union[_int, 'types.IntWithAggregatesFilter']
    spellsShareCharges: Union[_int, 'types.IntWithAggregatesFilter']
    condition: Union[_str, 'types.StringWithAggregatesFilter']
    consumableDamageAvg: Union[_int, 'types.IntWithAggregatesFilter']
    consumableSave: Union[_str, 'types.StringWithAggregatesFilter']
    semiPermanentDamageAvg: Union[_int, 'types.IntWithAggregatesFilter']
    semiPermSave: Union[_str, 'types.StringWithAggregatesFilter']
    durationMinutes: Union[_int, 'types.IntWithAggregatesFilter']
    permanentDamageAvg: Union[_int, 'types.IntWithAggregatesFilter']
    permSave: Union[_str, 'types.StringWithAggregatesFilter']
    specificSituations: Union[_str, 'types.StringWithAggregatesFilter']
    restoreHpAvg: Union[_int, 'types.IntWithAggregatesFilter']
    miscCosts: Union[_int, 'types.IntWithAggregatesFilter']
    secondSpellLevel: Union[_int, 'types.IntWithAggregatesFilter']
    secondUnlimitedCharges: Union[_str, 'types.StringWithAggregatesFilter']
    secondChargesPerDay: Union[_int, 'types.IntWithAggregatesFilter']
    thirdSpellLevel: Union[_int, 'types.IntWithAggregatesFilter']
    thirdUnlimitedCharges: Union[_str, 'types.StringWithAggregatesFilter']
    thirdChargesPerDay: Union[_int, 'types.IntWithAggregatesFilter']
    matCost: Union[_int, 'types.IntWithAggregatesFilter']
    acCost: Union[_int, 'types.IntWithAggregatesFilter']
    saveCost: Union[_int, 'types.IntWithAggregatesFilter']
    setScoreCost: Union[_int, 'types.IntWithAggregatesFilter']
    bonusScoreCost: Union[_int, 'types.IntWithAggregatesFilter']
    weaponCost: Union[_int, 'types.IntWithAggregatesFilter']
    consumSpellCost: Union[_int, 'types.IntWithAggregatesFilter']
    permChargesCost: Union[_int, 'types.IntWithAggregatesFilter']
    chargesDestroyed: Union[_int, 'types.IntWithAggregatesFilter']
    spellShareChargesCost: Union[_int, 'types.IntWithAggregatesFilter']
    conditionCost: Union[_int, 'types.IntWithAggregatesFilter']
    consDMGCost: Union[_int, 'types.IntWithAggregatesFilter']
    smPrDMGCost: Union[_int, 'types.IntWithAggregatesFilter']
    perDMGCost: Union[_int, 'types.IntWithAggregatesFilter']
    avgHPCost: Union[_int, 'types.IntWithAggregatesFilter']
    miscCost: Union[_int, 'types.IntWithAggregatesFilter']
    secondConsumSpellCost: Union[_int, 'types.IntWithAggregatesFilter']
    secondPermChargesCost: Union[_int, 'types.IntWithAggregatesFilter']
    thirdConsumSpellCost: Union[_int, 'types.IntWithAggregatesFilter']
    thirdPermChargesCost: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['MagicItemScalarWhereWithAggregatesInputRecursive2']
    OR: List['MagicItemScalarWhereWithAggregatesInputRecursive2']
    NOT: List['MagicItemScalarWhereWithAggregatesInputRecursive2']


class MagicItemScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """MagicItem arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    rarity: Union[_str, 'types.StringWithAggregatesFilter']
    attunement: Union[_str, 'types.StringWithAggregatesFilter']
    costGp: Union[_int, 'types.IntWithAggregatesFilter']
    note: Union[_str, 'types.StringWithAggregatesFilter']
    armorCost: Union[_int, 'types.IntWithAggregatesFilter']
    rareMaterial: Union[_str, 'types.StringWithAggregatesFilter']
    acBonus: Union[_int, 'types.IntWithAggregatesFilter']
    saveBonus: Union[_int, 'types.IntWithAggregatesFilter']
    setScoreModifier: Union[_int, 'types.IntWithAggregatesFilter']
    plusTwoBonusToScore: Union[_str, 'types.StringWithAggregatesFilter']
    weaponBonus: Union[_int, 'types.IntWithAggregatesFilter']
    spellLevel: Union[_int, 'types.IntWithAggregatesFilter']
    unlimitedCharges: Union[_str, 'types.StringWithAggregatesFilter']
    chargesPerDay: Union[_int, 'types.IntWithAggregatesFilter']
    chargesPerItem: Union[_int, 'types.IntWithAggregatesFilter']
    spellsShareCharges: Union[_int, 'types.IntWithAggregatesFilter']
    condition: Union[_str, 'types.StringWithAggregatesFilter']
    consumableDamageAvg: Union[_int, 'types.IntWithAggregatesFilter']
    consumableSave: Union[_str, 'types.StringWithAggregatesFilter']
    semiPermanentDamageAvg: Union[_int, 'types.IntWithAggregatesFilter']
    semiPermSave: Union[_str, 'types.StringWithAggregatesFilter']
    durationMinutes: Union[_int, 'types.IntWithAggregatesFilter']
    permanentDamageAvg: Union[_int, 'types.IntWithAggregatesFilter']
    permSave: Union[_str, 'types.StringWithAggregatesFilter']
    specificSituations: Union[_str, 'types.StringWithAggregatesFilter']
    restoreHpAvg: Union[_int, 'types.IntWithAggregatesFilter']
    miscCosts: Union[_int, 'types.IntWithAggregatesFilter']
    secondSpellLevel: Union[_int, 'types.IntWithAggregatesFilter']
    secondUnlimitedCharges: Union[_str, 'types.StringWithAggregatesFilter']
    secondChargesPerDay: Union[_int, 'types.IntWithAggregatesFilter']
    thirdSpellLevel: Union[_int, 'types.IntWithAggregatesFilter']
    thirdUnlimitedCharges: Union[_str, 'types.StringWithAggregatesFilter']
    thirdChargesPerDay: Union[_int, 'types.IntWithAggregatesFilter']
    matCost: Union[_int, 'types.IntWithAggregatesFilter']
    acCost: Union[_int, 'types.IntWithAggregatesFilter']
    saveCost: Union[_int, 'types.IntWithAggregatesFilter']
    setScoreCost: Union[_int, 'types.IntWithAggregatesFilter']
    bonusScoreCost: Union[_int, 'types.IntWithAggregatesFilter']
    weaponCost: Union[_int, 'types.IntWithAggregatesFilter']
    consumSpellCost: Union[_int, 'types.IntWithAggregatesFilter']
    permChargesCost: Union[_int, 'types.IntWithAggregatesFilter']
    chargesDestroyed: Union[_int, 'types.IntWithAggregatesFilter']
    spellShareChargesCost: Union[_int, 'types.IntWithAggregatesFilter']
    conditionCost: Union[_int, 'types.IntWithAggregatesFilter']
    consDMGCost: Union[_int, 'types.IntWithAggregatesFilter']
    smPrDMGCost: Union[_int, 'types.IntWithAggregatesFilter']
    perDMGCost: Union[_int, 'types.IntWithAggregatesFilter']
    avgHPCost: Union[_int, 'types.IntWithAggregatesFilter']
    miscCost: Union[_int, 'types.IntWithAggregatesFilter']
    secondConsumSpellCost: Union[_int, 'types.IntWithAggregatesFilter']
    secondPermChargesCost: Union[_int, 'types.IntWithAggregatesFilter']
    thirdConsumSpellCost: Union[_int, 'types.IntWithAggregatesFilter']
    thirdPermChargesCost: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['MagicItemScalarWhereWithAggregatesInputRecursive3']
    OR: List['MagicItemScalarWhereWithAggregatesInputRecursive3']
    NOT: List['MagicItemScalarWhereWithAggregatesInputRecursive3']


class MagicItemScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """MagicItem arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    rarity: Union[_str, 'types.StringWithAggregatesFilter']
    attunement: Union[_str, 'types.StringWithAggregatesFilter']
    costGp: Union[_int, 'types.IntWithAggregatesFilter']
    note: Union[_str, 'types.StringWithAggregatesFilter']
    armorCost: Union[_int, 'types.IntWithAggregatesFilter']
    rareMaterial: Union[_str, 'types.StringWithAggregatesFilter']
    acBonus: Union[_int, 'types.IntWithAggregatesFilter']
    saveBonus: Union[_int, 'types.IntWithAggregatesFilter']
    setScoreModifier: Union[_int, 'types.IntWithAggregatesFilter']
    plusTwoBonusToScore: Union[_str, 'types.StringWithAggregatesFilter']
    weaponBonus: Union[_int, 'types.IntWithAggregatesFilter']
    spellLevel: Union[_int, 'types.IntWithAggregatesFilter']
    unlimitedCharges: Union[_str, 'types.StringWithAggregatesFilter']
    chargesPerDay: Union[_int, 'types.IntWithAggregatesFilter']
    chargesPerItem: Union[_int, 'types.IntWithAggregatesFilter']
    spellsShareCharges: Union[_int, 'types.IntWithAggregatesFilter']
    condition: Union[_str, 'types.StringWithAggregatesFilter']
    consumableDamageAvg: Union[_int, 'types.IntWithAggregatesFilter']
    consumableSave: Union[_str, 'types.StringWithAggregatesFilter']
    semiPermanentDamageAvg: Union[_int, 'types.IntWithAggregatesFilter']
    semiPermSave: Union[_str, 'types.StringWithAggregatesFilter']
    durationMinutes: Union[_int, 'types.IntWithAggregatesFilter']
    permanentDamageAvg: Union[_int, 'types.IntWithAggregatesFilter']
    permSave: Union[_str, 'types.StringWithAggregatesFilter']
    specificSituations: Union[_str, 'types.StringWithAggregatesFilter']
    restoreHpAvg: Union[_int, 'types.IntWithAggregatesFilter']
    miscCosts: Union[_int, 'types.IntWithAggregatesFilter']
    secondSpellLevel: Union[_int, 'types.IntWithAggregatesFilter']
    secondUnlimitedCharges: Union[_str, 'types.StringWithAggregatesFilter']
    secondChargesPerDay: Union[_int, 'types.IntWithAggregatesFilter']
    thirdSpellLevel: Union[_int, 'types.IntWithAggregatesFilter']
    thirdUnlimitedCharges: Union[_str, 'types.StringWithAggregatesFilter']
    thirdChargesPerDay: Union[_int, 'types.IntWithAggregatesFilter']
    matCost: Union[_int, 'types.IntWithAggregatesFilter']
    acCost: Union[_int, 'types.IntWithAggregatesFilter']
    saveCost: Union[_int, 'types.IntWithAggregatesFilter']
    setScoreCost: Union[_int, 'types.IntWithAggregatesFilter']
    bonusScoreCost: Union[_int, 'types.IntWithAggregatesFilter']
    weaponCost: Union[_int, 'types.IntWithAggregatesFilter']
    consumSpellCost: Union[_int, 'types.IntWithAggregatesFilter']
    permChargesCost: Union[_int, 'types.IntWithAggregatesFilter']
    chargesDestroyed: Union[_int, 'types.IntWithAggregatesFilter']
    spellShareChargesCost: Union[_int, 'types.IntWithAggregatesFilter']
    conditionCost: Union[_int, 'types.IntWithAggregatesFilter']
    consDMGCost: Union[_int, 'types.IntWithAggregatesFilter']
    smPrDMGCost: Union[_int, 'types.IntWithAggregatesFilter']
    perDMGCost: Union[_int, 'types.IntWithAggregatesFilter']
    avgHPCost: Union[_int, 'types.IntWithAggregatesFilter']
    miscCost: Union[_int, 'types.IntWithAggregatesFilter']
    secondConsumSpellCost: Union[_int, 'types.IntWithAggregatesFilter']
    secondPermChargesCost: Union[_int, 'types.IntWithAggregatesFilter']
    thirdConsumSpellCost: Union[_int, 'types.IntWithAggregatesFilter']
    thirdPermChargesCost: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['MagicItemScalarWhereWithAggregatesInputRecursive4']
    OR: List['MagicItemScalarWhereWithAggregatesInputRecursive4']
    NOT: List['MagicItemScalarWhereWithAggregatesInputRecursive4']


class MagicItemScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """MagicItem arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    rarity: Union[_str, 'types.StringWithAggregatesFilter']
    attunement: Union[_str, 'types.StringWithAggregatesFilter']
    costGp: Union[_int, 'types.IntWithAggregatesFilter']
    note: Union[_str, 'types.StringWithAggregatesFilter']
    armorCost: Union[_int, 'types.IntWithAggregatesFilter']
    rareMaterial: Union[_str, 'types.StringWithAggregatesFilter']
    acBonus: Union[_int, 'types.IntWithAggregatesFilter']
    saveBonus: Union[_int, 'types.IntWithAggregatesFilter']
    setScoreModifier: Union[_int, 'types.IntWithAggregatesFilter']
    plusTwoBonusToScore: Union[_str, 'types.StringWithAggregatesFilter']
    weaponBonus: Union[_int, 'types.IntWithAggregatesFilter']
    spellLevel: Union[_int, 'types.IntWithAggregatesFilter']
    unlimitedCharges: Union[_str, 'types.StringWithAggregatesFilter']
    chargesPerDay: Union[_int, 'types.IntWithAggregatesFilter']
    chargesPerItem: Union[_int, 'types.IntWithAggregatesFilter']
    spellsShareCharges: Union[_int, 'types.IntWithAggregatesFilter']
    condition: Union[_str, 'types.StringWithAggregatesFilter']
    consumableDamageAvg: Union[_int, 'types.IntWithAggregatesFilter']
    consumableSave: Union[_str, 'types.StringWithAggregatesFilter']
    semiPermanentDamageAvg: Union[_int, 'types.IntWithAggregatesFilter']
    semiPermSave: Union[_str, 'types.StringWithAggregatesFilter']
    durationMinutes: Union[_int, 'types.IntWithAggregatesFilter']
    permanentDamageAvg: Union[_int, 'types.IntWithAggregatesFilter']
    permSave: Union[_str, 'types.StringWithAggregatesFilter']
    specificSituations: Union[_str, 'types.StringWithAggregatesFilter']
    restoreHpAvg: Union[_int, 'types.IntWithAggregatesFilter']
    miscCosts: Union[_int, 'types.IntWithAggregatesFilter']
    secondSpellLevel: Union[_int, 'types.IntWithAggregatesFilter']
    secondUnlimitedCharges: Union[_str, 'types.StringWithAggregatesFilter']
    secondChargesPerDay: Union[_int, 'types.IntWithAggregatesFilter']
    thirdSpellLevel: Union[_int, 'types.IntWithAggregatesFilter']
    thirdUnlimitedCharges: Union[_str, 'types.StringWithAggregatesFilter']
    thirdChargesPerDay: Union[_int, 'types.IntWithAggregatesFilter']
    matCost: Union[_int, 'types.IntWithAggregatesFilter']
    acCost: Union[_int, 'types.IntWithAggregatesFilter']
    saveCost: Union[_int, 'types.IntWithAggregatesFilter']
    setScoreCost: Union[_int, 'types.IntWithAggregatesFilter']
    bonusScoreCost: Union[_int, 'types.IntWithAggregatesFilter']
    weaponCost: Union[_int, 'types.IntWithAggregatesFilter']
    consumSpellCost: Union[_int, 'types.IntWithAggregatesFilter']
    permChargesCost: Union[_int, 'types.IntWithAggregatesFilter']
    chargesDestroyed: Union[_int, 'types.IntWithAggregatesFilter']
    spellShareChargesCost: Union[_int, 'types.IntWithAggregatesFilter']
    conditionCost: Union[_int, 'types.IntWithAggregatesFilter']
    consDMGCost: Union[_int, 'types.IntWithAggregatesFilter']
    smPrDMGCost: Union[_int, 'types.IntWithAggregatesFilter']
    perDMGCost: Union[_int, 'types.IntWithAggregatesFilter']
    avgHPCost: Union[_int, 'types.IntWithAggregatesFilter']
    miscCost: Union[_int, 'types.IntWithAggregatesFilter']
    secondConsumSpellCost: Union[_int, 'types.IntWithAggregatesFilter']
    secondPermChargesCost: Union[_int, 'types.IntWithAggregatesFilter']
    thirdConsumSpellCost: Union[_int, 'types.IntWithAggregatesFilter']
    thirdPermChargesCost: Union[_int, 'types.IntWithAggregatesFilter']



class MagicItemGroupByOutput(TypedDict, total=False):
    id: _int
    name: _str
    rarity: _str
    attunement: _str
    costGp: _int
    note: _str
    armorCost: _int
    rareMaterial: _str
    acBonus: _int
    saveBonus: _int
    setScoreModifier: _int
    plusTwoBonusToScore: _str
    weaponBonus: _int
    spellLevel: _int
    unlimitedCharges: _str
    chargesPerDay: _int
    chargesPerItem: _int
    spellsShareCharges: _int
    condition: _str
    consumableDamageAvg: _int
    consumableSave: _str
    semiPermanentDamageAvg: _int
    semiPermSave: _str
    durationMinutes: _int
    permanentDamageAvg: _int
    permSave: _str
    specificSituations: _str
    restoreHpAvg: _int
    miscCosts: _int
    secondSpellLevel: _int
    secondUnlimitedCharges: _str
    secondChargesPerDay: _int
    thirdSpellLevel: _int
    thirdUnlimitedCharges: _str
    thirdChargesPerDay: _int
    matCost: _int
    acCost: _int
    saveCost: _int
    setScoreCost: _int
    bonusScoreCost: _int
    weaponCost: _int
    consumSpellCost: _int
    permChargesCost: _int
    chargesDestroyed: _int
    spellShareChargesCost: _int
    conditionCost: _int
    consDMGCost: _int
    smPrDMGCost: _int
    perDMGCost: _int
    avgHPCost: _int
    miscCost: _int
    secondConsumSpellCost: _int
    secondPermChargesCost: _int
    thirdConsumSpellCost: _int
    thirdPermChargesCost: _int
    _sum: 'MagicItemSumAggregateOutput'
    _avg: 'MagicItemAvgAggregateOutput'
    _min: 'MagicItemMinAggregateOutput'
    _max: 'MagicItemMaxAggregateOutput'
    _count: 'MagicItemCountAggregateOutput'


class MagicItemAvgAggregateOutput(TypedDict, total=False):
    """MagicItem output for aggregating averages"""
    id: float
    costGp: float
    armorCost: float
    acBonus: float
    saveBonus: float
    setScoreModifier: float
    weaponBonus: float
    spellLevel: float
    chargesPerDay: float
    chargesPerItem: float
    spellsShareCharges: float
    consumableDamageAvg: float
    semiPermanentDamageAvg: float
    durationMinutes: float
    permanentDamageAvg: float
    restoreHpAvg: float
    miscCosts: float
    secondSpellLevel: float
    secondChargesPerDay: float
    thirdSpellLevel: float
    thirdChargesPerDay: float
    matCost: float
    acCost: float
    saveCost: float
    setScoreCost: float
    bonusScoreCost: float
    weaponCost: float
    consumSpellCost: float
    permChargesCost: float
    chargesDestroyed: float
    spellShareChargesCost: float
    conditionCost: float
    consDMGCost: float
    smPrDMGCost: float
    perDMGCost: float
    avgHPCost: float
    miscCost: float
    secondConsumSpellCost: float
    secondPermChargesCost: float
    thirdConsumSpellCost: float
    thirdPermChargesCost: float


class MagicItemSumAggregateOutput(TypedDict, total=False):
    """MagicItem output for aggregating sums"""
    id: _int
    costGp: _int
    armorCost: _int
    acBonus: _int
    saveBonus: _int
    setScoreModifier: _int
    weaponBonus: _int
    spellLevel: _int
    chargesPerDay: _int
    chargesPerItem: _int
    spellsShareCharges: _int
    consumableDamageAvg: _int
    semiPermanentDamageAvg: _int
    durationMinutes: _int
    permanentDamageAvg: _int
    restoreHpAvg: _int
    miscCosts: _int
    secondSpellLevel: _int
    secondChargesPerDay: _int
    thirdSpellLevel: _int
    thirdChargesPerDay: _int
    matCost: _int
    acCost: _int
    saveCost: _int
    setScoreCost: _int
    bonusScoreCost: _int
    weaponCost: _int
    consumSpellCost: _int
    permChargesCost: _int
    chargesDestroyed: _int
    spellShareChargesCost: _int
    conditionCost: _int
    consDMGCost: _int
    smPrDMGCost: _int
    perDMGCost: _int
    avgHPCost: _int
    miscCost: _int
    secondConsumSpellCost: _int
    secondPermChargesCost: _int
    thirdConsumSpellCost: _int
    thirdPermChargesCost: _int


class MagicItemScalarAggregateOutput(TypedDict, total=False):
    """MagicItem output including scalar fields"""
    id: _int
    name: _str
    rarity: _str
    attunement: _str
    costGp: _int
    note: _str
    armorCost: _int
    rareMaterial: _str
    acBonus: _int
    saveBonus: _int
    setScoreModifier: _int
    plusTwoBonusToScore: _str
    weaponBonus: _int
    spellLevel: _int
    unlimitedCharges: _str
    chargesPerDay: _int
    chargesPerItem: _int
    spellsShareCharges: _int
    condition: _str
    consumableDamageAvg: _int
    consumableSave: _str
    semiPermanentDamageAvg: _int
    semiPermSave: _str
    durationMinutes: _int
    permanentDamageAvg: _int
    permSave: _str
    specificSituations: _str
    restoreHpAvg: _int
    miscCosts: _int
    secondSpellLevel: _int
    secondUnlimitedCharges: _str
    secondChargesPerDay: _int
    thirdSpellLevel: _int
    thirdUnlimitedCharges: _str
    thirdChargesPerDay: _int
    matCost: _int
    acCost: _int
    saveCost: _int
    setScoreCost: _int
    bonusScoreCost: _int
    weaponCost: _int
    consumSpellCost: _int
    permChargesCost: _int
    chargesDestroyed: _int
    spellShareChargesCost: _int
    conditionCost: _int
    consDMGCost: _int
    smPrDMGCost: _int
    perDMGCost: _int
    avgHPCost: _int
    miscCost: _int
    secondConsumSpellCost: _int
    secondPermChargesCost: _int
    thirdConsumSpellCost: _int
    thirdPermChargesCost: _int


MagicItemMinAggregateOutput = MagicItemScalarAggregateOutput
MagicItemMaxAggregateOutput = MagicItemScalarAggregateOutput


class MagicItemMaxAggregateInput(TypedDict, total=False):
    """MagicItem input for aggregating by max"""
    id: bool
    name: bool
    rarity: bool
    attunement: bool
    costGp: bool
    note: bool
    armorCost: bool
    rareMaterial: bool
    acBonus: bool
    saveBonus: bool
    setScoreModifier: bool
    plusTwoBonusToScore: bool
    weaponBonus: bool
    spellLevel: bool
    unlimitedCharges: bool
    chargesPerDay: bool
    chargesPerItem: bool
    spellsShareCharges: bool
    condition: bool
    consumableDamageAvg: bool
    consumableSave: bool
    semiPermanentDamageAvg: bool
    semiPermSave: bool
    durationMinutes: bool
    permanentDamageAvg: bool
    permSave: bool
    specificSituations: bool
    restoreHpAvg: bool
    miscCosts: bool
    secondSpellLevel: bool
    secondUnlimitedCharges: bool
    secondChargesPerDay: bool
    thirdSpellLevel: bool
    thirdUnlimitedCharges: bool
    thirdChargesPerDay: bool
    matCost: bool
    acCost: bool
    saveCost: bool
    setScoreCost: bool
    bonusScoreCost: bool
    weaponCost: bool
    consumSpellCost: bool
    permChargesCost: bool
    chargesDestroyed: bool
    spellShareChargesCost: bool
    conditionCost: bool
    consDMGCost: bool
    smPrDMGCost: bool
    perDMGCost: bool
    avgHPCost: bool
    miscCost: bool
    secondConsumSpellCost: bool
    secondPermChargesCost: bool
    thirdConsumSpellCost: bool
    thirdPermChargesCost: bool


class MagicItemMinAggregateInput(TypedDict, total=False):
    """MagicItem input for aggregating by min"""
    id: bool
    name: bool
    rarity: bool
    attunement: bool
    costGp: bool
    note: bool
    armorCost: bool
    rareMaterial: bool
    acBonus: bool
    saveBonus: bool
    setScoreModifier: bool
    plusTwoBonusToScore: bool
    weaponBonus: bool
    spellLevel: bool
    unlimitedCharges: bool
    chargesPerDay: bool
    chargesPerItem: bool
    spellsShareCharges: bool
    condition: bool
    consumableDamageAvg: bool
    consumableSave: bool
    semiPermanentDamageAvg: bool
    semiPermSave: bool
    durationMinutes: bool
    permanentDamageAvg: bool
    permSave: bool
    specificSituations: bool
    restoreHpAvg: bool
    miscCosts: bool
    secondSpellLevel: bool
    secondUnlimitedCharges: bool
    secondChargesPerDay: bool
    thirdSpellLevel: bool
    thirdUnlimitedCharges: bool
    thirdChargesPerDay: bool
    matCost: bool
    acCost: bool
    saveCost: bool
    setScoreCost: bool
    bonusScoreCost: bool
    weaponCost: bool
    consumSpellCost: bool
    permChargesCost: bool
    chargesDestroyed: bool
    spellShareChargesCost: bool
    conditionCost: bool
    consDMGCost: bool
    smPrDMGCost: bool
    perDMGCost: bool
    avgHPCost: bool
    miscCost: bool
    secondConsumSpellCost: bool
    secondPermChargesCost: bool
    thirdConsumSpellCost: bool
    thirdPermChargesCost: bool


class MagicItemNumberAggregateInput(TypedDict, total=False):
    """MagicItem input for aggregating numbers"""
    id: bool
    costGp: bool
    armorCost: bool
    acBonus: bool
    saveBonus: bool
    setScoreModifier: bool
    weaponBonus: bool
    spellLevel: bool
    chargesPerDay: bool
    chargesPerItem: bool
    spellsShareCharges: bool
    consumableDamageAvg: bool
    semiPermanentDamageAvg: bool
    durationMinutes: bool
    permanentDamageAvg: bool
    restoreHpAvg: bool
    miscCosts: bool
    secondSpellLevel: bool
    secondChargesPerDay: bool
    thirdSpellLevel: bool
    thirdChargesPerDay: bool
    matCost: bool
    acCost: bool
    saveCost: bool
    setScoreCost: bool
    bonusScoreCost: bool
    weaponCost: bool
    consumSpellCost: bool
    permChargesCost: bool
    chargesDestroyed: bool
    spellShareChargesCost: bool
    conditionCost: bool
    consDMGCost: bool
    smPrDMGCost: bool
    perDMGCost: bool
    avgHPCost: bool
    miscCost: bool
    secondConsumSpellCost: bool
    secondPermChargesCost: bool
    thirdConsumSpellCost: bool
    thirdPermChargesCost: bool


MagicItemAvgAggregateInput = MagicItemNumberAggregateInput
MagicItemSumAggregateInput = MagicItemNumberAggregateInput


MagicItemCountAggregateInput = TypedDict(
    'MagicItemCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'rarity': bool,
        'attunement': bool,
        'costGp': bool,
        'note': bool,
        'armorCost': bool,
        'rareMaterial': bool,
        'acBonus': bool,
        'saveBonus': bool,
        'setScoreModifier': bool,
        'plusTwoBonusToScore': bool,
        'weaponBonus': bool,
        'spellLevel': bool,
        'unlimitedCharges': bool,
        'chargesPerDay': bool,
        'chargesPerItem': bool,
        'spellsShareCharges': bool,
        'condition': bool,
        'consumableDamageAvg': bool,
        'consumableSave': bool,
        'semiPermanentDamageAvg': bool,
        'semiPermSave': bool,
        'durationMinutes': bool,
        'permanentDamageAvg': bool,
        'permSave': bool,
        'specificSituations': bool,
        'restoreHpAvg': bool,
        'miscCosts': bool,
        'secondSpellLevel': bool,
        'secondUnlimitedCharges': bool,
        'secondChargesPerDay': bool,
        'thirdSpellLevel': bool,
        'thirdUnlimitedCharges': bool,
        'thirdChargesPerDay': bool,
        'matCost': bool,
        'acCost': bool,
        'saveCost': bool,
        'setScoreCost': bool,
        'bonusScoreCost': bool,
        'weaponCost': bool,
        'consumSpellCost': bool,
        'permChargesCost': bool,
        'chargesDestroyed': bool,
        'spellShareChargesCost': bool,
        'conditionCost': bool,
        'consDMGCost': bool,
        'smPrDMGCost': bool,
        'perDMGCost': bool,
        'avgHPCost': bool,
        'miscCost': bool,
        'secondConsumSpellCost': bool,
        'secondPermChargesCost': bool,
        'thirdConsumSpellCost': bool,
        'thirdPermChargesCost': bool,
        '_all': bool,
    },
    total=False,
)

MagicItemCountAggregateOutput = TypedDict(
    'MagicItemCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'rarity': int,
        'attunement': int,
        'costGp': int,
        'note': int,
        'armorCost': int,
        'rareMaterial': int,
        'acBonus': int,
        'saveBonus': int,
        'setScoreModifier': int,
        'plusTwoBonusToScore': int,
        'weaponBonus': int,
        'spellLevel': int,
        'unlimitedCharges': int,
        'chargesPerDay': int,
        'chargesPerItem': int,
        'spellsShareCharges': int,
        'condition': int,
        'consumableDamageAvg': int,
        'consumableSave': int,
        'semiPermanentDamageAvg': int,
        'semiPermSave': int,
        'durationMinutes': int,
        'permanentDamageAvg': int,
        'permSave': int,
        'specificSituations': int,
        'restoreHpAvg': int,
        'miscCosts': int,
        'secondSpellLevel': int,
        'secondUnlimitedCharges': int,
        'secondChargesPerDay': int,
        'thirdSpellLevel': int,
        'thirdUnlimitedCharges': int,
        'thirdChargesPerDay': int,
        'matCost': int,
        'acCost': int,
        'saveCost': int,
        'setScoreCost': int,
        'bonusScoreCost': int,
        'weaponCost': int,
        'consumSpellCost': int,
        'permChargesCost': int,
        'chargesDestroyed': int,
        'spellShareChargesCost': int,
        'conditionCost': int,
        'consDMGCost': int,
        'smPrDMGCost': int,
        'perDMGCost': int,
        'avgHPCost': int,
        'miscCost': int,
        'secondConsumSpellCost': int,
        'secondPermChargesCost': int,
        'thirdConsumSpellCost': int,
        'thirdPermChargesCost': int,
        '_all': int,
    },
    total=False,
)


MagicItemKeys = Literal[
    'id',
    'name',
    'rarity',
    'attunement',
    'costGp',
    'note',
    'armorCost',
    'rareMaterial',
    'acBonus',
    'saveBonus',
    'setScoreModifier',
    'plusTwoBonusToScore',
    'weaponBonus',
    'spellLevel',
    'unlimitedCharges',
    'chargesPerDay',
    'chargesPerItem',
    'spellsShareCharges',
    'condition',
    'consumableDamageAvg',
    'consumableSave',
    'semiPermanentDamageAvg',
    'semiPermSave',
    'durationMinutes',
    'permanentDamageAvg',
    'permSave',
    'specificSituations',
    'restoreHpAvg',
    'miscCosts',
    'secondSpellLevel',
    'secondUnlimitedCharges',
    'secondChargesPerDay',
    'thirdSpellLevel',
    'thirdUnlimitedCharges',
    'thirdChargesPerDay',
    'matCost',
    'acCost',
    'saveCost',
    'setScoreCost',
    'bonusScoreCost',
    'weaponCost',
    'consumSpellCost',
    'permChargesCost',
    'chargesDestroyed',
    'spellShareChargesCost',
    'conditionCost',
    'consDMGCost',
    'smPrDMGCost',
    'perDMGCost',
    'avgHPCost',
    'miscCost',
    'secondConsumSpellCost',
    'secondPermChargesCost',
    'thirdConsumSpellCost',
    'thirdPermChargesCost',
]
MagicItemScalarFieldKeys = Literal[
    'id',
    'name',
    'rarity',
    'attunement',
    'costGp',
    'note',
    'armorCost',
    'rareMaterial',
    'acBonus',
    'saveBonus',
    'setScoreModifier',
    'plusTwoBonusToScore',
    'weaponBonus',
    'spellLevel',
    'unlimitedCharges',
    'chargesPerDay',
    'chargesPerItem',
    'spellsShareCharges',
    'condition',
    'consumableDamageAvg',
    'consumableSave',
    'semiPermanentDamageAvg',
    'semiPermSave',
    'durationMinutes',
    'permanentDamageAvg',
    'permSave',
    'specificSituations',
    'restoreHpAvg',
    'miscCosts',
    'secondSpellLevel',
    'secondUnlimitedCharges',
    'secondChargesPerDay',
    'thirdSpellLevel',
    'thirdUnlimitedCharges',
    'thirdChargesPerDay',
    'matCost',
    'acCost',
    'saveCost',
    'setScoreCost',
    'bonusScoreCost',
    'weaponCost',
    'consumSpellCost',
    'permChargesCost',
    'chargesDestroyed',
    'spellShareChargesCost',
    'conditionCost',
    'consDMGCost',
    'smPrDMGCost',
    'perDMGCost',
    'avgHPCost',
    'miscCost',
    'secondConsumSpellCost',
    'secondPermChargesCost',
    'thirdConsumSpellCost',
    'thirdPermChargesCost',
]
MagicItemScalarFieldKeysT = TypeVar('MagicItemScalarFieldKeysT', bound=MagicItemScalarFieldKeys)

MagicItemRelationalFieldKeys = _NoneType

# GeneralEquipment types

class GeneralEquipmentOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the GeneralEquipment create method"""
    id: _int
    weightLbs: Optional[_str]


class GeneralEquipmentCreateInput(GeneralEquipmentOptionalCreateInput):
    """Required arguments to the GeneralEquipment create method"""
    name: _str
    cost: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class GeneralEquipmentOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the GeneralEquipment create method, without relations"""
    id: _int
    weightLbs: Optional[_str]


class GeneralEquipmentCreateWithoutRelationsInput(GeneralEquipmentOptionalCreateWithoutRelationsInput):
    """Required arguments to the GeneralEquipment create method, without relations"""
    name: _str
    cost: _str

class GeneralEquipmentConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'GeneralEquipmentCreateWithoutRelationsInput'
    where: 'GeneralEquipmentWhereUniqueInput'

class GeneralEquipmentCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'GeneralEquipmentCreateWithoutRelationsInput'
    connect: 'GeneralEquipmentWhereUniqueInput'
    connect_or_create: 'GeneralEquipmentConnectOrCreateWithoutRelationsInput'


class GeneralEquipmentCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['GeneralEquipmentCreateWithoutRelationsInput', List['GeneralEquipmentCreateWithoutRelationsInput']]
    connect: Union['GeneralEquipmentWhereUniqueInput', List['GeneralEquipmentWhereUniqueInput']]
    connect_or_create: Union['GeneralEquipmentConnectOrCreateWithoutRelationsInput', List['GeneralEquipmentConnectOrCreateWithoutRelationsInput']]

_GeneralEquipmentWhereUnique_id_Input = TypedDict(
    '_GeneralEquipmentWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_GeneralEquipmentWhereUnique_name_Input = TypedDict(
    '_GeneralEquipmentWhereUnique_name_Input',
    {
        'name': '_str',
    },
    total=True
)

GeneralEquipmentWhereUniqueInput = Union[
    '_GeneralEquipmentWhereUnique_id_Input',
    '_GeneralEquipmentWhereUnique_name_Input',
]


class GeneralEquipmentUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    name: _str
    cost: _str
    weightLbs: Optional[_str]


class GeneralEquipmentUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    name: _str
    cost: _str
    weightLbs: Optional[_str]


class GeneralEquipmentUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['GeneralEquipmentCreateWithoutRelationsInput']
    connect: List['GeneralEquipmentWhereUniqueInput']
    connect_or_create: List['GeneralEquipmentConnectOrCreateWithoutRelationsInput']
    set: List['GeneralEquipmentWhereUniqueInput']
    disconnect: List['GeneralEquipmentWhereUniqueInput']
    delete: List['GeneralEquipmentWhereUniqueInput']

    # TODO
    # update: List['GeneralEquipmentUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['GeneralEquipmentUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['GeneralEquipmentScalarWhereInput']
    # upsert: List['GeneralEquipmentUpserteWithWhereUniqueWithoutRelationsInput']


class GeneralEquipmentUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'GeneralEquipmentCreateWithoutRelationsInput'
    connect: 'GeneralEquipmentWhereUniqueInput'
    connect_or_create: 'GeneralEquipmentConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'GeneralEquipmentUpdateInput'
    # upsert: 'GeneralEquipmentUpsertWithoutRelationsInput'


class GeneralEquipmentUpsertInput(TypedDict):
    create: 'GeneralEquipmentCreateInput'
    update: 'GeneralEquipmentUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_GeneralEquipment_id_OrderByInput = TypedDict(
    '_GeneralEquipment_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_GeneralEquipment_name_OrderByInput = TypedDict(
    '_GeneralEquipment_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_GeneralEquipment_cost_OrderByInput = TypedDict(
    '_GeneralEquipment_cost_OrderByInput',
    {
        'cost': 'SortOrder',
    },
    total=True
)

_GeneralEquipment_weightLbs_OrderByInput = TypedDict(
    '_GeneralEquipment_weightLbs_OrderByInput',
    {
        'weightLbs': 'SortOrder',
    },
    total=True
)

_GeneralEquipment_RelevanceInner = TypedDict(
    '_GeneralEquipment_RelevanceInner',
    {
        'fields': 'List[GeneralEquipmentScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_GeneralEquipment_RelevanceOrderByInput = TypedDict(
    '_GeneralEquipment_RelevanceOrderByInput',
    {
        '_relevance': '_GeneralEquipment_RelevanceInner',
    },
    total=True
)

GeneralEquipmentOrderByInput = Union[
    '_GeneralEquipment_id_OrderByInput',
    '_GeneralEquipment_name_OrderByInput',
    '_GeneralEquipment_cost_OrderByInput',
    '_GeneralEquipment_weightLbs_OrderByInput',
    '_GeneralEquipment_RelevanceOrderByInput',
]



# recursive GeneralEquipment types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

GeneralEquipmentRelationFilter = TypedDict(
    'GeneralEquipmentRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class GeneralEquipmentListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class GeneralEquipmentInclude(TypedDict, total=False):
    """GeneralEquipment relational arguments"""


    

class MonsterIncludeFromGeneralEquipment(TypedDict, total=False):
    """Relational arguments for GeneralEquipment"""


class MonsterIncludeFromGeneralEquipmentRecursive1(TypedDict, total=False):
    """Relational arguments for GeneralEquipment"""


class MonsterIncludeFromGeneralEquipmentRecursive2(TypedDict, total=False):
    """Relational arguments for GeneralEquipment"""


class MonsterIncludeFromGeneralEquipmentRecursive3(TypedDict, total=False):
    """Relational arguments for GeneralEquipment"""


class MonsterIncludeFromGeneralEquipmentRecursive4(TypedDict, total=False):
    """Relational arguments for GeneralEquipment"""

    

class MonsterArgsFromGeneralEquipment(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    include: 'MonsterIncludeFromMonsterRecursive1'


class MonsterArgsFromGeneralEquipmentRecursive1(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    include: 'MonsterIncludeFromMonsterRecursive2'


class MonsterArgsFromGeneralEquipmentRecursive2(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    include: 'MonsterIncludeFromMonsterRecursive3'


class MonsterArgsFromGeneralEquipmentRecursive3(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    include: 'MonsterIncludeFromMonsterRecursive4'


class MonsterArgsFromGeneralEquipmentRecursive4(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    
    

class FindManyMonsterArgsFromGeneralEquipment(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    take: int
    skip: int
    order_by: Union['MonsterOrderByInput', List['MonsterOrderByInput']]
    where: 'MonsterWhereInput'
    cursor: 'MonsterWhereUniqueInput'
    distinct: List['MonsterScalarFieldKeys']
    include: 'MonsterIncludeFromMonsterRecursive1'


class FindManyMonsterArgsFromGeneralEquipmentRecursive1(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    take: int
    skip: int
    order_by: Union['MonsterOrderByInput', List['MonsterOrderByInput']]
    where: 'MonsterWhereInput'
    cursor: 'MonsterWhereUniqueInput'
    distinct: List['MonsterScalarFieldKeys']
    include: 'MonsterIncludeFromMonsterRecursive2'


class FindManyMonsterArgsFromGeneralEquipmentRecursive2(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    take: int
    skip: int
    order_by: Union['MonsterOrderByInput', List['MonsterOrderByInput']]
    where: 'MonsterWhereInput'
    cursor: 'MonsterWhereUniqueInput'
    distinct: List['MonsterScalarFieldKeys']
    include: 'MonsterIncludeFromMonsterRecursive3'


class FindManyMonsterArgsFromGeneralEquipmentRecursive3(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    take: int
    skip: int
    order_by: Union['MonsterOrderByInput', List['MonsterOrderByInput']]
    where: 'MonsterWhereInput'
    cursor: 'MonsterWhereUniqueInput'
    distinct: List['MonsterScalarFieldKeys']
    include: 'MonsterIncludeFromMonsterRecursive4'


class FindManyMonsterArgsFromGeneralEquipmentRecursive4(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    take: int
    skip: int
    order_by: Union['MonsterOrderByInput', List['MonsterOrderByInput']]
    where: 'MonsterWhereInput'
    cursor: 'MonsterWhereUniqueInput'
    distinct: List['MonsterScalarFieldKeys']
    
    

class RaceIncludeFromGeneralEquipment(TypedDict, total=False):
    """Relational arguments for GeneralEquipment"""


class RaceIncludeFromGeneralEquipmentRecursive1(TypedDict, total=False):
    """Relational arguments for GeneralEquipment"""


class RaceIncludeFromGeneralEquipmentRecursive2(TypedDict, total=False):
    """Relational arguments for GeneralEquipment"""


class RaceIncludeFromGeneralEquipmentRecursive3(TypedDict, total=False):
    """Relational arguments for GeneralEquipment"""


class RaceIncludeFromGeneralEquipmentRecursive4(TypedDict, total=False):
    """Relational arguments for GeneralEquipment"""

    

class RaceArgsFromGeneralEquipment(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    include: 'RaceIncludeFromRaceRecursive1'


class RaceArgsFromGeneralEquipmentRecursive1(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    include: 'RaceIncludeFromRaceRecursive2'


class RaceArgsFromGeneralEquipmentRecursive2(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    include: 'RaceIncludeFromRaceRecursive3'


class RaceArgsFromGeneralEquipmentRecursive3(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    include: 'RaceIncludeFromRaceRecursive4'


class RaceArgsFromGeneralEquipmentRecursive4(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    
    

class FindManyRaceArgsFromGeneralEquipment(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    take: int
    skip: int
    order_by: Union['RaceOrderByInput', List['RaceOrderByInput']]
    where: 'RaceWhereInput'
    cursor: 'RaceWhereUniqueInput'
    distinct: List['RaceScalarFieldKeys']
    include: 'RaceIncludeFromRaceRecursive1'


class FindManyRaceArgsFromGeneralEquipmentRecursive1(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    take: int
    skip: int
    order_by: Union['RaceOrderByInput', List['RaceOrderByInput']]
    where: 'RaceWhereInput'
    cursor: 'RaceWhereUniqueInput'
    distinct: List['RaceScalarFieldKeys']
    include: 'RaceIncludeFromRaceRecursive2'


class FindManyRaceArgsFromGeneralEquipmentRecursive2(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    take: int
    skip: int
    order_by: Union['RaceOrderByInput', List['RaceOrderByInput']]
    where: 'RaceWhereInput'
    cursor: 'RaceWhereUniqueInput'
    distinct: List['RaceScalarFieldKeys']
    include: 'RaceIncludeFromRaceRecursive3'


class FindManyRaceArgsFromGeneralEquipmentRecursive3(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    take: int
    skip: int
    order_by: Union['RaceOrderByInput', List['RaceOrderByInput']]
    where: 'RaceWhereInput'
    cursor: 'RaceWhereUniqueInput'
    distinct: List['RaceScalarFieldKeys']
    include: 'RaceIncludeFromRaceRecursive4'


class FindManyRaceArgsFromGeneralEquipmentRecursive4(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    take: int
    skip: int
    order_by: Union['RaceOrderByInput', List['RaceOrderByInput']]
    where: 'RaceWhereInput'
    cursor: 'RaceWhereUniqueInput'
    distinct: List['RaceScalarFieldKeys']
    
    

class SpellIncludeFromGeneralEquipment(TypedDict, total=False):
    """Relational arguments for GeneralEquipment"""


class SpellIncludeFromGeneralEquipmentRecursive1(TypedDict, total=False):
    """Relational arguments for GeneralEquipment"""


class SpellIncludeFromGeneralEquipmentRecursive2(TypedDict, total=False):
    """Relational arguments for GeneralEquipment"""


class SpellIncludeFromGeneralEquipmentRecursive3(TypedDict, total=False):
    """Relational arguments for GeneralEquipment"""


class SpellIncludeFromGeneralEquipmentRecursive4(TypedDict, total=False):
    """Relational arguments for GeneralEquipment"""

    

class SpellArgsFromGeneralEquipment(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    include: 'SpellIncludeFromSpellRecursive1'


class SpellArgsFromGeneralEquipmentRecursive1(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    include: 'SpellIncludeFromSpellRecursive2'


class SpellArgsFromGeneralEquipmentRecursive2(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    include: 'SpellIncludeFromSpellRecursive3'


class SpellArgsFromGeneralEquipmentRecursive3(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    include: 'SpellIncludeFromSpellRecursive4'


class SpellArgsFromGeneralEquipmentRecursive4(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    
    

class FindManySpellArgsFromGeneralEquipment(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    take: int
    skip: int
    order_by: Union['SpellOrderByInput', List['SpellOrderByInput']]
    where: 'SpellWhereInput'
    cursor: 'SpellWhereUniqueInput'
    distinct: List['SpellScalarFieldKeys']
    include: 'SpellIncludeFromSpellRecursive1'


class FindManySpellArgsFromGeneralEquipmentRecursive1(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    take: int
    skip: int
    order_by: Union['SpellOrderByInput', List['SpellOrderByInput']]
    where: 'SpellWhereInput'
    cursor: 'SpellWhereUniqueInput'
    distinct: List['SpellScalarFieldKeys']
    include: 'SpellIncludeFromSpellRecursive2'


class FindManySpellArgsFromGeneralEquipmentRecursive2(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    take: int
    skip: int
    order_by: Union['SpellOrderByInput', List['SpellOrderByInput']]
    where: 'SpellWhereInput'
    cursor: 'SpellWhereUniqueInput'
    distinct: List['SpellScalarFieldKeys']
    include: 'SpellIncludeFromSpellRecursive3'


class FindManySpellArgsFromGeneralEquipmentRecursive3(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    take: int
    skip: int
    order_by: Union['SpellOrderByInput', List['SpellOrderByInput']]
    where: 'SpellWhereInput'
    cursor: 'SpellWhereUniqueInput'
    distinct: List['SpellScalarFieldKeys']
    include: 'SpellIncludeFromSpellRecursive4'


class FindManySpellArgsFromGeneralEquipmentRecursive4(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    take: int
    skip: int
    order_by: Union['SpellOrderByInput', List['SpellOrderByInput']]
    where: 'SpellWhereInput'
    cursor: 'SpellWhereUniqueInput'
    distinct: List['SpellScalarFieldKeys']
    
    

class PlayerClassIncludeFromGeneralEquipment(TypedDict, total=False):
    """Relational arguments for GeneralEquipment"""


class PlayerClassIncludeFromGeneralEquipmentRecursive1(TypedDict, total=False):
    """Relational arguments for GeneralEquipment"""


class PlayerClassIncludeFromGeneralEquipmentRecursive2(TypedDict, total=False):
    """Relational arguments for GeneralEquipment"""


class PlayerClassIncludeFromGeneralEquipmentRecursive3(TypedDict, total=False):
    """Relational arguments for GeneralEquipment"""


class PlayerClassIncludeFromGeneralEquipmentRecursive4(TypedDict, total=False):
    """Relational arguments for GeneralEquipment"""

    

class PlayerClassArgsFromGeneralEquipment(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    include: 'PlayerClassIncludeFromPlayerClassRecursive1'


class PlayerClassArgsFromGeneralEquipmentRecursive1(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    include: 'PlayerClassIncludeFromPlayerClassRecursive2'


class PlayerClassArgsFromGeneralEquipmentRecursive2(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    include: 'PlayerClassIncludeFromPlayerClassRecursive3'


class PlayerClassArgsFromGeneralEquipmentRecursive3(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    include: 'PlayerClassIncludeFromPlayerClassRecursive4'


class PlayerClassArgsFromGeneralEquipmentRecursive4(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    
    

class FindManyPlayerClassArgsFromGeneralEquipment(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    take: int
    skip: int
    order_by: Union['PlayerClassOrderByInput', List['PlayerClassOrderByInput']]
    where: 'PlayerClassWhereInput'
    cursor: 'PlayerClassWhereUniqueInput'
    distinct: List['PlayerClassScalarFieldKeys']
    include: 'PlayerClassIncludeFromPlayerClassRecursive1'


class FindManyPlayerClassArgsFromGeneralEquipmentRecursive1(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    take: int
    skip: int
    order_by: Union['PlayerClassOrderByInput', List['PlayerClassOrderByInput']]
    where: 'PlayerClassWhereInput'
    cursor: 'PlayerClassWhereUniqueInput'
    distinct: List['PlayerClassScalarFieldKeys']
    include: 'PlayerClassIncludeFromPlayerClassRecursive2'


class FindManyPlayerClassArgsFromGeneralEquipmentRecursive2(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    take: int
    skip: int
    order_by: Union['PlayerClassOrderByInput', List['PlayerClassOrderByInput']]
    where: 'PlayerClassWhereInput'
    cursor: 'PlayerClassWhereUniqueInput'
    distinct: List['PlayerClassScalarFieldKeys']
    include: 'PlayerClassIncludeFromPlayerClassRecursive3'


class FindManyPlayerClassArgsFromGeneralEquipmentRecursive3(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    take: int
    skip: int
    order_by: Union['PlayerClassOrderByInput', List['PlayerClassOrderByInput']]
    where: 'PlayerClassWhereInput'
    cursor: 'PlayerClassWhereUniqueInput'
    distinct: List['PlayerClassScalarFieldKeys']
    include: 'PlayerClassIncludeFromPlayerClassRecursive4'


class FindManyPlayerClassArgsFromGeneralEquipmentRecursive4(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    take: int
    skip: int
    order_by: Union['PlayerClassOrderByInput', List['PlayerClassOrderByInput']]
    where: 'PlayerClassWhereInput'
    cursor: 'PlayerClassWhereUniqueInput'
    distinct: List['PlayerClassScalarFieldKeys']
    
    

class MagicItemIncludeFromGeneralEquipment(TypedDict, total=False):
    """Relational arguments for GeneralEquipment"""


class MagicItemIncludeFromGeneralEquipmentRecursive1(TypedDict, total=False):
    """Relational arguments for GeneralEquipment"""


class MagicItemIncludeFromGeneralEquipmentRecursive2(TypedDict, total=False):
    """Relational arguments for GeneralEquipment"""


class MagicItemIncludeFromGeneralEquipmentRecursive3(TypedDict, total=False):
    """Relational arguments for GeneralEquipment"""


class MagicItemIncludeFromGeneralEquipmentRecursive4(TypedDict, total=False):
    """Relational arguments for GeneralEquipment"""

    

class MagicItemArgsFromGeneralEquipment(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    include: 'MagicItemIncludeFromMagicItemRecursive1'


class MagicItemArgsFromGeneralEquipmentRecursive1(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    include: 'MagicItemIncludeFromMagicItemRecursive2'


class MagicItemArgsFromGeneralEquipmentRecursive2(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    include: 'MagicItemIncludeFromMagicItemRecursive3'


class MagicItemArgsFromGeneralEquipmentRecursive3(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    include: 'MagicItemIncludeFromMagicItemRecursive4'


class MagicItemArgsFromGeneralEquipmentRecursive4(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    
    

class FindManyMagicItemArgsFromGeneralEquipment(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    take: int
    skip: int
    order_by: Union['MagicItemOrderByInput', List['MagicItemOrderByInput']]
    where: 'MagicItemWhereInput'
    cursor: 'MagicItemWhereUniqueInput'
    distinct: List['MagicItemScalarFieldKeys']
    include: 'MagicItemIncludeFromMagicItemRecursive1'


class FindManyMagicItemArgsFromGeneralEquipmentRecursive1(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    take: int
    skip: int
    order_by: Union['MagicItemOrderByInput', List['MagicItemOrderByInput']]
    where: 'MagicItemWhereInput'
    cursor: 'MagicItemWhereUniqueInput'
    distinct: List['MagicItemScalarFieldKeys']
    include: 'MagicItemIncludeFromMagicItemRecursive2'


class FindManyMagicItemArgsFromGeneralEquipmentRecursive2(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    take: int
    skip: int
    order_by: Union['MagicItemOrderByInput', List['MagicItemOrderByInput']]
    where: 'MagicItemWhereInput'
    cursor: 'MagicItemWhereUniqueInput'
    distinct: List['MagicItemScalarFieldKeys']
    include: 'MagicItemIncludeFromMagicItemRecursive3'


class FindManyMagicItemArgsFromGeneralEquipmentRecursive3(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    take: int
    skip: int
    order_by: Union['MagicItemOrderByInput', List['MagicItemOrderByInput']]
    where: 'MagicItemWhereInput'
    cursor: 'MagicItemWhereUniqueInput'
    distinct: List['MagicItemScalarFieldKeys']
    include: 'MagicItemIncludeFromMagicItemRecursive4'


class FindManyMagicItemArgsFromGeneralEquipmentRecursive4(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    take: int
    skip: int
    order_by: Union['MagicItemOrderByInput', List['MagicItemOrderByInput']]
    where: 'MagicItemWhereInput'
    cursor: 'MagicItemWhereUniqueInput'
    distinct: List['MagicItemScalarFieldKeys']
    
    

class GeneralEquipmentIncludeFromGeneralEquipment(TypedDict, total=False):
    """Relational arguments for GeneralEquipment"""


class GeneralEquipmentIncludeFromGeneralEquipmentRecursive1(TypedDict, total=False):
    """Relational arguments for GeneralEquipment"""


class GeneralEquipmentIncludeFromGeneralEquipmentRecursive2(TypedDict, total=False):
    """Relational arguments for GeneralEquipment"""


class GeneralEquipmentIncludeFromGeneralEquipmentRecursive3(TypedDict, total=False):
    """Relational arguments for GeneralEquipment"""


class GeneralEquipmentIncludeFromGeneralEquipmentRecursive4(TypedDict, total=False):
    """Relational arguments for GeneralEquipment"""

    

class GeneralEquipmentArgsFromGeneralEquipment(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive1'


class GeneralEquipmentArgsFromGeneralEquipmentRecursive1(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive2'


class GeneralEquipmentArgsFromGeneralEquipmentRecursive2(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive3'


class GeneralEquipmentArgsFromGeneralEquipmentRecursive3(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive4'


class GeneralEquipmentArgsFromGeneralEquipmentRecursive4(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    
    

class FindManyGeneralEquipmentArgsFromGeneralEquipment(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    take: int
    skip: int
    order_by: Union['GeneralEquipmentOrderByInput', List['GeneralEquipmentOrderByInput']]
    where: 'GeneralEquipmentWhereInput'
    cursor: 'GeneralEquipmentWhereUniqueInput'
    distinct: List['GeneralEquipmentScalarFieldKeys']
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive1'


class FindManyGeneralEquipmentArgsFromGeneralEquipmentRecursive1(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    take: int
    skip: int
    order_by: Union['GeneralEquipmentOrderByInput', List['GeneralEquipmentOrderByInput']]
    where: 'GeneralEquipmentWhereInput'
    cursor: 'GeneralEquipmentWhereUniqueInput'
    distinct: List['GeneralEquipmentScalarFieldKeys']
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive2'


class FindManyGeneralEquipmentArgsFromGeneralEquipmentRecursive2(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    take: int
    skip: int
    order_by: Union['GeneralEquipmentOrderByInput', List['GeneralEquipmentOrderByInput']]
    where: 'GeneralEquipmentWhereInput'
    cursor: 'GeneralEquipmentWhereUniqueInput'
    distinct: List['GeneralEquipmentScalarFieldKeys']
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive3'


class FindManyGeneralEquipmentArgsFromGeneralEquipmentRecursive3(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    take: int
    skip: int
    order_by: Union['GeneralEquipmentOrderByInput', List['GeneralEquipmentOrderByInput']]
    where: 'GeneralEquipmentWhereInput'
    cursor: 'GeneralEquipmentWhereUniqueInput'
    distinct: List['GeneralEquipmentScalarFieldKeys']
    include: 'GeneralEquipmentIncludeFromGeneralEquipmentRecursive4'


class FindManyGeneralEquipmentArgsFromGeneralEquipmentRecursive4(TypedDict, total=False):
    """Arguments for GeneralEquipment"""
    take: int
    skip: int
    order_by: Union['GeneralEquipmentOrderByInput', List['GeneralEquipmentOrderByInput']]
    where: 'GeneralEquipmentWhereInput'
    cursor: 'GeneralEquipmentWhereUniqueInput'
    distinct: List['GeneralEquipmentScalarFieldKeys']
    


FindManyGeneralEquipmentArgs = FindManyGeneralEquipmentArgsFromGeneralEquipment
FindFirstGeneralEquipmentArgs = FindManyGeneralEquipmentArgsFromGeneralEquipment


    

class GeneralEquipmentWhereInput(TypedDict, total=False):
    """GeneralEquipment arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    cost: Union[_str, 'types.StringFilter']
    weightLbs: Union[None, _str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['GeneralEquipmentWhereInputRecursive1', List['GeneralEquipmentWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['GeneralEquipmentWhereInputRecursive1']
    OR: List['GeneralEquipmentWhereInputRecursive1']
    NOT: List['GeneralEquipmentWhereInputRecursive1']


class GeneralEquipmentWhereInputRecursive1(TypedDict, total=False):
    """GeneralEquipment arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    cost: Union[_str, 'types.StringFilter']
    weightLbs: Union[None, _str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['GeneralEquipmentWhereInputRecursive2', List['GeneralEquipmentWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['GeneralEquipmentWhereInputRecursive2']
    OR: List['GeneralEquipmentWhereInputRecursive2']
    NOT: List['GeneralEquipmentWhereInputRecursive2']


class GeneralEquipmentWhereInputRecursive2(TypedDict, total=False):
    """GeneralEquipment arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    cost: Union[_str, 'types.StringFilter']
    weightLbs: Union[None, _str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['GeneralEquipmentWhereInputRecursive3', List['GeneralEquipmentWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['GeneralEquipmentWhereInputRecursive3']
    OR: List['GeneralEquipmentWhereInputRecursive3']
    NOT: List['GeneralEquipmentWhereInputRecursive3']


class GeneralEquipmentWhereInputRecursive3(TypedDict, total=False):
    """GeneralEquipment arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    cost: Union[_str, 'types.StringFilter']
    weightLbs: Union[None, _str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['GeneralEquipmentWhereInputRecursive4', List['GeneralEquipmentWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['GeneralEquipmentWhereInputRecursive4']
    OR: List['GeneralEquipmentWhereInputRecursive4']
    NOT: List['GeneralEquipmentWhereInputRecursive4']


class GeneralEquipmentWhereInputRecursive4(TypedDict, total=False):
    """GeneralEquipment arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    cost: Union[_str, 'types.StringFilter']
    weightLbs: Union[None, _str, 'types.StringFilter']



# aggregate GeneralEquipment types


    

class GeneralEquipmentScalarWhereWithAggregatesInput(TypedDict, total=False):
    """GeneralEquipment arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    cost: Union[_str, 'types.StringWithAggregatesFilter']
    weightLbs: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['GeneralEquipmentScalarWhereWithAggregatesInputRecursive1']
    OR: List['GeneralEquipmentScalarWhereWithAggregatesInputRecursive1']
    NOT: List['GeneralEquipmentScalarWhereWithAggregatesInputRecursive1']


class GeneralEquipmentScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """GeneralEquipment arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    cost: Union[_str, 'types.StringWithAggregatesFilter']
    weightLbs: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['GeneralEquipmentScalarWhereWithAggregatesInputRecursive2']
    OR: List['GeneralEquipmentScalarWhereWithAggregatesInputRecursive2']
    NOT: List['GeneralEquipmentScalarWhereWithAggregatesInputRecursive2']


class GeneralEquipmentScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """GeneralEquipment arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    cost: Union[_str, 'types.StringWithAggregatesFilter']
    weightLbs: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['GeneralEquipmentScalarWhereWithAggregatesInputRecursive3']
    OR: List['GeneralEquipmentScalarWhereWithAggregatesInputRecursive3']
    NOT: List['GeneralEquipmentScalarWhereWithAggregatesInputRecursive3']


class GeneralEquipmentScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """GeneralEquipment arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    cost: Union[_str, 'types.StringWithAggregatesFilter']
    weightLbs: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['GeneralEquipmentScalarWhereWithAggregatesInputRecursive4']
    OR: List['GeneralEquipmentScalarWhereWithAggregatesInputRecursive4']
    NOT: List['GeneralEquipmentScalarWhereWithAggregatesInputRecursive4']


class GeneralEquipmentScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """GeneralEquipment arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    cost: Union[_str, 'types.StringWithAggregatesFilter']
    weightLbs: Union[_str, 'types.StringWithAggregatesFilter']



class GeneralEquipmentGroupByOutput(TypedDict, total=False):
    id: _int
    name: _str
    cost: _str
    weightLbs: _str
    _sum: 'GeneralEquipmentSumAggregateOutput'
    _avg: 'GeneralEquipmentAvgAggregateOutput'
    _min: 'GeneralEquipmentMinAggregateOutput'
    _max: 'GeneralEquipmentMaxAggregateOutput'
    _count: 'GeneralEquipmentCountAggregateOutput'


class GeneralEquipmentAvgAggregateOutput(TypedDict, total=False):
    """GeneralEquipment output for aggregating averages"""
    id: float


class GeneralEquipmentSumAggregateOutput(TypedDict, total=False):
    """GeneralEquipment output for aggregating sums"""
    id: _int


class GeneralEquipmentScalarAggregateOutput(TypedDict, total=False):
    """GeneralEquipment output including scalar fields"""
    id: _int
    name: _str
    cost: _str
    weightLbs: _str


GeneralEquipmentMinAggregateOutput = GeneralEquipmentScalarAggregateOutput
GeneralEquipmentMaxAggregateOutput = GeneralEquipmentScalarAggregateOutput


class GeneralEquipmentMaxAggregateInput(TypedDict, total=False):
    """GeneralEquipment input for aggregating by max"""
    id: bool
    name: bool
    cost: bool
    weightLbs: bool


class GeneralEquipmentMinAggregateInput(TypedDict, total=False):
    """GeneralEquipment input for aggregating by min"""
    id: bool
    name: bool
    cost: bool
    weightLbs: bool


class GeneralEquipmentNumberAggregateInput(TypedDict, total=False):
    """GeneralEquipment input for aggregating numbers"""
    id: bool


GeneralEquipmentAvgAggregateInput = GeneralEquipmentNumberAggregateInput
GeneralEquipmentSumAggregateInput = GeneralEquipmentNumberAggregateInput


GeneralEquipmentCountAggregateInput = TypedDict(
    'GeneralEquipmentCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'cost': bool,
        'weightLbs': bool,
        '_all': bool,
    },
    total=False,
)

GeneralEquipmentCountAggregateOutput = TypedDict(
    'GeneralEquipmentCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'cost': int,
        'weightLbs': int,
        '_all': int,
    },
    total=False,
)


GeneralEquipmentKeys = Literal[
    'id',
    'name',
    'cost',
    'weightLbs',
]
GeneralEquipmentScalarFieldKeys = Literal[
    'id',
    'name',
    'cost',
    'weightLbs',
]
GeneralEquipmentScalarFieldKeysT = TypeVar('GeneralEquipmentScalarFieldKeysT', bound=GeneralEquipmentScalarFieldKeys)

GeneralEquipmentRelationalFieldKeys = _NoneType



# we have to import ourselves as types can be namespaced to types
from . import types, enums, models, fields